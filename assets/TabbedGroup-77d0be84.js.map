{"version":3,"file":"TabbedGroup-77d0be84.js","sources":["../../node_modules/@rgossiaux/svelte-heroicons/solid/XCircle/XCircle.svelte","../../src/Logic/ExtraFunctions.ts","../../node_modules/trap-focus-svelte/dist/trap-focus-svelte.svelte.js","../../src/UI/Base/FloatOver.svelte","../../src/UI/Base/TabbedGroup.svelte"],"sourcesContent":["<!-- svelte-ignore a11y-mouse-events-have-key-events --><svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\" fill=\"currentColor\" aria-hidden=\"true\" {...$$restProps} on:click on:mouseover on:mouseenter on:mouseleave on:keydown><slot />\n  <path fill-rule=\"evenodd\" d=\"M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z\" clip-rule=\"evenodd\"/>\n</svg>","import { GeoOperations } from \"./GeoOperations\"\nimport Combine from \"../UI/Base/Combine\"\nimport BaseUIElement from \"../UI/BaseUIElement\"\nimport List from \"../UI/Base/List\"\nimport Title from \"../UI/Base/Title\"\nimport { BBox } from \"./BBox\"\nimport { Feature, Geometry, MultiPolygon, Polygon } from \"geojson\"\nimport { GeoJSONFeature } from \"maplibre-gl\"\n\nexport interface ExtraFuncParams {\n    /**\n     * Gets all the features from the given layer within the given BBOX.\n     * Note that more features then requested can be given back.\n     * Format: [ [ geojson, geojson, geojson, ... ], [geojson, ...], ...]\n     */\n    getFeaturesWithin: (\n        layerId: string,\n        bbox: BBox\n    ) => Feature<Geometry, Record<string, string>>[][]\n    getFeatureById: (id: string) => Feature<Geometry, Record<string, string>>\n}\n\n/**\n * Describes a function that is added to a geojson object in order to calculate calculated tags\n */\ninterface ExtraFunction {\n    readonly _name: string\n    readonly _args: string[]\n    readonly _doc: string\n    readonly _f: (params: ExtraFuncParams, feat: Feature<Geometry, any>) => any\n}\n\nclass EnclosingFunc implements ExtraFunction {\n    _name = \"enclosingFeatures\"\n    _doc = [\n        \"Gives a list of all features in the specified layers which fully contain this object. Returned features will always be (multi)polygons. (LineStrings and Points from the other layers are ignored)\",\n        \"\",\n        \"The result is a list of features: `{feat: Polygon}[]`\",\n        \"This function will never return the feature itself.\",\n    ].join(\"\\n\")\n    _args = [\n        \"...layerIds - one or more layer ids of the layer from which every feature is checked for overlap)\",\n    ]\n\n    _f(params: ExtraFuncParams, feat: Feature<Geometry, any>) {\n        return (...layerIds: string[]) => {\n            const result: { feat: any }[] = []\n            const bbox = BBox.get(feat)\n            const seenIds = new Set<string>()\n            seenIds.add(feat.properties.id)\n            for (const layerId of layerIds) {\n                const otherFeaturess = params.getFeaturesWithin(layerId, bbox)\n                if (otherFeaturess === undefined) {\n                    continue\n                }\n                if (otherFeaturess.length === 0) {\n                    continue\n                }\n                for (const otherFeatures of otherFeaturess) {\n                    for (const otherFeature of otherFeatures) {\n                        if (seenIds.has(otherFeature.properties.id)) {\n                            continue\n                        }\n                        seenIds.add(otherFeature.properties.id)\n                        if (\n                            otherFeature.geometry.type !== \"Polygon\" &&\n                            otherFeature.geometry.type !== \"MultiPolygon\"\n                        ) {\n                            continue\n                        }\n                        if (\n                            GeoOperations.completelyWithin(\n                                <Feature>feat,\n                                <Feature<Polygon | MultiPolygon, any>>otherFeature\n                            )\n                        ) {\n                            result.push({ feat: otherFeature })\n                        }\n                    }\n                }\n            }\n\n            return result\n        }\n    }\n}\n\nclass OverlapFunc implements ExtraFunction {\n    _name = \"overlapWith\"\n    _doc = [\n        \"Gives a list of features from the specified layer which this feature (partly) overlaps with. A point which is embedded in the feature is detected as well.\",\n        \"If the current feature is a point, all features that this point is embeded in are given.\",\n        \"\",\n        \"The returned value is `{ feat: GeoJSONFeature, overlap: number}[]` where `overlap` is the overlapping surface are (in mÂ²) for areas, the overlapping length (in meter) if the current feature is a line or `undefined` if the current feature is a point.\",\n        \"The resulting list is sorted in descending order by overlap. The feature with the most overlap will thus be the first in the list.\",\n        \"\",\n        \"For example to get all objects which overlap or embed from a layer, use `_contained_climbing_routes_properties=overlapWith(feat)('climbing_route')`\",\n        \"\",\n        \"Also see [enclosingFeatures](#enclosingFeatures) which can be used to get all objects which fully contain this feature\",\n    ].join(\"\\n\")\n    _args = [\n        \"...layerIds - one or more layer ids of the layer from which every feature is checked for overlap)\",\n    ]\n\n    _f(params, feat) {\n        return (...layerIds: string[]) => {\n            const result: { feat: any; overlap: number }[] = []\n            const seenIds = new Set<string>()\n            const bbox = BBox.get(feat)\n            for (const layerId of layerIds) {\n                const otherFeaturess = params.getFeaturesWithin(layerId, bbox)\n                if (otherFeaturess === undefined) {\n                    continue\n                }\n                if (otherFeaturess.length === 0) {\n                    continue\n                }\n                for (const otherFeatures of otherFeaturess) {\n                    const overlap = GeoOperations.calculateOverlap(feat, otherFeatures)\n                    for (const overlappingFeature of overlap) {\n                        if (seenIds.has(overlappingFeature.feat.properties.id)) {\n                            continue\n                        }\n                        seenIds.add(overlappingFeature.feat.properties.id)\n                        result.push(overlappingFeature)\n                    }\n                }\n            }\n\n            result.sort((a, b) => b.overlap - a.overlap)\n            return result\n        }\n    }\n}\n\nclass IntersectionFunc implements ExtraFunction {\n    _name = \"intersectionsWith\"\n    _doc =\n        \"Gives the intersection points with selected features. Only works with (Multi)Polygons and LineStrings.\\n\\n\" +\n        \"Returns a `{feat: GeoJson, intersections: [number,number][]}` where `feat` is the full, original feature. This list is in random order.\\n\\n\" +\n        \"If the current feature is a point, this function will return an empty list.\\n\" +\n        \"Points from other layers are ignored - even if the points are parts of the current linestring.\"\n    _args = [\n        \"...layerIds - one or more layer ids of the layer from which every feature is checked for intersection)\",\n    ]\n\n    _f(params: ExtraFuncParams, feat) {\n        return (...layerIds: string[]) => {\n            const result: { feat: any; intersections: [number, number][] }[] = []\n\n            const bbox = BBox.get(feat)\n\n            for (const layerId of layerIds) {\n                const otherLayers = params.getFeaturesWithin(layerId, bbox)\n                if (otherLayers === undefined) {\n                    continue\n                }\n                if (otherLayers.length === 0) {\n                    continue\n                }\n                for (const otherFeatures of otherLayers) {\n                    for (const otherFeature of otherFeatures) {\n                        const intersections = GeoOperations.LineIntersections(\n                            feat,\n                            <Feature<any, Record<string, string>>>otherFeature\n                        )\n                        if (intersections.length === 0) {\n                            continue\n                        }\n                        result.push({ feat: otherFeature, intersections })\n                    }\n                }\n            }\n\n            return result\n        }\n    }\n}\n\nclass DistanceToFunc implements ExtraFunction {\n    _name = \"distanceTo\"\n    _doc =\n        \"Calculates the distance between the feature and a specified point in meter. The input should either be a pair of coordinates, a geojson feature or the ID of an object\"\n    _args = [\"feature OR featureID OR longitude\", \"undefined OR latitude\"]\n\n    _f(featuresPerLayer, feature) {\n        return (arg0, lat) => {\n            if (arg0 === undefined) {\n                return undefined\n            }\n            if (typeof arg0 === \"number\") {\n                // Feature._lon and ._lat is conveniently place by one of the other metatags\n                return GeoOperations.distanceBetween(\n                    [arg0, lat],\n                    GeoOperations.centerpointCoordinates(feature)\n                )\n            }\n            if (typeof arg0 === \"string\") {\n                // This is an identifier\n                const feature = featuresPerLayer.getFeatureById(arg0)\n                if (feature === undefined) {\n                    return undefined\n                }\n                arg0 = feature\n            }\n\n            // arg0 is probably a geojsonfeature\n            return GeoOperations.distanceBetween(\n                GeoOperations.centerpointCoordinates(arg0),\n                GeoOperations.centerpointCoordinates(feature)\n            )\n        }\n    }\n}\n\nclass ClosestObjectFunc implements ExtraFunction {\n    _name = \"closest\"\n    _doc =\n        \"Given either a list of geojson features or a single layer name, gives the single object which is nearest to the feature. In the case of ways/polygons, only the centerpoint is considered. Returns a single geojson feature or undefined if nothing is found (or not yet loaded)\"\n\n    _args = [\"list of features or a layer name or '*' to get all features\"]\n\n    _f(params, feature) {\n        return (features) =>\n            ClosestNObjectFunc.GetClosestNFeatures(params, feature, features)?.[0]?.feat\n    }\n}\n\nclass ClosestNObjectFunc implements ExtraFunction {\n    _name = \"closestn\"\n    _doc =\n        \"Given either a list of geojson features or a single layer name, gives the n closest objects which are nearest to the feature (excluding the feature itself). In the case of ways/polygons, only the centerpoint is considered. \" +\n        \"Returns a list of `{feat: geojson, distance:number}` the empty list if nothing is found (or not yet loaded)\\n\\n\" +\n        \"If a 'unique tag key' is given, the tag with this key will only appear once (e.g. if 'name' is given, all features will have a different name)\"\n    _args = [\n        \"list of features or layer name or '*' to get all features\",\n        \"amount of features\",\n        \"unique tag key (optional)\",\n        \"maxDistanceInMeters (optional)\",\n    ]\n\n    /**\n     * Gets the closes N features, sorted by ascending distance.\n     *\n     * @param params: The link to mapcomplete state\n     * @param feature: The central feature under consideration\n     * @param features: The other features\n     * @param options: maxFeatures: The maximum amount of features to be returned. Default: 1; uniqueTag: returned features are not allowed to have the same value for this key; maxDistance: stop searching if it is too far away (in meter). Default: 500m\n     * @constructor\n     * @private\n     */\n    static GetClosestNFeatures(\n        params: ExtraFuncParams,\n        feature: any,\n        features: string | string[] | Feature[],\n        options?: { maxFeatures?: number; uniqueTag?: string | undefined; maxDistance?: number }\n    ): { feat: any; distance: number }[] {\n        const maxFeatures = options?.maxFeatures ?? 1\n        const maxDistance = options?.maxDistance ?? 500\n        const uniqueTag: string | undefined = options?.uniqueTag\n        if (typeof features === \"string\") {\n            features = [features]\n        }\n\n        let allFeatures: Feature[][] = []\n        for (const spec of features) {\n            if (typeof spec === \"string\") {\n                const name = spec\n                const bbox = GeoOperations.bbox(\n                    GeoOperations.buffer(GeoOperations.bbox(feature), maxDistance)\n                )\n                const coors = <[number, number][]>bbox.geometry.coordinates\n                allFeatures.push(...params.getFeaturesWithin(name, new BBox(coors)))\n            } else {\n                allFeatures.push([spec])\n            }\n        }\n        console.log(\n            \"Determining features which are close to\",\n            features,\n            \"other features:\",\n            allFeatures\n        )\n        if (features === undefined) {\n            return\n        }\n\n        const selfCenter = GeoOperations.centerpointCoordinates(feature)\n        let closestFeatures: { feat: any; distance: number }[] = []\n\n        for (const feats of allFeatures ?? []) {\n            for (const otherFeature of feats) {\n                if (otherFeature.properties === undefined) {\n                    console.warn(\"OtherFeature does not have properties:\", otherFeature)\n                }\n                if (\n                    otherFeature === feature ||\n                    otherFeature.properties.id === feature.properties.id\n                ) {\n                    continue // We ignore self\n                }\n                const distance = GeoOperations.distanceBetween(\n                    GeoOperations.centerpointCoordinates(otherFeature),\n                    selfCenter\n                )\n                if (distance === undefined || distance === null || isNaN(distance)) {\n                    console.error(\n                        \"Could not calculate the distance between\",\n                        feature,\n                        \"and\",\n                        otherFeature\n                    )\n                    throw \"Undefined distance!\"\n                }\n\n                if (distance === 0) {\n                    console.trace(\n                        \"Got a suspiciously zero distance between\",\n                        otherFeature,\n                        \"and self-feature\",\n                        feature\n                    )\n                }\n\n                if (distance > maxDistance) {\n                    continue\n                }\n\n                if (closestFeatures.length === 0) {\n                    // This is the first matching feature we find - always add it\n                    closestFeatures.push({\n                        feat: otherFeature,\n                        distance: distance,\n                    })\n                    continue\n                }\n\n                if (\n                    closestFeatures.length >= maxFeatures &&\n                    closestFeatures[maxFeatures - 1].distance < distance\n                ) {\n                    // The last feature of the list (and thus the furthest away is still closer\n                    // No use for checking, as we already have plenty of features!\n                    continue\n                }\n\n                let targetIndex = closestFeatures.length\n                for (let i = 0; i < closestFeatures.length; i++) {\n                    const closestFeature = closestFeatures[i]\n\n                    if (uniqueTag !== undefined) {\n                        const uniqueTagsMatch =\n                            otherFeature.properties[uniqueTag] !== undefined &&\n                            closestFeature.feat.properties[uniqueTag] ===\n                                otherFeature.properties[uniqueTag]\n                        if (uniqueTagsMatch) {\n                            targetIndex = -1\n                            if (closestFeature.distance > distance) {\n                                // This is a very special situation:\n                                // We want to see the tag `uniquetag=some_value` only once in the entire list (e.g. to prevent road segements of identical names to fill up the list of 'names of nearby roads')\n                                // AT this point, we have found a closer segment with the same, identical tag\n                                // so we replace directly\n                                closestFeatures[i] = { feat: otherFeature, distance: distance }\n                            }\n                            break\n                        }\n                    }\n\n                    if (closestFeature.distance > distance) {\n                        targetIndex = i\n\n                        if (uniqueTag !== undefined) {\n                            const uniqueValue = otherFeature.properties[uniqueTag]\n                            // We might still have some other values later one with the same uniquetag that have to be cleaned\n                            for (let j = i; j < closestFeatures.length; j++) {\n                                if (closestFeatures[j].feat.properties[uniqueTag] === uniqueValue) {\n                                    closestFeatures.splice(j, 1)\n                                }\n                            }\n                        }\n                        break\n                    }\n                }\n\n                if (targetIndex == -1) {\n                    continue // value is already swapped by the unique tag\n                }\n\n                if (targetIndex < maxFeatures) {\n                    // insert and drop one\n                    closestFeatures.splice(targetIndex, 0, {\n                        feat: otherFeature,\n                        distance: distance,\n                    })\n                    if (closestFeatures.length >= maxFeatures) {\n                        closestFeatures.splice(maxFeatures, 1)\n                    }\n                } else {\n                    // Overwrite the last element\n                    closestFeatures[targetIndex] = {\n                        feat: otherFeature,\n                        distance: distance,\n                    }\n                }\n            }\n        }\n        return closestFeatures\n    }\n\n    _f(params, feature) {\n        return (features, amount, uniqueTag, maxDistanceInMeters) => {\n            let distance: number = Number(maxDistanceInMeters)\n            if (isNaN(distance)) {\n                distance = undefined\n            }\n            return ClosestNObjectFunc.GetClosestNFeatures(params, feature, features, {\n                maxFeatures: Number(amount),\n                uniqueTag: uniqueTag,\n                maxDistance: distance,\n            })\n        }\n    }\n}\n\nclass GetParsed implements ExtraFunction {\n    _name = \"get\"\n    _doc =\n        \"Gets the property of the feature, parses it (as JSON) and returns it. Might return 'undefined' if not defined, null, ...\"\n    _args = [\"key\"]\n\n    _f(params, feat) {\n        return (key) => {\n            const value = feat.properties[key]\n            if (value === undefined) {\n                return undefined\n            }\n            if (typeof value !== \"string\") {\n                return value\n            }\n            try {\n                const parsed = JSON.parse(value)\n                if (parsed === null) {\n                    return undefined\n                }\n                return parsed\n            } catch (e) {\n                console.warn(\n                    \"Could not parse property \" + key + \" due to: \" + e + \", the value is \" + value\n                )\n                return undefined\n            }\n        }\n    }\n}\n\nexport type ExtraFuncType = (typeof ExtraFunctions.types)[number]\n\nexport class ExtraFunctions {\n    static readonly intro = new Combine([\n        new Title(\"Calculating tags with Javascript\", 2),\n        \"In some cases, it is useful to have some tags calculated based on other properties. Some useful tags are available by default (e.g. `lat`, `lon`, `_country`), as detailed above.\",\n        \"It is also possible to calculate your own tags - but this requires some javascript knowledge.\",\n        \"\",\n        \"Before proceeding, some warnings:\",\n        new List([\n            \"DO NOT DO THIS AS BEGINNER\",\n            \"**Only do this if all other techniques fail**  This should _not_ be done to create a rendering effect, only to calculate a specific value\",\n            \"**THIS MIGHT BE DISABLED WITHOUT ANY NOTICE ON UNOFFICIAL THEMES** As unofficial themes might be loaded from the internet, this is the equivalent of injecting arbitrary code into the client. It'll be disabled if abuse occurs.\",\n        ]),\n        \"To enable this feature,  add a field `calculatedTags` in the layer object, e.g.:\",\n        \"````\",\n        '\"calculatedTags\": [',\n        '    \"_someKey=javascript-expression (lazy execution)\",',\n        '    \"_some_other_key:=javascript expression (strict execution)',\n        '    \"name=feat.properties.name ?? feat.properties.ref ?? feat.properties.operator\",',\n        \"    \\\"_distanceCloserThen3Km=distanceTo(feat)( some_lon, some_lat) < 3 ? 'yes' : 'no'\\\" \",\n        \"  ]\",\n        \"````\",\n        \"\",\n        \"By using `:=` as separator, the attribute will be calculated as soon as the data is loaded (strict evaluation)\",\n        \"The default behaviour, using `=` as separator, is lazy loading\",\n        \"\",\n        \"The above code will be executed for every feature in the layer. The feature is accessible as `feat` and is an amended geojson object:\",\n\n        new List([\n            \"`area` contains the surface area (in square meters) of the object\",\n            \"`lat` and `lon` contain the latitude and longitude\",\n        ]),\n        \"Some advanced functions are available as well. Due to technical reasons, they should be used as `funcname(feat)(arguments)`.\",\n    ])\n        .SetClass(\"flex-col\")\n        .AsMarkdown()\n\n    static readonly types = [\n        \"distanceTo\",\n        \"overlapWith\",\n        \"enclosingFeatures\",\n        \"intersectionsWith\",\n        \"closest\",\n        \"closestn\",\n        \"get\",\n    ] as const\n    private static readonly allFuncs = [\n        new DistanceToFunc(),\n        new OverlapFunc(),\n        new EnclosingFunc(),\n        new IntersectionFunc(),\n        new ClosestObjectFunc(),\n        new ClosestNObjectFunc(),\n        new GetParsed(),\n    ]\n\n    public static constructHelpers(\n        params: ExtraFuncParams\n    ): Record<ExtraFuncType, (feature: Feature) => Function> {\n        const record: Record<string, (feature: GeoJSONFeature) => Function> = {}\n        for (const f of ExtraFunctions.allFuncs) {\n            if (this.types.indexOf(<any>f._name) < 0) {\n                throw \"Invalid extraFunc-type: \" + f._name\n            }\n            record[f._name] = (feat) => f._f(params, feat)\n        }\n        return record\n    }\n\n    public static HelpText(): BaseUIElement {\n        const elems = []\n        for (const func of ExtraFunctions.allFuncs) {\n            elems.push(new Title(func._name, 3), func._doc, new List(func._args ?? [], true))\n        }\n\n        return new Combine([\n            ExtraFunctions.intro,\n            new List(ExtraFunctions.allFuncs.map((func) => `[${func._name}](#${func._name})`)),\n            ...elems,\n        ])\n    }\n}\n","import{listen as t}from\"svelte/internal\";let e=[];function o(o,n=1){let c=0;const u=t(document,\"keydown\",(t=>c=t.shiftKey&&\"Tab\"==t.key));function f(){const t=[...o.querySelectorAll(\"*\")].filter((t=>t.tabIndex>=0));return[t.at(0)??o,t.at(-1)??o]}let s;function r(){e.push(o),s=document.activeElement,f().at(0).focus()}function i(){e=e.filter((t=>t!=o)),s.focus()}n&&r();const a=t=>e.at(-1)?.contains(t),l=t(o,\"focusout\",(t=>{if(a(o)){const[e,o]=f();t.target==e&&c?o.focus():t.target!=o||c||e.focus()}})),d=t(document,\"focusin\",(t=>{if(a(o)&&!a(t.target)){const[t,e]=f();(c?e:t).focus()}}));return{update(t){t?r():i()},destroy(){u(),d(),l(),i()}}}export{o as trapFocus};\n","<script lang=\"ts\">\n  import { createEventDispatcher } from \"svelte\"\n  import { XCircleIcon } from \"@rgossiaux/svelte-heroicons/solid\"\n  import { twMerge } from \"tailwind-merge\"\n  import { trapFocus } from \"trap-focus-svelte\"\n  import { ariaLabel } from \"../../Utils/ariaLabel\"\n  import Translations from \"../i18n/Translations\"\n\n  /**\n   * The slotted element will be shown on top, with a lower-opacity border\n   */\n  const dispatch = createEventDispatcher<{ close }>()\n\n  export let extraClasses = \"p-4 md:p-6\"\n</script>\n\n<!-- Draw the background over the total screen -->\n<div\n  class=\"absolute top-0 left-0 h-screen w-screen\"\n  on:click={() => {\n    dispatch(\"close\")\n  }}\n  style=\"background-color: #00000088; z-index: 20\"\n/>\n<!-- draw a _second_ absolute div, placed using 'bottom' which will be above the navigation bar on mobile browsers -->\n<div\n  class={twMerge(\"absolute bottom-0 right-0 h-full w-screen\", extraClasses)}\n  style=\"z-index: 21\"\n  use:trapFocus\n>\n  <div class=\"h-full content normal-background\" on:click|stopPropagation={() => {}}>\n    <div class=\"h-full rounded-xl\">\n      <slot />\n    </div>\n    <slot name=\"close-button\">\n      <!-- The close button is placed _after_ the default slot in order to always paint it on top -->\n      <button\n        class=\"absolute right-10 top-10 h-8 w-8 cursor-pointer rounded-full border-none bg-white p-0\"\n        on:click={() => dispatch(\"close\")}\n        use:ariaLabel={Translations.t.general.backToMap}\n      >\n        <XCircleIcon />\n      </button>\n    </slot>\n  </div>\n</div>\n\n<style>\n  .content {\n    border-radius: 0.5rem;\n    overflow-x: hidden;\n    box-shadow: 0 0 1rem #00000088;\n  }\n</style>\n","<script lang=\"ts\">\n  /**\n   * Thin wrapper around 'TabGroup' which binds the state\n   */\n\n  import { Tab, TabGroup, TabList, TabPanel, TabPanels } from \"@rgossiaux/svelte-headlessui\"\n  import { ImmutableStore, Store, UIEventSource } from \"../../Logic/UIEventSource\"\n  import { twJoin } from \"tailwind-merge\"\n\n  /**\n   * If a condition is given for a certain tab, it will only be shown if this condition is true.\n   * E.g.\n   * condition3 = new ImmutableStore(false) will always hide tab3 (the fourth tab)\n   */\n  const tr = new ImmutableStore(true)\n  export let condition0: Store<boolean> = tr\n  export let condition1: Store<boolean> = tr\n  export let condition2: Store<boolean> = tr\n  export let condition3: Store<boolean> = tr\n  export let condition4: Store<boolean> = tr\n  export let condition5: Store<boolean> = tr\n  export let condition6: Store<boolean> = tr\n  export let tab: UIEventSource<number> = new UIEventSource<number>(0)\n  let tabElements: HTMLElement[] = []\n  $: tabElements[$tab]?.click()\n  $: {\n    if (tabElements[tab.data]) {\n      window.setTimeout(() => tabElements[tab.data].click(), 50)\n    }\n  }\n</script>\n\n<div class=\"tabbedgroup flex h-full w-full\">\n  <TabGroup\n    class=\"flex h-full w-full flex-col\"\n    defaultIndex={1}\n    on:change={(e) => {\n      if (e.detail >= 0) {\n        tab.setData(e.detail)\n      }\n    }}\n  >\n    <div class=\"interactive sticky top-0 flex items-center justify-between\">\n      <TabList class=\"flex flex-wrap\">\n        {#if $$slots.title0}\n          <Tab\n            class={({ selected }) => twJoin(\"tab\", selected && \"primary\", !$condition0 && \"hidden\")}\n          >\n            <div bind:this={tabElements[0]} class=\"flex\">\n              <slot name=\"title0\">Tab 0</slot>\n            </div>\n          </Tab>\n        {/if}\n        {#if $$slots.title1}\n          <Tab\n            class={({ selected }) => twJoin(\"tab\", selected && \"primary\", !$condition1 && \"hidden\")}\n          >\n            <div bind:this={tabElements[1]} class=\"flex\">\n              <slot name=\"title1\" />\n            </div>\n          </Tab>\n        {/if}\n        {#if $$slots.title2}\n          <Tab\n            class={({ selected }) => twJoin(\"tab\", selected && \"primary\", !$condition2 && \"hidden\")}\n          >\n            <div bind:this={tabElements[2]} class=\"flex\">\n              <slot name=\"title2\" />\n            </div>\n          </Tab>\n        {/if}\n        {#if $$slots.title3}\n          <Tab\n            class={({ selected }) => twJoin(\"tab\", selected && \"primary\", !$condition3 && \"hidden\")}\n          >\n            <div bind:this={tabElements[3]} class=\"flex\">\n              <slot name=\"title3\" />\n            </div>\n          </Tab>\n        {/if}\n        {#if $$slots.title4}\n          <Tab\n            class={({ selected }) => twJoin(\"tab\", selected && \"primary\", !$condition4 && \"hidden\")}\n          >\n            <div bind:this={tabElements[4]} class=\"flex\">\n              <slot name=\"title4\" />\n            </div>\n          </Tab>\n        {/if}\n        {#if $$slots.title5}\n          <Tab\n            class={({ selected }) => twJoin(\"tab\", selected && \"primary\", !$condition5 && \"hidden\")}\n          >\n            <div bind:this={tabElements[5]} class=\"flex\">\n              <slot name=\"title5\" />\n            </div>\n          </Tab>\n        {/if}\n        {#if $$slots.title6}\n          <Tab\n            class={({ selected }) => twJoin(\"tab\", selected && \"primary\", !$condition6 && \"hidden\")}\n          >\n            <div bind:this={tabElements[6]} class=\"flex\">\n              <slot name=\"title6\" />\n            </div>\n          </Tab>\n        {/if}\n      </TabList>\n      <slot name=\"post-tablist\" />\n    </div>\n    <div class=\"normal-background h-full overflow-y-auto\">\n      <TabPanels class=\"tabpanels\" defaultIndex={$tab}>\n        <TabPanel class=\"tabpanel\">\n          <slot name=\"content0\">\n            <div>Empty</div>\n          </slot>\n        </TabPanel>\n        <TabPanel class=\"tabpanel\">\n          <slot name=\"content1\">\n            <div />\n          </slot>\n        </TabPanel>\n        <TabPanel class=\"tabpanel\">\n          <slot name=\"content2\">\n            <div />\n          </slot>\n        </TabPanel>\n        <TabPanel class=\"tabpanel\">\n          <slot name=\"content3\">\n            <div />\n          </slot>\n        </TabPanel>\n        <TabPanel class=\"tabpanel\">\n          <slot name=\"content4\">\n            <div />\n          </slot>\n        </TabPanel>\n        <TabPanel class=\"tabpanel\">\n          <slot name=\"content5\">\n            <div />\n          </slot>\n        </TabPanel>\n        <TabPanel class=\"tabpanel\">\n          <slot name=\"content6\">\n            <div />\n          </slot>\n        </TabPanel>\n      </TabPanels>\n    </div>\n  </TabGroup>\n</div>\n\n<style>\n  .tabbedgroup {\n    max-height: 100vh;\n    height: 100%;\n  }\n\n  :global(.tabpanel) {\n    height: 100%;\n  }\n\n  :global(.tabpanels) {\n    height: calc(100% - 2rem);\n  }\n\n  :global(.tab) {\n    margin: 0.25rem;\n    padding: 0.25rem;\n    padding-left: 0.75rem;\n    padding-right: 0.75rem;\n    border-radius: 1rem;\n  }\n\n  :global(.tab .flex) {\n    align-items: center;\n    gap: 0.25rem;\n  }\n\n  :global(.tab span|div) {\n    align-items: center;\n    gap: 0.25rem;\n    display: flex;\n  }\n\n  :global(.tab-selected svg) {\n    fill: var(--catch-detail-color-contrast);\n  }\n\n  :global(.tab-unselected) {\n    background-color: var(--background-color) !important;\n    color: var(--foreground-color) !important;\n  }\n</style>\n"],"names":["ctx","insert","target","svg","anchor","append","path","EnclosingFunc","__publicField","params","feat","layerIds","result","bbox","BBox","seenIds","layerId","otherFeaturess","otherFeatures","otherFeature","GeoOperations","OverlapFunc","overlap","overlappingFeature","a","b","IntersectionFunc","otherLayers","intersections","DistanceToFunc","featuresPerLayer","feature","arg0","lat","ClosestObjectFunc","features","_b","_a","ClosestNObjectFunc","options","maxFeatures","maxDistance","uniqueTag","allFeatures","spec","name","coors","selfCenter","closestFeatures","feats","distance","targetIndex","i","closestFeature","uniqueValue","j","amount","maxDistanceInMeters","GetParsed","key","value","parsed","e","_ExtraFunctions","record","f","elems","func","Title","List","Combine","ExtraFunctions","o","n","c","u","t","s","r","l","d","button","action_destroyer","ariaLabel","Translations","twMerge","div0","div3","div2","div1","dispatch","createEventDispatcher","extraClasses","$$props","click_handler_1","div","if_block0","create_if_block_6","if_block1","create_if_block_5","if_block2","create_if_block_4","if_block3","create_if_block_3","if_block4","create_if_block_2","if_block5","create_if_block_1","if_block6","create_if_block","tr","ImmutableStore","condition0","condition1","condition2","condition3","condition4","condition5","condition6","tab","UIEventSource","tabElements","$$value","selected","twJoin","$condition0","$condition1","$condition2","$condition3","$condition4","$condition5","$condition6","$tab"],"mappings":"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","x_google_ignoreList":[0,2]}