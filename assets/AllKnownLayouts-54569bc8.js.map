{"version":3,"file":"AllKnownLayouts-54569bc8.js","sources":["../../src/Models/ThemeConfig/Conversion/AddContextToTranslations.ts","../../src/Models/ThemeConfig/Conversion/ValidationUtils.ts","../../src/Models/ThemeConfig/Conversion/PrepareLayer.ts","../../src/Models/ThemeConfig/Conversion/Validation.ts","../../src/Models/ThemeConfig/Conversion/CreateNoteImportLayer.ts","../../src/Models/ThemeConfig/DependencyCalculator.ts","../../src/Models/ThemeConfig/Conversion/PrepareTheme.ts","../../src/Customizations/AllKnownLayouts.ts"],"sourcesContent":["import { DesugaringStep } from \"./Conversion\"\nimport { Utils } from \"../../../Utils\"\nimport Translations from \"../../../UI/i18n/Translations\"\nimport { ConversionContext } from \"./ConversionContext\"\n\nexport class AddContextToTranslations<T> extends DesugaringStep<T> {\n    private readonly _prefix: string\n\n    constructor(prefix = \"\") {\n        super(\n            \"Adds a '_context' to every object that is probably a translation\",\n            [\"_context\"],\n            \"AddContextToTranslation\"\n        )\n        this._prefix = prefix\n    }\n\n    /**\n     * const theme = {\n     *   layers: [\n     *       {\n     *           builtin: [\"abc\"],\n     *           override: {\n     *               title:{\n     *                   en: \"Some title\"\n     *               }\n     *           }\n     *       }\n     *   ]\n     * }\n     * const rewritten = new AddContextToTranslations<any>(\"prefix:\").convertStrict(theme, ConversionContext.test())\n     * const expected = {\n     *   layers: [\n     *       {\n     *           builtin: [\"abc\"],\n     *           override: {\n     *               title:{\n     *                  _context: \"prefix:layers.0.override.title\"\n     *                   en: \"Some title\"\n     *               }\n     *           }\n     *       }\n     *   ]\n     * }\n     * rewritten // => expected\n     *\n     * // should use the ID if one is present instead of the index\n     * const theme = {\n     *   layers: [\n     *       {\n     *           tagRenderings:[\n     *               {id: \"some-tr\",\n     *               question:{\n     *                   en:\"Question?\"\n     *               }\n     *               }\n     *           ]\n     *       }\n     *   ]\n     * }\n     * const rewritten = new AddContextToTranslations<any>(\"prefix:\").convertStrict(theme, ConversionContext.test())\n     * const expected = {\n     *   layers: [\n     *       {\n     *           tagRenderings:[\n     *               {id: \"some-tr\",\n     *               question:{\n     *                  _context: \"prefix:layers.0.tagRenderings.some-tr.question\"\n     *                   en:\"Question?\"\n     *               }\n     *               }\n     *           ]\n     *       }\n     *   ]\n     * }\n     * rewritten // => expected\n     *\n     * // should preserve nulls\n     * const theme = {\n     *   layers: [\n     *       {\n     *           builtin: [\"abc\"],\n     *           override: {\n     *               name:null\n     *           }\n     *       }\n     *   ]\n     * }\n     * const rewritten = new AddContextToTranslations<any>(\"prefix:\").convertStrict(theme, ConversionContext.test())\n     * const expected = {\n     *   layers: [\n     *       {\n     *           builtin: [\"abc\"],\n     *           override: {\n     *               name: null\n     *           }\n     *       }\n     *   ]\n     * }\n     * rewritten // => expected\n     *\n     *\n     * // Should ignore all if '#dont-translate' is set\n     * const theme = {\n     *  \"#dont-translate\": \"*\",\n     *   layers: [\n     *       {\n     *           builtin: [\"abc\"],\n     *           override: {\n     *               title:{\n     *                   en: \"Some title\"\n     *               }\n     *           }\n     *       }\n     *   ]\n     * }\n     * const rewritten = new AddContextToTranslations<any>(\"prefix:\").convertStrict(theme, ConversionContext.test())\n     * rewritten // => theme\n     *\n     */\n    convert(json: T, context: ConversionContext): T {\n        if (json[\"#dont-translate\"] === \"*\") {\n            return json\n        }\n\n        return Utils.WalkJson(\n            json,\n            (leaf, path) => {\n                if (leaf === undefined || leaf === null) {\n                    return leaf\n                }\n                if (typeof leaf === \"object\") {\n                    // follow the path. If we encounter a number, check that there is no ID we can use instead\n                    let breadcrumb = json\n                    for (let i = 0; i < path.length; i++) {\n                        const pointer = path[i]\n                        breadcrumb = breadcrumb[pointer]\n                        if (pointer.match(\"[0-9]+\") && breadcrumb[\"id\"] !== undefined) {\n                            path[i] = breadcrumb[\"id\"]\n                        }\n                    }\n\n                    return {\n                        ...leaf,\n                        _context: this._prefix + context.path.concat(path).join(\".\"),\n                    }\n                } else {\n                    return leaf\n                }\n            },\n            (obj) => obj === undefined || obj === null || Translations.isProbablyATranslation(obj)\n        )\n    }\n}\n","import { TagRenderingConfigJson } from \"../Json/TagRenderingConfigJson\"\nimport { Utils } from \"../../../Utils\"\nimport SpecialVisualizations from \"../../../UI/SpecialVisualizations\"\nimport { RenderingSpecification, SpecialVisualization } from \"../../../UI/SpecialVisualization\"\nimport { QuestionableTagRenderingConfigJson } from \"../Json/QuestionableTagRenderingConfigJson\"\n\nexport default class ValidationUtils {\n    public static getAllSpecialVisualisations(\n        renderingConfigs: (TagRenderingConfigJson | QuestionableTagRenderingConfigJson)[]\n    ): RenderingSpecification[] {\n        const visualisations: RenderingSpecification[] = []\n        for (const renderConfig of renderingConfigs) {\n            visualisations.push(...ValidationUtils.getSpecialVisualisationsWithArgs(renderConfig))\n        }\n        return visualisations\n    }\n\n    /**\n     * Gives all the (function names of) used special visualisations\n     * @param renderingConfig\n     */\n    public static getSpecialVisualisations(\n        renderingConfig: TagRenderingConfigJson\n    ): SpecialVisualization[] {\n        return ValidationUtils.getSpecialVisualisationsWithArgs(renderingConfig).map(\n            (spec) => spec[\"func\"]\n        )\n    }\n\n    public static getSpecialVisualisationsWithArgs(\n        renderingConfig: TagRenderingConfigJson\n    ): RenderingSpecification[] {\n        if (!renderingConfig) {\n            return []\n        }\n        const cacheName = \"__specialVisualisationsWithArgs_cache\"\n        if (renderingConfig[cacheName]) {\n            return renderingConfig[cacheName]\n        }\n        const translations: any[] = Utils.NoNull([\n            renderingConfig.render,\n            ...(renderingConfig.mappings ?? []).map((m) => m.then),\n        ])\n        const all: RenderingSpecification[] = []\n        for (let translation of translations) {\n            if (typeof translation == \"string\") {\n                translation = { \"*\": translation }\n            }\n\n            for (const key in translation) {\n                if (!translation.hasOwnProperty(key)) {\n                    continue\n                }\n\n                const template = translation[key]\n                const parts = SpecialVisualizations.constructSpecification(template)\n                const specials = parts.filter((p) => typeof p !== \"string\")\n                all.push(...specials)\n            }\n        }\n\n        // _Very_ dirty hack\n        Object.defineProperty(renderingConfig, cacheName, {\n            value: all,\n            enumerable: false,\n            configurable: true,\n            writable: true,\n        })\n\n        return all\n    }\n}\n","import {\n    Concat,\n    Conversion,\n    DesugaringContext,\n    DesugaringStep,\n    Each,\n    FirstOf,\n    Fuse,\n    On,\n    SetDefault,\n} from \"./Conversion\"\nimport { LayerConfigJson } from \"../Json/LayerConfigJson\"\nimport {\n    MinimalTagRenderingConfigJson,\n    TagRenderingConfigJson,\n} from \"../Json/TagRenderingConfigJson\"\nimport { Utils } from \"../../../Utils\"\nimport RewritableConfigJson from \"../Json/RewritableConfigJson\"\nimport SpecialVisualizations from \"../../../UI/SpecialVisualizations\"\nimport Translations from \"../../../UI/i18n/Translations\"\nimport { Translation } from \"../../../UI/i18n/Translation\"\nimport tagrenderingconfigmeta from \"../../../../src/assets/schemas/tagrenderingconfigmeta.json\"\nimport { AddContextToTranslations } from \"./AddContextToTranslations\"\nimport FilterConfigJson from \"../Json/FilterConfigJson\"\nimport predifined_filters from \"../../../../assets/layers/filters/filters.json\"\nimport { TagConfigJson } from \"../Json/TagConfigJson\"\nimport PointRenderingConfigJson, { IconConfigJson } from \"../Json/PointRenderingConfigJson\"\nimport ValidationUtils from \"./ValidationUtils\"\nimport { RenderingSpecification } from \"../../../UI/SpecialVisualization\"\nimport { QuestionableTagRenderingConfigJson } from \"../Json/QuestionableTagRenderingConfigJson\"\nimport { ConfigMeta } from \"../../../UI/Studio/configMeta\"\nimport LineRenderingConfigJson from \"../Json/LineRenderingConfigJson\"\nimport { ConversionContext } from \"./ConversionContext\"\n\nclass ExpandFilter extends DesugaringStep<LayerConfigJson> {\n    private static readonly predefinedFilters = ExpandFilter.load_filters()\n    private _state: DesugaringContext\n\n    constructor(state: DesugaringContext) {\n        super(\n            \"Expands filters: replaces a shorthand by the value found in 'filters.json'. If the string is formatted 'layername.filtername, it will be looked up into that layer instead\",\n            [\"filter\"],\n            \"ExpandFilter\"\n        )\n        this._state = state\n    }\n\n    private static load_filters(): Map<string, FilterConfigJson> {\n        let filters = new Map<string, FilterConfigJson>()\n        for (const filter of <FilterConfigJson[]>predifined_filters.filter) {\n            filters.set(filter.id, filter)\n        }\n        return filters\n    }\n\n    convert(json: LayerConfigJson, context: ConversionContext): LayerConfigJson {\n        if (json?.filter === undefined || json?.filter === null) {\n            return json // Nothing to change here\n        }\n\n        if (json.filter[\"sameAs\"] !== undefined) {\n            return json // Nothing to change here\n        }\n\n        const newFilters: FilterConfigJson[] = []\n        for (const filter of <(FilterConfigJson | string)[]>json.filter) {\n            if (typeof filter !== \"string\") {\n                newFilters.push(filter)\n                continue\n            }\n            if (filter.indexOf(\".\") > 0) {\n                if (this._state.sharedLayers.size > 0) {\n                    const split = filter.split(\".\")\n                    if (split.length > 2) {\n                        context.err(\n                            \"invalid filter name: \" + filter + \", expected `layername.filterid`\"\n                        )\n                    }\n                    const layer = this._state.sharedLayers.get(split[0])\n                    if (layer === undefined) {\n                        context.err(\"Layer '\" + split[0] + \"' not found\")\n                    }\n                    const expectedId = split[1]\n                    const expandedFilter = (<(FilterConfigJson | string)[]>layer.filter).find(\n                        (f) => typeof f !== \"string\" && f.id === expectedId\n                    )\n                    newFilters.push(<FilterConfigJson>expandedFilter)\n                } else {\n                    // This is a bootstrapping-run, we can safely ignore this\n                }\n                continue\n            }\n            // Search for the filter:\n            const found = ExpandFilter.predefinedFilters.get(filter)\n            if (found === undefined) {\n                const suggestions = Utils.sortedByLevenshteinDistance(\n                    filter,\n                    Array.from(ExpandFilter.predefinedFilters.keys()),\n                    (t) => t\n                )\n                context\n                    .enter(filter)\n                    .err(\n                        \"While searching for predefined filter \" +\n                            filter +\n                            \": this filter is not found. Perhaps you meant one of: \" +\n                            suggestions\n                    )\n            }\n            newFilters.push(found)\n        }\n        return { ...json, filter: newFilters }\n    }\n}\n\nclass ExpandTagRendering extends Conversion<\n    | string\n    | TagRenderingConfigJson\n    | {\n          builtin: string | string[]\n          override: any\n      },\n    TagRenderingConfigJson[]\n> {\n    private readonly _state: DesugaringContext\n    private readonly _tagRenderingsByLabel: Map<string, TagRenderingConfigJson[]>\n    // Only used for self-reference\n    private readonly _self: LayerConfigJson\n    private readonly _options: {\n        /* If true, will copy the 'osmSource'-tags into the condition */\n        applyCondition?: true | boolean\n        noHardcodedStrings?: false | boolean\n    }\n\n    constructor(\n        state: DesugaringContext,\n        self: LayerConfigJson,\n        options?: {\n            applyCondition?: true | boolean\n            noHardcodedStrings?: false | boolean\n        }\n    ) {\n        super(\n            \"Converts a tagRenderingSpec into the full tagRendering, e.g. by substituting the tagRendering by the shared-question\",\n            [],\n            \"ExpandTagRendering\"\n        )\n        this._state = state\n        this._self = self\n        this._options = options\n        this._tagRenderingsByLabel = new Map<string, TagRenderingConfigJson[]>()\n        for (const trconfig of state.tagRenderings?.values() ?? []) {\n            for (const label of trconfig[\"labels\"] ?? []) {\n                let withLabel = this._tagRenderingsByLabel.get(label)\n                if (withLabel === undefined) {\n                    withLabel = []\n                    this._tagRenderingsByLabel.set(label, withLabel)\n                }\n                withLabel.push(trconfig)\n            }\n        }\n    }\n\n    public convert(\n        spec: string | any,\n        ctx: ConversionContext\n    ): QuestionableTagRenderingConfigJson[] {\n        const trs = this.convertOnce(spec, ctx)\n\n        const result = []\n        for (const tr of trs) {\n            if (typeof tr === \"string\" || tr[\"builtin\"] !== undefined) {\n                const stable = this.convert(tr, ctx.inOperation(\"recursive_resolve\"))\n                result.push(...stable)\n            } else {\n                result.push(tr)\n            }\n        }\n\n        return result\n    }\n\n    private lookup(name: string): TagRenderingConfigJson[] | undefined {\n        const direct = this.directLookup(name)\n\n        if (direct === undefined) {\n            return undefined\n        }\n        const result: TagRenderingConfigJson[] = []\n        for (const tagRenderingConfigJson of direct) {\n            let nm: string | string[] | undefined = tagRenderingConfigJson[\"builtin\"]\n            if (nm !== undefined) {\n                let indirect: TagRenderingConfigJson[]\n                if (typeof nm === \"string\") {\n                    indirect = this.lookup(nm)\n                } else {\n                    indirect = [].concat(...nm.map((n) => this.lookup(n)))\n                }\n                for (let foundTr of indirect) {\n                    foundTr = Utils.Clone<any>(foundTr)\n                    Utils.Merge(tagRenderingConfigJson[\"override\"] ?? {}, foundTr)\n                    foundTr[\"id\"] = tagRenderingConfigJson[\"id\"] ?? foundTr[\"id\"]\n                    result.push(foundTr)\n                }\n            } else {\n                result.push(tagRenderingConfigJson)\n            }\n        }\n        return result\n    }\n\n    /**\n     * Looks up a tagRendering or group of tagRenderings based on the name.\n     */\n    private directLookup(name: string): TagRenderingConfigJson[] | undefined {\n        const state = this._state\n        if (state.tagRenderings.has(name)) {\n            return [state.tagRenderings.get(name)]\n        }\n        if (this._tagRenderingsByLabel.has(name)) {\n            return this._tagRenderingsByLabel.get(name)\n        }\n\n        if (name.indexOf(\".\") < 0) {\n            return undefined\n        }\n\n        const spl = name.split(\".\")\n        let layer = state.sharedLayers?.get(spl[0])\n        if (spl[0] === this._self?.id) {\n            layer = this._self\n        }\n\n        if (spl.length !== 2 || !layer) {\n            return undefined\n        }\n\n        const id = spl[1]\n\n        const layerTrs = <TagRenderingConfigJson[]>(\n            layer.tagRenderings.filter((tr) => tr[\"id\"] !== undefined)\n        )\n        let matchingTrs: TagRenderingConfigJson[]\n        if (id === \"*\") {\n            matchingTrs = layerTrs\n        } else if (id.startsWith(\"*\")) {\n            const id_ = id.substring(1)\n            matchingTrs = layerTrs.filter((tr) => tr[\"labels\"]?.indexOf(id_) >= 0)\n        } else {\n            matchingTrs = layerTrs.filter((tr) => tr[\"id\"] === id || tr[\"labels\"]?.indexOf(id) >= 0)\n        }\n\n        const contextWriter = new AddContextToTranslations<TagRenderingConfigJson>(\"layers:\")\n        for (let i = 0; i < matchingTrs.length; i++) {\n            let found: TagRenderingConfigJson = Utils.Clone(matchingTrs[i])\n            if (this._options?.applyCondition) {\n                // The matched tagRenderings are 'stolen' from another layer. This means that they must match the layer condition before being shown\n                if (typeof layer.source !== \"string\") {\n                    if (found.condition === undefined) {\n                        found.condition = layer.source[\"osmTags\"]\n                    } else {\n                        found.condition = { and: [found.condition, layer.source[\"osmTags\"]] }\n                    }\n                }\n            }\n\n            found = contextWriter.convertStrict(\n                found,\n                ConversionContext.construct(\n                    [layer.id, \"tagRenderings\", found[\"id\"]],\n                    [\"AddContextToTranslations\"]\n                )\n            )\n            matchingTrs[i] = found\n        }\n\n        if (matchingTrs.length !== 0) {\n            return matchingTrs\n        }\n        return undefined\n    }\n\n    private convertOnce(tr: string | any, ctx: ConversionContext): TagRenderingConfigJson[] {\n        const state = this._state\n\n        if (typeof tr === \"string\") {\n            let lookup\n            if (this._state.tagRenderings !== null) {\n                lookup = this.lookup(tr)\n            }\n            if (lookup === undefined) {\n                if (\n                    this._state.sharedLayers?.size > 0 &&\n                    ctx.path.at(-1) !== \"icon\" &&\n                    !ctx.path.find((p) => p === \"pointRendering\")\n                ) {\n                    ctx.warn(\n                        `A literal rendering was detected: ${tr}\n                      Did you perhaps forgot to add a layer name as 'layername.${tr}'? ` +\n                            Array.from(state.sharedLayers.keys()).join(\", \")\n                    )\n                }\n\n                if (this._options?.noHardcodedStrings && this._state?.sharedLayers?.size > 0) {\n                    ctx.err(\n                        \"Detected an invocation to a builtin tagRendering, but this tagrendering was not found: \" +\n                            tr +\n                            \" \\n    Did you perhaps forget to add the layer as prefix, such as `icons.\" +\n                            tr +\n                            \"`? \"\n                    )\n                }\n\n                return [\n                    <any>{\n                        render: tr,\n                        id: tr.replace(/[^a-zA-Z0-9]/g, \"\"),\n                    },\n                ]\n            }\n            return lookup\n        }\n\n        if (tr[\"builtin\"] !== undefined) {\n            let names: string | string[] = tr[\"builtin\"]\n            if (typeof names === \"string\") {\n                names = [names]\n            }\n\n            if (this._state.tagRenderings === null) {\n                return []\n            }\n\n            for (const key of Object.keys(tr)) {\n                if (\n                    key === \"builtin\" ||\n                    key === \"override\" ||\n                    key === \"id\" ||\n                    key.startsWith(\"#\")\n                ) {\n                    continue\n                }\n                ctx.err(\n                    \"An object calling a builtin can only have keys `builtin` or `override`, but a key with name `\" +\n                        key +\n                        \"` was found. This won't be picked up! The full object is: \" +\n                        JSON.stringify(tr)\n                )\n            }\n\n            const trs: TagRenderingConfigJson[] = []\n            for (const name of names) {\n                const lookup = this.lookup(name)\n                if (lookup === undefined) {\n                    let candidates = Array.from(state.tagRenderings.keys())\n                    if (name.indexOf(\".\") > 0) {\n                        const [layerName] = name.split(\".\")\n                        let layer = state.sharedLayers.get(layerName)\n                        if (layerName === this._self?.id) {\n                            layer = this._self\n                        }\n                        if (layer === undefined) {\n                            const candidates = Utils.sortedByLevenshteinDistance(\n                                layerName,\n                                Array.from(state.sharedLayers.keys()),\n                                (s) => s\n                            )\n                            if (state.sharedLayers.size === 0) {\n                                ctx.warn(\n                                    \"BOOTSTRAPPING. Rerun generate layeroverview. While reusing tagrendering: \" +\n                                        name +\n                                        \": layer \" +\n                                        layerName +\n                                        \" not found for now, but ignoring as this is a bootstrapping run. \"\n                                )\n                            } else {\n                                ctx.err(\n                                    \": While reusing tagrendering: \" +\n                                        name +\n                                        \": layer \" +\n                                        layerName +\n                                        \" not found. Maybe you meant one of \" +\n                                        candidates.slice(0, 3).join(\", \")\n                                )\n                            }\n                            continue\n                        }\n                        candidates = Utils.NoNull(layer.tagRenderings.map((tr) => tr[\"id\"])).map(\n                            (id) => layerName + \".\" + id\n                        )\n                    }\n                    candidates = Utils.sortedByLevenshteinDistance(name, candidates, (i) => i)\n                    ctx.err(\n                        \"The tagRendering with identifier \" +\n                            name +\n                            \" was not found.\\n\\tDid you mean one of \" +\n                            candidates.join(\", \") +\n                            \"?\\n(Hint: did you add a new label and are you trying to use this label at the same time? Run 'reset:layeroverview' first\"\n                    )\n                    continue\n                }\n                for (let foundTr of lookup) {\n                    foundTr = Utils.Clone<any>(foundTr)\n                    Utils.Merge(tr[\"override\"] ?? {}, foundTr)\n                    if (names.length == 1) {\n                        foundTr[\"id\"] = tr[\"id\"] ?? foundTr[\"id\"]\n                    }\n                    trs.push(foundTr)\n                }\n            }\n            return trs\n        }\n\n        return [tr]\n    }\n}\n\nclass DetectInline extends DesugaringStep<QuestionableTagRenderingConfigJson> {\n    constructor() {\n        super(\n            \"If no 'inline' is set on the freeform key, it will be automatically added. If no special renderings are used, it'll be set to true\",\n            [\"freeform.inline\"],\n            \"DetectInline\"\n        )\n    }\n\n    convert(\n        json: QuestionableTagRenderingConfigJson,\n        context: ConversionContext\n    ): QuestionableTagRenderingConfigJson {\n        if (json.freeform === undefined) {\n            return json\n        }\n        let spec: Record<string, string>\n        if (typeof json.render === \"string\") {\n            spec = { \"*\": json.render }\n        } else {\n            spec = <Record<string, string>>json.render\n        }\n        for (const key in spec) {\n            if (spec[key].indexOf(\"<a \") >= 0) {\n                // We have a link element, it probably contains something that needs to be substituted...\n                // Let's play this safe and not inline it\n                return json\n            }\n            const fullSpecification = SpecialVisualizations.constructSpecification(spec[key])\n            if (fullSpecification.length > 1) {\n                // We found a special rendering!\n                if (json.freeform.inline === true) {\n                    context.err(\n                        \"'inline' is set, but the rendering contains a special visualisation...\\n    \" +\n                            spec[key]\n                    )\n                }\n                json = JSON.parse(JSON.stringify(json))\n                json.freeform.inline = false\n                return json\n            }\n        }\n        json = JSON.parse(JSON.stringify(json))\n        if (typeof json.freeform === \"string\") {\n            context.err(\"'freeform' is a string, but should be an object\")\n            return json\n        }\n        json.freeform.inline ??= true\n        return json\n    }\n}\n\nexport class AddQuestionBox extends DesugaringStep<LayerConfigJson> {\n    constructor() {\n        super(\n            \"Adds a 'questions'-object if no question element is added yet\",\n            [\"tagRenderings\"],\n            \"AddQuestionBox\"\n        )\n    }\n\n    convert(json: LayerConfigJson, context: ConversionContext): LayerConfigJson {\n        if (\n            json.tagRenderings === undefined ||\n            json.tagRenderings.some((tr) => tr[\"id\"] === \"leftover-questions\")\n        ) {\n            return json\n        }\n        if (json.source === \"special\") {\n            return json\n        }\n        json = { ...json }\n        json.tagRenderings = [...json.tagRenderings]\n        const allSpecials: Exclude<RenderingSpecification, string>[] = <any>(\n            ValidationUtils.getAllSpecialVisualisations(<any>json.tagRenderings).filter(\n                (spec) => typeof spec !== \"string\"\n            )\n        )\n\n        const questionSpecials = allSpecials.filter((sp) => sp.func.funcName === \"questions\")\n        const noLabels = questionSpecials.filter(\n            (sp) => sp.args.length === 0 || sp.args[0].trim() === \"\"\n        )\n\n        if (noLabels.length > 1) {\n            context.err(\n                \"Multiple 'questions'-visualisations found which would show _all_ questions. Don't do this\"\n            )\n        }\n\n        // ALl labels that are used in this layer\n        const allLabels = new Set(\n            [].concat(\n                ...json.tagRenderings.map(\n                    (tr) => (<QuestionableTagRenderingConfigJson>tr).labels ?? []\n                )\n            )\n        )\n        const seen = new Set()\n        for (const questionSpecial of questionSpecials) {\n            if (typeof questionSpecial === \"string\") {\n                continue\n            }\n            const used = questionSpecial.args[0]\n                ?.split(\";\")\n                ?.map((a) => a.trim())\n                ?.filter((s) => s != \"\")\n            const blacklisted = questionSpecial.args[1]\n                ?.split(\";\")\n                ?.map((a) => a.trim())\n                ?.filter((s) => s != \"\")\n            if (blacklisted?.length > 0 && used?.length > 0) {\n                context.err(\n                    \"The {questions()}-special rendering only supports either a blacklist OR a whitelist, but not both.\" +\n                        \"\\n    Whitelisted: \" +\n                        used.join(\", \") +\n                        \"\\n    Blacklisted: \" +\n                        blacklisted.join(\", \")\n                )\n            }\n            for (const usedLabel of used) {\n                if (!allLabels.has(usedLabel)) {\n                    context.err(\n                        \"This layers specifies a special question element for label `\" +\n                            usedLabel +\n                            \"`, but this label doesn't exist.\\n\" +\n                            \"    Available labels are \" +\n                            Array.from(allLabels).join(\", \")\n                    )\n                }\n                seen.add(usedLabel)\n            }\n        }\n\n        if (noLabels.length == 0) {\n            /* At this point, we know which question labels are not yet handled and which already are handled, and we\n             * know there is no previous catch-all questions\n             */\n            const question: QuestionableTagRenderingConfigJson = {\n                id: \"leftover-questions\",\n                render: {\n                    \"*\": `{questions( ,${Array.from(seen).join(\";\")})}`,\n                },\n            }\n            json.tagRenderings.push(question)\n        }\n        return json\n    }\n}\n\nexport class AddEditingElements extends DesugaringStep<LayerConfigJson> {\n    private readonly _desugaring: DesugaringContext\n\n    constructor(desugaring: DesugaringContext) {\n        super(\n            \"Add some editing elements, such as the delete button or the move button if they are configured. These used to be handled by the feature info box, but this has been replaced by special visualisation elements\",\n            [],\n            \"AddEditingElements\"\n        )\n        this._desugaring = desugaring\n    }\n\n    convert(json: LayerConfigJson, context: ConversionContext): LayerConfigJson {\n        if (this._desugaring.tagRenderings === null) {\n            return json\n        }\n        if (json.source === \"special\") {\n            return json\n        }\n        if (!json.title && !json.tagRenderings) {\n            return json\n        }\n        json = { ...json }\n        json.tagRenderings = [...(json.tagRenderings ?? [])]\n        const specialVisualisations = ValidationUtils.getAllSpecialVisualisations(\n            <any>json.tagRenderings\n        )\n        const usedSpecialFunctions = new Set(\n            specialVisualisations.map((sv) =>\n                typeof sv === \"string\" ? undefined : sv.func.funcName\n            )\n        )\n        if (!usedSpecialFunctions.has(\"minimap\")) {\n            json.tagRenderings.push(this._desugaring.tagRenderings.get(\"minimap\"))\n        }\n\n        if (\n            this._desugaring.tagRenderings.has(\"just_created\") &&\n            !json.tagRenderings.some((tr) => tr === \"just_created\" || tr[\"id\"] === \"just_created\")\n        ) {\n            json.tagRenderings.unshift(this._desugaring.tagRenderings.get(\"just_created\"))\n        }\n\n        if (json.allowSplit && !usedSpecialFunctions.has(\"split_button\")) {\n            json.tagRenderings.push({\n                id: \"split-button\",\n                render: { \"*\": \"{split_button()}\" },\n            })\n            delete json.allowSplit\n        }\n\n        if (json.allowMove && !usedSpecialFunctions.has(\"move_button\")) {\n            json.tagRenderings.push({\n                id: \"move-button\",\n                render: { \"*\": \"{move_button()}\" },\n            })\n        }\n        if (json.deletion && !usedSpecialFunctions.has(\"delete_button\")) {\n            json.tagRenderings.push({\n                id: \"delete-button\",\n                render: { \"*\": \"{delete_button()}\" },\n            })\n        }\n\n        if (\n            json.source !== \"special\" &&\n            json.source !== \"special:library\" &&\n            json.tagRenderings &&\n            this._desugaring.tagRenderings.has(\"last_edit\") &&\n            !json.tagRenderings.some((tr) => tr[\"id\"] === \"last_edit\")\n        ) {\n            json.tagRenderings.push(this._desugaring.tagRenderings.get(\"last_edit\"))\n        }\n\n        if (!usedSpecialFunctions.has(\"all_tags\")) {\n            const trc: QuestionableTagRenderingConfigJson = {\n                id: \"all-tags\",\n                render: { \"*\": \"{all_tags()}\" },\n\n                metacondition: {\n                    or: [\n                        \"__featureSwitchIsDebugging=true\",\n                        \"mapcomplete-show_tags=full\",\n                        \"mapcomplete-show_debug=yes\",\n                    ],\n                },\n            }\n            json.tagRenderings?.push(trc)\n        }\n\n        return json\n    }\n}\n\nexport class ExpandRewrite<T> extends Conversion<T | RewritableConfigJson<T>, T[]> {\n    constructor() {\n        super(\"Applies a rewrite\", [], \"ExpandRewrite\")\n    }\n\n    /**\n     * Used for left|right group creation and replacement.\n     * Every 'keyToRewrite' will be replaced with 'target' recursively. This substitution will happen in place in the object 'tr'\n     *\n     * // should substitute strings\n     * const spec = {\n     *   \"someKey\": \"somevalue {xyz}\"\n     * }\n     * ExpandRewrite.RewriteParts(\"{xyz}\", \"rewritten\", spec) // => {\"someKey\": \"somevalue rewritten\"}\n     *\n     * // should substitute all occurances in strings\n     * const spec = {\n     *   \"someKey\": \"The left|right side has {key:left|right}\"\n     * }\n     * ExpandRewrite.RewriteParts(\"left|right\", \"left\", spec) // => {\"someKey\": \"The left side has {key:left}\"}\n     *\n     */\n    public static RewriteParts<T>(keyToRewrite: string, target: string | any, tr: T): T {\n        const targetIsTranslation = Translations.isProbablyATranslation(target)\n\n        function replaceRecursive(obj: string | any, target) {\n            if (obj === keyToRewrite) {\n                return target\n            }\n\n            if (typeof obj === \"string\") {\n                // This is a simple string - we do a simple replace\n                while (obj.indexOf(keyToRewrite) >= 0) {\n                    obj = obj.replace(keyToRewrite, target)\n                }\n                return obj\n            }\n            if (Array.isArray(obj)) {\n                // This is a list of items\n                return obj.map((o) => replaceRecursive(o, target))\n            }\n\n            if (typeof obj === \"object\") {\n                obj = { ...obj }\n\n                const isTr = targetIsTranslation && Translations.isProbablyATranslation(obj)\n\n                for (const key in obj) {\n                    let subtarget = target\n                    if (isTr && target[key] !== undefined) {\n                        // The target is a translation AND the current object is a translation\n                        // This means we should recursively replace with the translated value\n                        subtarget = target[key]\n                    }\n\n                    obj[key] = replaceRecursive(obj[key], subtarget)\n                }\n                return obj\n            }\n            return obj\n        }\n\n        return replaceRecursive(tr, target)\n    }\n\n    /**\n     * // should convert simple strings\n     * const spec = <RewritableConfigJson<string>>{\n     *     rewrite: {\n     *         sourceString: [\"xyz\",\"abc\"],\n     *         into: [\n     *             [\"X\", \"A\"],\n     *             [\"Y\", \"B\"],\n     *             [\"Z\", \"C\"]],\n     *     },\n     *     renderings: \"The value of xyz is abc\"\n     * }\n     * new ExpandRewrite().convertStrict(spec, ConversionContext.test()) // => [\"The value of X is A\", \"The value of Y is B\", \"The value of Z is C\"]\n     *\n     * // should rewrite with translations\n     * const spec = <RewritableConfigJson<any>>{\n     *     rewrite: {\n     *         sourceString: [\"xyz\",\"abc\"],\n     *         into: [\n     *             [\"X\", {en: \"value\", nl: \"waarde\"}],\n     *             [\"Y\", {en: \"some other value\", nl: \"een andere waarde\"}],\n     *     },\n     *     renderings: {en: \"The value of xyz is abc\", nl: \"De waarde van xyz is abc\"}\n     * }\n     * const expected = [\n     *  {\n     *      en: \"The value of X is value\",\n     *      nl: \"De waarde van X is waarde\"\n     *  },\n     *  {\n     *      en: \"The value of Y is some other value\",\n     *      nl: \"De waarde van Y is een andere waarde\"\n     *  }\n     * ]\n     * new ExpandRewrite().convertStrict(spec, ConversionContext.test()) // => expected\n     */\n    convert(json: T | RewritableConfigJson<T>, context: ConversionContext): T[] {\n        if (json === null || json === undefined) {\n            return []\n        }\n\n        if (json[\"rewrite\"] === undefined) {\n            // not a rewrite\n            return [<T>json]\n        }\n\n        const rewrite = <RewritableConfigJson<T>>json\n        const keysToRewrite = rewrite.rewrite\n        const ts: T[] = []\n\n        {\n            // sanity check: rewrite: [\"xyz\", \"longer_xyz\"] is not allowed as \"longer_xyz\" will never be triggered\n            for (let i = 0; i < keysToRewrite.sourceString.length; i++) {\n                const guard = keysToRewrite.sourceString[i]\n                for (let j = i + 1; j < keysToRewrite.sourceString.length; j++) {\n                    const toRewrite = keysToRewrite.sourceString[j]\n                    if (toRewrite.indexOf(guard) >= 0) {\n                        context.err(\n                            `sourcestring[${i}] is a substring of sourcestring[${j}]: ${guard} will be substituted away before ${toRewrite} is reached.`\n                        )\n                    }\n                }\n            }\n        }\n\n        {\n            // sanity check: {rewrite: [\"a\", \"b\"] should have the right amount of 'intos' in every case\n            for (let i = 0; i < rewrite.rewrite.into.length; i++) {\n                const into = keysToRewrite.into[i]\n                if (into.length !== rewrite.rewrite.sourceString.length) {\n                    context\n                        .enters(\"into\", i)\n                        .err(\n                            `Error in rewrite: there are ${rewrite.rewrite.sourceString.length} keys to rewrite, but entry ${i} has only ${into.length} values`\n                        )\n                }\n            }\n        }\n\n        for (let i = 0; i < keysToRewrite.into.length; i++) {\n            let t = Utils.Clone(rewrite.renderings)\n            for (let j = 0; j < keysToRewrite.sourceString.length; j++) {\n                const key = keysToRewrite.sourceString[j]\n                const target = keysToRewrite.into[i][j]\n                t = ExpandRewrite.RewriteParts(key, target, t)\n            }\n            ts.push(t)\n        }\n\n        return ts\n    }\n}\n\n/**\n * Converts a 'special' translation into a regular translation which uses parameters\n */\nexport class RewriteSpecial extends DesugaringStep<TagRenderingConfigJson> {\n    constructor() {\n        super(\n            \"Converts a 'special' translation into a regular translation which uses parameters\",\n            [\"special\"],\n            \"RewriteSpecial\"\n        )\n    }\n\n    /**\n     * Does the heavy lifting and conversion\n     *\n     * // should not do anything if no 'special'-key is present\n     * RewriteSpecial.convertIfNeeded({\"en\": \"xyz\", \"nl\": \"abc\"}, ConversionContext.test()) // => {\"en\": \"xyz\", \"nl\": \"abc\"}\n     *\n     * // should handle a simple special case\n     * RewriteSpecial.convertIfNeeded({\"special\": {\"type\":\"image_carousel\"}}, ConversionContext.test()) // => {'*': \"{image_carousel()}\"}\n     *\n     * // should handle special case with a parameter\n     * RewriteSpecial.convertIfNeeded({\"special\": {\"type\":\"image_carousel\", \"image_key\": \"some_image_key\"}}, ConversionContext.test()) // =>  {'*': \"{image_carousel(some_image_key)}\"}\n     *\n     * // should handle special case with a translated parameter\n     * const spec = {\"special\": {\"type\":\"image_upload\", \"label\": {\"en\": \"Add a picture to this object\", \"nl\": \"Voeg een afbeelding toe\"}}}\n     * const r = RewriteSpecial.convertIfNeeded(spec, ConversionContext.test())\n     * r // => {\"en\": \"{image_upload(,Add a picture to this object)}\", \"nl\": \"{image_upload(,Voeg een afbeelding toe)}\" }\n     *\n     * // should handle special case with a prefix and postfix\n     * const spec = {\"special\": {\"type\":\"image_upload\" }, before: {\"en\": \"PREFIX \"}, after: {\"en\": \" POSTFIX\", nl: \" Achtervoegsel\"} }\n     * const r = RewriteSpecial.convertIfNeeded(spec, ConversionContext.test())\n     * r // => {\"en\": \"PREFIX {image_upload(,)} POSTFIX\", \"nl\": \"PREFIX {image_upload(,)} Achtervoegsel\" }\n     *\n     * // should warn for unexpected keys\n     * const context = ConversionContext.test()\n     * RewriteSpecial.convertIfNeeded({\"special\": {type: \"image_carousel\"}, \"en\": \"xyz\"}, context) // =>  {'*': \"{image_carousel()}\"}\n     * context.getAll(\"error\")[0].message // => \"The only keys allowed next to a 'special'-block are 'before' and 'after'. Perhaps you meant to put 'en' into the special block?\"\n     *\n     * // should give an error on unknown visualisations\n     * const context = ConversionContext.test()\n     * RewriteSpecial.convertIfNeeded({\"special\": {type: \"qsdf\"}}, context) // => undefined\n     * context.getAll(\"error\")[0].message.indexOf(\"Special visualisation 'qsdf' not found\") >= 0 // => true\n     *\n     * // should give an error is 'type' is missing\n     * const context = ConversionContext.test()\n     * RewriteSpecial.convertIfNeeded({\"special\": {}}, context) // => undefined\n     * context.getAll(\"error\")[0].message // => \"A 'special'-block should define 'type' to indicate which visualisation should be used\"\n     *\n     *\n     * // an actual test\n     * const special = {\n     *     \"before\": {\n     *             \"en\": \"<h3>Entrances</h3>This building has {_entrances_count} entrances:\"\n     *           },\n     *     \"after\": {\n     *             \"en\": \"{_entrances_count_without_width_count} entrances don't have width information yet\"\n     *           },\n     *     \"special\": {\n     *           \"type\": \"multi\",\n     *           \"key\": \"_entrance_properties_with_width\",\n     *           \"tagrendering\": {\n     *             \"en\": \"An <a href='#{id}'>entrance</a> of {canonical(width)}\"\n     *           }\n     *         }}\n     * const context = ConversionContext.test()\n     * RewriteSpecial.convertIfNeeded(special, context) // => {\"en\": \"<h3>Entrances</h3>This building has {_entrances_count} entrances:{multi(_entrance_properties_with_width,An <a href='#&LBRACEid&RBRACE'>entrance</a> of &LBRACEcanonical&LPARENSwidth&RPARENS&RBRACE)}{_entrances_count_without_width_count} entrances don't have width information yet\"}\n     * context.getAll(\"error\") // => []\n     */\n    private static convertIfNeeded(\n        input:\n            | (object & {\n                  special: {\n                      type: string\n                  }\n              })\n            | any,\n        context: ConversionContext\n    ): any {\n        const special = input[\"special\"]\n        if (special === undefined) {\n            return input\n        }\n\n        const type = special[\"type\"]\n        if (type === undefined) {\n            context.err(\n                \"A 'special'-block should define 'type' to indicate which visualisation should be used\"\n            )\n            return undefined\n        }\n\n        const vis = SpecialVisualizations.specialVisualizations.find((sp) => sp.funcName === type)\n        if (vis === undefined) {\n            const options = Utils.sortedByLevenshteinDistance(\n                type,\n                SpecialVisualizations.specialVisualizations,\n                (sp) => sp.funcName\n            )\n            context.err(\n                `Special visualisation '${type}' not found. Did you perhaps mean ${options[0].funcName}, ${options[1].funcName} or ${options[2].funcName}?\\n\\tFor all known special visualisations, please see https://github.com/pietervdvn/MapComplete/blob/develop/Docs/SpecialRenderings.md`\n            )\n            return undefined\n        }\n        Array.from(Object.keys(input))\n            .filter((k) => k !== \"special\" && k !== \"before\" && k !== \"after\")\n            .map((k) => {\n                return `The only keys allowed next to a 'special'-block are 'before' and 'after'. Perhaps you meant to put '${k}' into the special block?`\n            })\n            .forEach((e) => context.err(e))\n\n        const argNamesList = vis.args.map((a) => a.name)\n        const argNames = new Set<string>(argNamesList)\n        // Check for obsolete and misspelled arguments\n        Object.keys(special)\n            .filter((k) => !argNames.has(k))\n            .filter((k) => k !== \"type\" && k !== \"before\" && k !== \"after\")\n            .map((wrongArg) => {\n                const byDistance = Utils.sortedByLevenshteinDistance(\n                    wrongArg,\n                    argNamesList,\n                    (x) => x\n                )\n                return `Unexpected argument in special block at ${context} with name '${wrongArg}'. Did you mean ${\n                    byDistance[0]\n                }?\\n\\tAll known arguments are ${argNamesList.join(\", \")}`\n            })\n            .forEach((e) => context.err(e))\n\n        // Check that all obligated arguments are present. They are obligated if they don't have a preset value\n        for (const arg of vis.args) {\n            if (arg.required !== true) {\n                continue\n            }\n            const param = special[arg.name]\n            if (param === undefined) {\n                context.err(\n                    `Obligated parameter '${arg.name}' in special rendering of type ${\n                        vis.funcName\n                    } not found.\\n    The full special rendering specification is: '${JSON.stringify(\n                        input\n                    )}'\\n    ${arg.name}: ${arg.doc}`\n                )\n            }\n        }\n\n        const foundLanguages = new Set<string>()\n        const translatedArgs = argNamesList\n            .map((nm) => special[nm])\n            .filter((v) => v !== undefined)\n            .filter((v) => Translations.isProbablyATranslation(v))\n        for (const translatedArg of translatedArgs) {\n            for (const ln of Object.keys(translatedArg)) {\n                foundLanguages.add(ln)\n            }\n        }\n\n        const before = Translations.T(input.before)\n        const after = Translations.T(input.after)\n\n        for (const ln of Object.keys(before?.translations ?? {})) {\n            foundLanguages.add(ln)\n        }\n        for (const ln of Object.keys(after?.translations ?? {})) {\n            foundLanguages.add(ln)\n        }\n\n        if (foundLanguages.size === 0) {\n            const args = argNamesList.map((nm) => special[nm] ?? \"\").join(\",\")\n            return {\n                \"*\": `{${type}(${args})}`,\n            }\n        }\n\n        const result = {}\n        const languages = Array.from(foundLanguages)\n        languages.sort()\n        for (const ln of languages) {\n            const args = []\n            for (const argName of argNamesList) {\n                let v = special[argName] ?? \"\"\n                if (Translations.isProbablyATranslation(v)) {\n                    v = new Translation(v).textFor(ln)\n                }\n\n                if (typeof v === \"string\") {\n                    const txt = v\n                        .replace(/,/g, \"&COMMA\")\n                        .replace(/\\{/g, \"&LBRACE\")\n                        .replace(/}/g, \"&RBRACE\")\n                        .replace(/\\(/g, \"&LPARENS\")\n                        .replace(/\\)/g, \"&RPARENS\")\n                    args.push(txt)\n                } else if (typeof v === \"object\") {\n                    args.push(JSON.stringify(v))\n                } else {\n                    args.push(v)\n                }\n            }\n            const beforeText = before?.textFor(ln) ?? \"\"\n            const afterText = after?.textFor(ln) ?? \"\"\n            result[ln] = `${beforeText}{${type}(${args.map((a) => a).join(\",\")})}${afterText}`\n        }\n        return result\n    }\n\n    /**\n     * const tr = {\n     *     render: {special: {type: \"image_carousel\", image_key: \"image\" }},\n     *     mappings: [\n     *         {\n     *             if: \"other_image_key\",\n     *             then: {special: {type: \"image_carousel\", image_key: \"other_image_key\"}}\n     *         }\n     *     ]\n     * }\n     * const result = new RewriteSpecial().convertStrict(tr,ConversionContext.test())\n     * const expected = {render:  {'*': \"{image_carousel(image)}\"}, mappings: [{if: \"other_image_key\", then:  {'*': \"{image_carousel(other_image_key)}\"}} ]}\n     * result // => expected\n     *\n     * // Should put text before if specified\n     * const tr = {\n     *     render: {special: {type: \"image_carousel\", image_key: \"image\"}, before: {en: \"Some introduction\"} },\n     * }\n     * const result = new RewriteSpecial().convertStrict(tr,ConversionContext.test())\n     * const expected = {render:  {'en': \"Some introduction{image_carousel(image)}\"}}\n     * result // => expected\n     *\n     * // Should put text after if specified\n     * const tr = {\n     *     render: {special: {type: \"image_carousel\", image_key: \"image\"}, after: {en: \"Some footer\"} },\n     * }\n     * const result = new RewriteSpecial().convertStrict(tr,ConversionContext.test())\n     * const expected = {render:  {'en': \"{image_carousel(image)}Some footer\"}}\n     * result // => expected\n     */\n    convert(json: TagRenderingConfigJson, context: ConversionContext): TagRenderingConfigJson {\n        json = Utils.Clone(json)\n        const paths: ConfigMeta[] = tagrenderingconfigmeta\n        for (const path of paths) {\n            if (path.hints.typehint !== \"rendered\") {\n                continue\n            }\n            Utils.WalkPath(path.path, json, (leaf, travelled) =>\n                RewriteSpecial.convertIfNeeded(leaf, context.enter(travelled))\n            )\n        }\n\n        return json\n    }\n}\n\nclass ExpandIconBadges extends DesugaringStep<PointRenderingConfigJson> {\n    private _expand: ExpandTagRendering\n\n    constructor(state: DesugaringContext, layer: LayerConfigJson) {\n        super(\"Expands shorthand properties on iconBadges\", [\"iconBadges\"], \"ExpandIconBadges\")\n        this._expand = new ExpandTagRendering(state, layer)\n    }\n\n    convert(json: PointRenderingConfigJson, context: ConversionContext): PointRenderingConfigJson {\n        if (!json[\"iconBadges\"]) {\n            return json\n        }\n        const badgesJson = json.iconBadges\n\n        const iconBadges: {\n            if: TagConfigJson\n            then: string | MinimalTagRenderingConfigJson\n        }[] = []\n\n        for (let i = 0; i < badgesJson.length; i++) {\n            const iconBadge: {\n                if: TagConfigJson\n                then: string | MinimalTagRenderingConfigJson\n            } = badgesJson[i]\n            const expanded = this._expand.convert(\n                <QuestionableTagRenderingConfigJson>iconBadge.then,\n                context.enters(\"iconBadges\", i)\n            )\n            if (expanded === undefined) {\n                iconBadges.push(iconBadge)\n                continue\n            }\n\n            iconBadges.push(\n                ...expanded.map((resolved) => ({\n                    if: iconBadge.if,\n                    then: <MinimalTagRenderingConfigJson>resolved,\n                }))\n            )\n        }\n\n        return { ...json, iconBadges }\n    }\n}\n\nclass PreparePointRendering extends Fuse<PointRenderingConfigJson> {\n    constructor(state: DesugaringContext, layer: LayerConfigJson) {\n        super(\n            \"Prepares point renderings by expanding 'icon' and 'iconBadges'\",\n            new On(\n                \"marker\",\n                new Each(\n                    new On(\n                        \"icon\",\n                        new FirstOf(new ExpandTagRendering(state, layer, { applyCondition: false }))\n                    )\n                )\n            ),\n            new ExpandIconBadges(state, layer)\n        )\n    }\n}\n\nclass SetFullNodeDatabase extends DesugaringStep<LayerConfigJson> {\n    constructor() {\n        super(\n            \"sets the fullNodeDatabase-bit if needed\",\n            [\"fullNodeDatabase\"],\n            \"SetFullNodeDatabase\"\n        )\n    }\n\n    convert(json: LayerConfigJson, context: ConversionContext): LayerConfigJson {\n        const needsSpecial =\n            json.tagRenderings?.some((tr) => {\n                if (typeof tr === \"string\") {\n                    return false\n                }\n                const specs = ValidationUtils.getSpecialVisualisations(<TagRenderingConfigJson>tr)\n                return specs?.some((sp) => sp.needsNodeDatabase)\n            }) ?? false\n        if (!needsSpecial) {\n            return json\n        }\n        context.info(\"Layer \" + json.id + \" needs the fullNodeDatabase\")\n        return { ...json, fullNodeDatabase: true }\n    }\n}\n\nclass ExpandMarkerRenderings extends DesugaringStep<IconConfigJson> {\n    private readonly _layer: LayerConfigJson\n    private readonly _state: DesugaringContext\n\n    constructor(state: DesugaringContext, layer: LayerConfigJson) {\n        super(\n            \"Expands tagRenderings in the icons, if needed\",\n            [\"icon\", \"color\"],\n            \"ExpandMarkerRenderings\"\n        )\n        this._layer = layer\n        this._state = state\n    }\n\n    convert(json: IconConfigJson, context: ConversionContext): IconConfigJson {\n        const expander = new ExpandTagRendering(this._state, this._layer)\n        const result: IconConfigJson = { icon: undefined, color: undefined }\n        if (json.icon && json.icon[\"builtin\"]) {\n            result.icon = <MinimalTagRenderingConfigJson>(\n                expander.convert(<any>json.icon, context.enter(\"icon\"))[0]\n            )\n        } else {\n            result.icon = json.icon\n        }\n        if (json.color && json.color[\"builtin\"]) {\n            result.color = <MinimalTagRenderingConfigJson>(\n                expander.convert(<any>json.color, context.enter(\"color\"))[0]\n            )\n        } else {\n            result.color = json.color\n        }\n        return result\n    }\n}\n\nexport class PrepareLayer extends Fuse<LayerConfigJson> {\n    constructor(state: DesugaringContext) {\n        super(\n            \"Fully prepares and expands a layer for the LayerConfig.\",\n            new On(\"tagRenderings\", new Each(new RewriteSpecial())),\n            new On(\"tagRenderings\", new Concat(new ExpandRewrite()).andThenF(Utils.Flatten)),\n            new On(\"tagRenderings\", (layer) => new Concat(new ExpandTagRendering(state, layer))),\n            new On(\"tagRenderings\", new Each(new DetectInline())),\n            new AddQuestionBox(),\n            new AddEditingElements(state),\n            new SetFullNodeDatabase(),\n            new On<\n                (LineRenderingConfigJson | RewritableConfigJson<LineRenderingConfigJson>)[],\n                LayerConfigJson\n            >(\"lineRendering\", new Each(new ExpandRewrite()).andThenF(Utils.Flatten)),\n            new On<PointRenderingConfigJson[], LayerConfigJson>(\n                \"pointRendering\",\n                (layer) =>\n                    new Each(new On(\"marker\", new Each(new ExpandMarkerRenderings(state, layer))))\n            ),\n            new On<PointRenderingConfigJson[], LayerConfigJson>(\n                \"pointRendering\",\n                (layer) => new Each(new PreparePointRendering(state, layer))\n            ),\n            new SetDefault(\"titleIcons\", [\"icons.defaults\"]),\n            new On(\n                \"titleIcons\",\n                (layer) =>\n                    new Concat(new ExpandTagRendering(state, layer, { noHardcodedStrings: true }))\n            ),\n            new ExpandFilter(state)\n        )\n    }\n}\n","import { Conversion, DesugaringStep, Each, Fuse, On, Pipe, Pure } from \"./Conversion\"\nimport { LayerConfigJson } from \"../Json/LayerConfigJson\"\nimport LayerConfig from \"../LayerConfig\"\nimport { Utils } from \"../../../Utils\"\nimport Constants from \"../../Constants\"\nimport { Translation } from \"../../../UI/i18n/Translation\"\nimport { LayoutConfigJson } from \"../Json/LayoutConfigJson\"\nimport LayoutConfig from \"../LayoutConfig\"\nimport { TagRenderingConfigJson } from \"../Json/TagRenderingConfigJson\"\nimport { TagUtils } from \"../../../Logic/Tags/TagUtils\"\nimport { ExtractImages } from \"./FixImages\"\nimport { And } from \"../../../Logic/Tags/And\"\nimport Translations from \"../../../UI/i18n/Translations\"\nimport Svg from \"../../../Svg\"\nimport FilterConfigJson from \"../Json/FilterConfigJson\"\nimport DeleteConfig from \"../DeleteConfig\"\nimport { QuestionableTagRenderingConfigJson } from \"../Json/QuestionableTagRenderingConfigJson\"\nimport Validators from \"../../../UI/InputElement/Validators\"\nimport TagRenderingConfig from \"../TagRenderingConfig\"\nimport { parse as parse_html } from \"node-html-parser\"\nimport PresetConfig from \"../PresetConfig\"\nimport { TagsFilter } from \"../../../Logic/Tags/TagsFilter\"\nimport { Translatable } from \"../Json/Translatable\"\nimport { ConversionContext } from \"./ConversionContext\"\n\nclass ValidateLanguageCompleteness extends DesugaringStep<any> {\n    private readonly _languages: string[]\n\n    constructor(...languages: string[]) {\n        super(\n            \"Checks that the given object is fully translated in the specified languages\",\n            [],\n            \"ValidateLanguageCompleteness\"\n        )\n        this._languages = languages ?? [\"en\"]\n    }\n\n    convert(obj: any, context: ConversionContext): LayerConfig {\n        const translations = Translation.ExtractAllTranslationsFrom(obj)\n        for (const neededLanguage of this._languages) {\n            translations\n                .filter(\n                    (t) =>\n                        t.tr.translations[neededLanguage] === undefined &&\n                        t.tr.translations[\"*\"] === undefined\n                )\n                .forEach((missing) => {\n                    context\n                        .enter(missing.context.split(\".\"))\n                        .err(\n                            `The theme ${obj.id} should be translation-complete for ` +\n                                neededLanguage +\n                                \", but it lacks a translation for \" +\n                                missing.context +\n                                \".\\n\\tThe known translation is \" +\n                                missing.tr.textFor(\"en\")\n                        )\n                })\n        }\n\n        return obj\n    }\n}\n\nexport class DoesImageExist extends DesugaringStep<string> {\n    private readonly _knownImagePaths: Set<string>\n    private readonly _ignore?: Set<string>\n    private readonly doesPathExist: (path: string) => boolean = undefined\n\n    constructor(\n        knownImagePaths: Set<string>,\n        checkExistsSync: (path: string) => boolean = undefined,\n        ignore?: Set<string>\n    ) {\n        super(\"Checks if an image exists\", [], \"DoesImageExist\")\n        this._ignore = ignore\n        this._knownImagePaths = knownImagePaths\n        this.doesPathExist = checkExistsSync\n    }\n\n    convert(image: string, context: ConversionContext): string {\n        if (this._ignore?.has(image)) {\n            return image\n        }\n\n        if (image.indexOf(\"{\") >= 0) {\n            context.debug(\"Ignoring image with { in the path: \" + image)\n            return image\n        }\n\n        if (image === \"assets/SocialImage.png\") {\n            return image\n        }\n        if (image.match(/[a-z]*/)) {\n            if (Svg.All[image + \".svg\"] !== undefined) {\n                // This is a builtin img, e.g. 'checkmark' or 'crosshair'\n                return image\n            }\n        }\n\n        if (image.startsWith(\"<\") && image.endsWith(\">\")) {\n            // This is probably HTML, you're on your own here\n            return image\n        }\n\n        if (!this._knownImagePaths.has(image)) {\n            if (this.doesPathExist === undefined) {\n                context.err(\n                    `Image with path ${image} not found or not attributed; it is used in ${context}`\n                )\n            } else if (!this.doesPathExist(image)) {\n                context.err(\n                    `Image with path ${image} does not exist; it is used in ${context}.\\n     Check for typo's and missing directories in the path.`\n                )\n            } else {\n                context.err(\n                    `Image with path ${image} is not attributed (but it exists); execute 'npm run query:licenses' to add the license information and/or run 'npm run generate:licenses' to compile all the license info`\n                )\n            }\n        }\n        return image\n    }\n}\n\nexport class ValidateTheme extends DesugaringStep<LayoutConfigJson> {\n    /**\n     * The paths where this layer is originally saved. Triggers some extra checks\n     * @private\n     */\n    private readonly _path?: string\n    private readonly _isBuiltin: boolean\n    //private readonly _sharedTagRenderings: Map<string, any>\n    private readonly _validateImage: DesugaringStep<string>\n    private readonly _extractImages: ExtractImages = undefined\n\n    constructor(\n        doesImageExist: DoesImageExist,\n        path: string,\n        isBuiltin: boolean,\n        sharedTagRenderings?: Set<string>\n    ) {\n        super(\"Doesn't change anything, but emits warnings and errors\", [], \"ValidateTheme\")\n        this._validateImage = doesImageExist\n        this._path = path\n        this._isBuiltin = isBuiltin\n        if (sharedTagRenderings) {\n            this._extractImages = new ExtractImages(this._isBuiltin, sharedTagRenderings)\n        }\n    }\n\n    convert(json: LayoutConfigJson, context: ConversionContext): LayoutConfigJson {\n        const theme = new LayoutConfig(json, this._isBuiltin)\n        {\n            // Legacy format checks\n            if (this._isBuiltin) {\n                if (json[\"units\"] !== undefined) {\n                    context.err(\n                        \"The theme \" +\n                            json.id +\n                            \" has units defined - these should be defined on the layer instead. (Hint: use overrideAll: { '+units': ... }) \"\n                    )\n                }\n                if (json[\"roamingRenderings\"] !== undefined) {\n                    context.err(\n                        \"Theme \" +\n                            json.id +\n                            \" contains an old 'roamingRenderings'. Use an 'overrideAll' instead\"\n                    )\n                }\n            }\n        }\n        if (!json.title) {\n            context.enter(\"title\").err(`The theme ${json.id} does not have a title defined.`)\n        }\n        if (this._isBuiltin && this._extractImages !== undefined) {\n            // Check images: are they local, are the licenses there, is the theme icon square, ...\n            const images = this._extractImages.convert(json, context.inOperation(\"ValidateTheme\"))\n            const remoteImages = images.filter((img) => img.path.indexOf(\"http\") == 0)\n            for (const remoteImage of remoteImages) {\n                context.err(\n                    \"Found a remote image: \" +\n                        remoteImage.path +\n                        \" in theme \" +\n                        json.id +\n                        \", please download it.\"\n                )\n            }\n            for (const image of images) {\n                this._validateImage.convert(image.path, context.enters(image.context))\n            }\n        }\n\n        try {\n            if (this._isBuiltin) {\n                if (theme.id !== theme.id.toLowerCase()) {\n                    context.err(\"Theme ids should be in lowercase, but it is \" + theme.id)\n                }\n\n                const filename = this._path.substring(\n                    this._path.lastIndexOf(\"/\") + 1,\n                    this._path.length - 5\n                )\n                if (theme.id !== filename) {\n                    context.err(\n                        \"Theme ids should be the same as the name.json, but we got id: \" +\n                            theme.id +\n                            \" and filename \" +\n                            filename +\n                            \" (\" +\n                            this._path +\n                            \")\"\n                    )\n                }\n                this._validateImage.convert(theme.icon, context.enter(\"icon\"))\n            }\n            const dups = Utils.Duplicates(json.layers.map((layer) => layer[\"id\"]))\n            if (dups.length > 0) {\n                context.err(\n                    `The theme ${json.id} defines multiple layers with id ${dups.join(\", \")}`\n                )\n            }\n            if (json[\"mustHaveLanguage\"] !== undefined) {\n                new ValidateLanguageCompleteness(...json[\"mustHaveLanguage\"]).convert(\n                    theme,\n                    context\n                )\n            }\n            if (!json.hideFromOverview && theme.id !== \"personal\" && this._isBuiltin) {\n                // The first key in the the title-field must be english, otherwise the title in the loading page will be the different language\n                const targetLanguage = theme.title.SupportedLanguages()[0]\n                if (targetLanguage !== \"en\") {\n                    context.err(\n                        `TargetLanguage is not 'en' for public theme ${theme.id}, it is ${targetLanguage}. Move 'en' up in the title of the theme and set it as the first key`\n                    )\n                }\n\n                // Official, public themes must have a full english translation\n                new ValidateLanguageCompleteness(\"en\").convert(theme, context)\n            }\n        } catch (e) {\n            context.err(e)\n        }\n\n        if (theme.id !== \"personal\") {\n            new DetectDuplicatePresets().convert(theme, context)\n        }\n\n        if (!theme.title) {\n            context.enter(\"title\").err(\"A theme must have a title\")\n        }\n\n        if (!theme.description) {\n            context.enter(\"description\").err(\"A theme must have a description\")\n        }\n\n        if (theme.overpassUrl && typeof theme.overpassUrl === \"string\") {\n            context\n                .enter(\"overpassUrl\")\n                .err(\"The overpassURL is a string, use a list of strings instead. Wrap it with [ ]\")\n        }\n\n        return json\n    }\n}\n\nexport class ValidateThemeAndLayers extends Fuse<LayoutConfigJson> {\n    constructor(\n        doesImageExist: DoesImageExist,\n        path: string,\n        isBuiltin: boolean,\n        sharedTagRenderings?: Set<string>\n    ) {\n        super(\n            \"Validates a theme and the contained layers\",\n            new ValidateTheme(doesImageExist, path, isBuiltin, sharedTagRenderings),\n            new On(\n                \"layers\",\n                new Each(\n                    new Pipe(\n                        new ValidateLayer(undefined, isBuiltin, doesImageExist, false, true),\n                        new Pure((x) => x?.raw)\n                    )\n                )\n            )\n        )\n    }\n}\n\nclass OverrideShadowingCheck extends DesugaringStep<LayoutConfigJson> {\n    constructor() {\n        super(\n            \"Checks that an 'overrideAll' does not override a single override\",\n            [],\n            \"OverrideShadowingCheck\"\n        )\n    }\n\n    convert(json: LayoutConfigJson, context: ConversionContext): LayoutConfigJson {\n        const overrideAll = json.overrideAll\n        if (overrideAll === undefined) {\n            return json\n        }\n\n        const withOverride = json.layers.filter((l) => l[\"override\"] !== undefined)\n\n        for (const layer of withOverride) {\n            for (const key in overrideAll) {\n                if (key.endsWith(\"+\") || key.startsWith(\"+\")) {\n                    // This key will _add_ to the list, not overwrite it - so no warning is needed\n                    continue\n                }\n                if (\n                    layer[\"override\"][key] !== undefined ||\n                    layer[\"override\"][\"=\" + key] !== undefined\n                ) {\n                    const w =\n                        \"The override of layer \" +\n                        JSON.stringify(layer[\"builtin\"]) +\n                        \" has a shadowed property: \" +\n                        key +\n                        \" is overriden by overrideAll of the theme\"\n                    context.err(w)\n                }\n            }\n        }\n\n        return json\n    }\n}\n\nclass MiscThemeChecks extends DesugaringStep<LayoutConfigJson> {\n    constructor() {\n        super(\"Miscelleanous checks on the theme\", [], \"MiscThemesChecks\")\n    }\n\n    convert(json: LayoutConfigJson, context: ConversionContext): LayoutConfigJson {\n        if (json.id !== \"personal\" && (json.layers === undefined || json.layers.length === 0)) {\n            context.err(\"The theme \" + json.id + \" has no 'layers' defined\")\n        }\n        if (json.socialImage === \"\") {\n            context.warn(\"Social image for theme \" + json.id + \" is the emtpy string\")\n        }\n        return json\n    }\n}\n\nexport class PrevalidateTheme extends Fuse<LayoutConfigJson> {\n    constructor() {\n        super(\n            \"Various consistency checks on the raw JSON\",\n            new MiscThemeChecks(),\n            new OverrideShadowingCheck()\n        )\n    }\n}\n\nexport class DetectConflictingAddExtraTags extends DesugaringStep<TagRenderingConfigJson> {\n    constructor() {\n        super(\n            \"The `if`-part in a mapping might set some keys. Those key are not allowed to be set in the `addExtraTags`, as this might result in conflicting values\",\n            [],\n            \"DetectConflictingAddExtraTags\"\n        )\n    }\n\n    convert(json: TagRenderingConfigJson, context: ConversionContext): TagRenderingConfigJson {\n        if (!(json.mappings?.length > 0)) {\n            return json\n        }\n\n        try {\n            const tagRendering = new TagRenderingConfig(json)\n\n            for (let i = 0; i < tagRendering.mappings.length; i++) {\n                const mapping = tagRendering.mappings[i]\n                if (!mapping.addExtraTags) {\n                    continue\n                }\n                const keysInMapping = new Set(mapping.if.usedKeys())\n\n                const keysInAddExtraTags = mapping.addExtraTags.map((t) => t.key)\n\n                const duplicateKeys = keysInAddExtraTags.filter((k) => keysInMapping.has(k))\n                if (duplicateKeys.length > 0) {\n                    context\n                        .enters(\"mappings\", i)\n                        .err(\n                            \"AddExtraTags overrides a key that is set in the `if`-clause of this mapping. Selecting this answer might thus first set one value (needed to match as answer) and then override it with a different value, resulting in an unsaveable question. The offending `addExtraTags` is \" +\n                                duplicateKeys.join(\", \")\n                        )\n                }\n            }\n\n            return json\n        } catch (e) {\n            context.err(e)\n            return undefined\n        }\n    }\n}\n\nexport class DetectShadowedMappings extends DesugaringStep<TagRenderingConfigJson> {\n    private readonly _calculatedTagNames: string[]\n\n    constructor(layerConfig?: LayerConfigJson) {\n        super(\"Checks that the mappings don't shadow each other\", [], \"DetectShadowedMappings\")\n        this._calculatedTagNames = DetectShadowedMappings.extractCalculatedTagNames(layerConfig)\n    }\n\n    /**\n     *\n     * DetectShadowedMappings.extractCalculatedTagNames({calculatedTags: [\"_abc:=js()\"]}) // => [\"_abc\"]\n     * DetectShadowedMappings.extractCalculatedTagNames({calculatedTags: [\"_abc=js()\"]}) // => [\"_abc\"]\n     */\n    private static extractCalculatedTagNames(\n        layerConfig?: LayerConfigJson | { calculatedTags: string[] }\n    ) {\n        return (\n            layerConfig?.calculatedTags?.map((ct) => {\n                if (ct.indexOf(\":=\") >= 0) {\n                    return ct.split(\":=\")[0]\n                }\n                return ct.split(\"=\")[0]\n            }) ?? []\n        )\n    }\n\n    /**\n     *\n     * // should detect a simple shadowed mapping\n     * const tr = {mappings: [\n     *            {\n     *                if: {or: [\"key=value\", \"x=y\"]},\n     *                then: \"Case A\"\n     *            },\n     *            {\n     *                if: \"key=value\",\n     *                then: \"Shadowed\"\n     *            }\n     *        ]\n     *    }\n     * const context = ConversionContext.test()\n     * const r = new DetectShadowedMappings().convert(tr, context);\n     * context.getAll(\"error\").length // => 1\n     * context.getAll(\"error\")[0].message.indexOf(\"The mapping key=value is fully matched by a previous mapping (namely 0)\") >= 0 // => true\n     *\n     * const tr = {mappings: [\n     *         {\n     *             if: {or: [\"key=value\", \"x=y\"]},\n     *             then: \"Case A\"\n     *         },\n     *         {\n     *             if: {and: [\"key=value\", \"x=y\"]},\n     *             then: \"Shadowed\"\n     *         }\n     *     ]\n     * }\n     * const context = ConversionContext.test()\n     * const r = new DetectShadowedMappings().convert(tr, context);\n     * context.getAll(\"error\").length // => 1\n     * context.getAll(\"error\")[0].message.indexOf(\"The mapping key=value&x=y is fully matched by a previous mapping (namely 0)\") >= 0 // => true\n     */\n    convert(json: TagRenderingConfigJson, context: ConversionContext): TagRenderingConfigJson {\n        if (json.mappings === undefined || json.mappings.length === 0) {\n            return json\n        }\n        const defaultProperties = {}\n        for (const calculatedTagName of this._calculatedTagNames) {\n            defaultProperties[calculatedTagName] =\n                \"some_calculated_tag_value_for_\" + calculatedTagName\n        }\n        const parsedConditions = json.mappings.map((m, i) => {\n            const c = context.enters(\"mappings\", i)\n            const ifTags = TagUtils.Tag(m.if, c.enter(\"if\"))\n            const hideInAnswer = m[\"hideInAnswer\"]\n            if (hideInAnswer !== undefined && hideInAnswer !== false && hideInAnswer !== true) {\n                let conditionTags = TagUtils.Tag(hideInAnswer)\n                // Merge the condition too!\n                return new And([conditionTags, ifTags])\n            }\n            return ifTags\n        })\n        for (let i = 0; i < json.mappings.length; i++) {\n            if (!parsedConditions[i]?.isUsableAsAnswer()) {\n                // There is no straightforward way to convert this mapping.if into a properties-object, so we simply skip this one\n                // Yes, it might be shadowed, but running this check is to difficult right now\n                continue\n            }\n            const keyValues = parsedConditions[i].asChange(defaultProperties)\n            const properties = {}\n            keyValues.forEach(({ k, v }) => {\n                properties[k] = v\n            })\n            for (let j = 0; j < i; j++) {\n                const doesMatch = parsedConditions[j].matchesProperties(properties)\n                if (\n                    doesMatch &&\n                    json.mappings[j][\"hideInAnswer\"] === true &&\n                    json.mappings[i][\"hideInAnswer\"] !== true\n                ) {\n                    context.warn(\n                        `Mapping ${i} is shadowed by mapping ${j}. However, mapping ${j} has 'hideInAnswer' set, which will result in a different rendering in question-mode.`\n                    )\n                } else if (doesMatch) {\n                    // The current mapping is shadowed!\n                    context.err(`Mapping ${i} is shadowed by mapping ${j} and will thus never be shown:\n    The mapping ${parsedConditions[i].asHumanString(\n        false,\n        false,\n        {}\n    )} is fully matched by a previous mapping (namely ${j}), which matches:\n    ${parsedConditions[j].asHumanString(false, false, {})}.\n\n    To fix this problem, you can try to:\n    - Move the shadowed mapping up\n    - Do you want to use a different text in 'question mode'? Add 'hideInAnswer=true' to the first mapping\n    - Use \"addExtraTags\": [\"key=value\", ...] in order to avoid a different rendering\n         (e.g. [{\"if\": \"fee=no\",                     \"then\": \"Free to use\", \"hideInAnswer\":true},\n                {\"if\": {\"and\":[\"fee=no\",\"charge=\"]}, \"then\": \"Free to use\"}]\n          can be replaced by\n               [{\"if\":\"fee=no\", \"then\": \"Free to use\", \"addExtraTags\": [\"charge=\"]}]\n`)\n                }\n            }\n        }\n\n        return json\n    }\n}\n\nexport class DetectMappingsWithImages extends DesugaringStep<TagRenderingConfigJson> {\n    private readonly _doesImageExist: DoesImageExist\n\n    constructor(doesImageExist: DoesImageExist) {\n        super(\n            \"Checks that 'then'clauses in mappings don't have images, but use 'icon' instead\",\n            [],\n            \"DetectMappingsWithImages\"\n        )\n        this._doesImageExist = doesImageExist\n    }\n\n    /**\n     * const context = ConversionContext.test()\n     * const r = new DetectMappingsWithImages(new DoesImageExist(new Set<string>())).convert({\n     *     \"mappings\": [\n     *         {\n     *             \"if\": \"bicycle_parking=stands\",\n     *             \"then\": {\n     *                 \"en\": \"Staple racks <img style='width: 25%' src='./assets/layers/bike_parking/staple.svg'>\",\n     *                 \"nl\": \"Nietjes <img style='width: 25%'' src='./assets/layers/bike_parking/staple.svg'>\",\n     *                 \"fr\": \"Arceaux <img style='width: 25%'' src='./assets/layers/bike_parking/staple.svg'>\",\n     *                 \"gl\": \"De roda (Stands) <img style='width: 25%'' src='./assets/layers/bike_parking/staple.svg'>\",\n     *                 \"de\": \"Fahrradbügel <img style='width: 25%'' src='./assets/layers/bike_parking/staple.svg'>\",\n     *                 \"hu\": \"Korlát <img style='width: 25%' src='./assets/layers/bike_parking/staple.svg'>\",\n     *                 \"it\": \"Archetti <img style='width: 25%' src='./assets/layers/bike_parking/staple.svg'>\",\n     *                 \"zh_Hant\": \"單車架 <img style='width: 25%' src='./assets/layers/bike_parking/staple.svg'>\"\n     *             }\n     *         }]\n     * }, context);\n     * context.hasErrors() // => true\n     * context.getAll(\"error\").some(msg => msg.message.indexOf(\"./assets/layers/bike_parking/staple.svg\") >= 0) // => true\n     */\n    convert(json: TagRenderingConfigJson, context: ConversionContext): TagRenderingConfigJson {\n        if (json.mappings === undefined || json.mappings.length === 0) {\n            return json\n        }\n        const ignoreToken = \"ignore-image-in-then\"\n        for (let i = 0; i < json.mappings.length; i++) {\n            const mapping = json.mappings[i]\n            const ignore = mapping[\"#\"]?.indexOf(ignoreToken) >= 0\n            const images = Utils.Dedup(Translations.T(mapping.then)?.ExtractImages() ?? [])\n            const ctx = context.enters(\"mappings\", i)\n            if (images.length > 0) {\n                if (!ignore) {\n                    ctx.err(\n                        `A mapping has an image in the 'then'-clause. Remove the image there and use \\`\"icon\": <your-image>\\` instead. The images found are ${images.join(\n                            \", \"\n                        )}. (This check can be turned of by adding \"#\": \"${ignoreToken}\" in the mapping, but this is discouraged`\n                    )\n                } else {\n                    ctx.info(\n                        `Ignored image ${images.join(\n                            \", \"\n                        )} in 'then'-clause of a mapping as this check has been disabled`\n                    )\n\n                    for (const image of images) {\n                        this._doesImageExist.convert(image, ctx)\n                    }\n                }\n            } else if (ignore) {\n                ctx.warn(`Unused '${ignoreToken}' - please remove this`)\n            }\n        }\n\n        return json\n    }\n}\n\nclass ValidatePossibleLinks extends DesugaringStep<string | Record<string, string>> {\n    constructor() {\n        super(\n            \"Given a possible set of translations, validates that <a href=... target='_blank'> does have `rel='noopener'` set\",\n            [],\n            \"ValidatePossibleLinks\"\n        )\n    }\n\n    public isTabnabbingProne(str: string): boolean {\n        const p = parse_html(str)\n        const links = Array.from(p.getElementsByTagName(\"a\"))\n        if (links.length == 0) {\n            return false\n        }\n        for (const link of Array.from(links)) {\n            if (link.getAttribute(\"target\") !== \"_blank\") {\n                continue\n            }\n            const rel = new Set<string>(link.getAttribute(\"rel\")?.split(\" \") ?? [])\n            if (rel.has(\"noopener\")) {\n                continue\n            }\n            const source = link.getAttribute(\"href\")\n            if (source.startsWith(\"http\")) {\n                // No variable part - we assume the link is safe\n                continue\n            }\n            return true\n        }\n        return false\n    }\n\n    convert(\n        json: string | Record<string, string>,\n        context: ConversionContext\n    ): string | Record<string, string> {\n        if (typeof json === \"string\") {\n            if (this.isTabnabbingProne(json)) {\n                context.err(\n                    \"The string \" +\n                        json +\n                        \" has a link targeting `_blank`, but it doesn't have `rel='noopener'` set. This gives rise to reverse tabnapping\"\n                )\n            }\n        } else {\n            for (const k in json) {\n                if (this.isTabnabbingProne(json[k])) {\n                    context.err(\n                        `The translation for ${k} '${json[k]}' has a link targeting \\`_blank\\`, but it doesn't have \\`rel='noopener'\\` set. This gives rise to reverse tabnapping`\n                    )\n                }\n            }\n        }\n        return json\n    }\n}\n\nclass CheckTranslation extends DesugaringStep<Translatable> {\n    public static readonly allowUndefined: CheckTranslation = new CheckTranslation(true)\n    public static readonly noUndefined: CheckTranslation = new CheckTranslation()\n    private readonly _allowUndefined: boolean\n\n    constructor(allowUndefined: boolean = false) {\n        super(\n            \"Checks that a translation is valid and internally consistent\",\n            [\"*\"],\n            \"CheckTranslation\"\n        )\n        this._allowUndefined = allowUndefined\n    }\n\n    convert(json: Translatable, context: ConversionContext): Translatable {\n        if (json === undefined || json === null) {\n            if (!this._allowUndefined) {\n                context.err(\"Expected a translation, but got \" + json)\n            }\n            return json\n        }\n        if (typeof json === \"string\") {\n            return json\n        }\n        const keys = Object.keys(json)\n        if (keys.length === 0) {\n            context.err(\"No actual values are given in this translation, it is completely empty\")\n            return json\n        }\n        const en = json[\"en\"]\n        if (!en && json[\"*\"] === undefined) {\n            const msg = \"Received a translation without english version\"\n            context.warn(msg)\n        }\n\n        for (const key of keys) {\n            const lng = json[key]\n            if (lng === \"\") {\n                context.enter(lng).err(\"Got an empty string in translation for language \" + lng)\n            }\n\n            // TODO validate that all subparts are here\n        }\n\n        return json\n    }\n}\n\nclass MiscTagRenderingChecks extends DesugaringStep<TagRenderingConfigJson> {\n    constructor() {\n        super(\"Miscellaneous checks on the tagrendering\", [\"special\"], \"MiscTagRenderingChecks\")\n    }\n\n    convert(\n        json: TagRenderingConfigJson | QuestionableTagRenderingConfigJson,\n        context: ConversionContext\n    ): TagRenderingConfigJson {\n        if (json[\"special\"] !== undefined) {\n            context.err(\n                'Detected `special` on the top level. Did you mean `{\"render\":{ \"special\": ... }}`'\n            )\n        }\n\n        {\n            for (const key of [\"question\", \"questionHint\", \"render\"]) {\n                CheckTranslation.allowUndefined.convert(json[key], context.enter(key))\n            }\n            for (let i = 0; i < json.mappings?.length ?? 0; i++) {\n                const mapping = json.mappings[i]\n                CheckTranslation.noUndefined.convert(\n                    mapping.then,\n                    context.enters(\"mappings\", i, \"then\")\n                )\n                if (!mapping.if) {\n                    context.enters(\"mappings\", i).err(\"No `if` is defined\")\n                }\n                const en = mapping?.then?.[\"en\"]\n                if (en && en.toLowerCase().match(/(yes|no)([ ,:;.?]|$)/)) {\n                    context\n                        .enters(\"mappings\", i, \"then\")\n                        .warn(\n                            \"A mapping should not start with 'yes' or 'no'. If the attribute is known, it will only show 'yes' or 'no' <i>without</i> the question, resulting in a weird popup\"\n                        )\n                }\n            }\n        }\n        if (json[\"group\"]) {\n            context.err('Groups are deprecated, use `\"label\": [\"' + json[\"group\"] + '\"]` instead')\n        }\n\n        if (json[\"question\"] && json.freeform?.key === undefined && json.mappings === undefined) {\n            context.err(\n                \"A question is defined, but no mappings nor freeform (key) are. Add at least one of them\"\n            )\n        }\n        if (json[\"question\"] && !json.freeform && (json.mappings?.length ?? 0) == 1) {\n            context.err(\"A question is defined, but there is only one option to choose from.\")\n        }\n        if (json[\"questionHint\"] && !json[\"question\"]) {\n            context\n                .enter(\"questionHint\")\n                .err(\n                    \"A questionHint is defined, but no question is given. As such, the questionHint will never be shown\"\n                )\n        }\n\n        if (json.freeform) {\n            if (json.render === undefined) {\n                context\n                    .enter(\"render\")\n                    .err(\n                        \"This tagRendering allows to set a value to key \" +\n                            json.freeform.key +\n                            \", but does not define a `render`. Please, add a value here which contains `{\" +\n                            json.freeform.key +\n                            \"}`\"\n                    )\n            } else {\n                const render = new Translation(<any>json.render)\n                for (const ln in render.translations) {\n                    if (ln.startsWith(\"_\")) {\n                        continue\n                    }\n                    const txt: string = render.translations[ln]\n                    if (txt === \"\") {\n                        context.enter(\"render\").err(\" Rendering for language \" + ln + \" is empty\")\n                    }\n                    if (\n                        txt.indexOf(\"{\" + json.freeform.key + \"}\") >= 0 ||\n                        txt.indexOf(\"&LBRACE\" + json.freeform.key + \"&RBRACE\") >= 0\n                    ) {\n                        continue\n                    }\n                    if (txt.indexOf(\"{\" + json.freeform.key + \":\") >= 0) {\n                        continue\n                    }\n\n                    if (\n                        json.freeform[\"type\"] === \"opening_hours\" &&\n                        txt.indexOf(\"{opening_hours_table(\") >= 0\n                    ) {\n                        continue\n                    }\n                    const keyFirstArg = [\"canonical\", \"fediverse_link\", \"translated\"]\n                    if (\n                        keyFirstArg.some(\n                            (funcName) => txt.indexOf(`{${funcName}(${json.freeform.key}`) >= 0\n                        )\n                    ) {\n                        continue\n                    }\n                    if (\n                        json.freeform[\"type\"] === \"wikidata\" &&\n                        txt.indexOf(\"{wikipedia(\" + json.freeform.key) >= 0\n                    ) {\n                        continue\n                    }\n                    if (json.freeform.key === \"wikidata\" && txt.indexOf(\"{wikipedia()\") >= 0) {\n                        continue\n                    }\n                    if (\n                        json.freeform[\"type\"] === \"wikidata\" &&\n                        txt.indexOf(`{wikidata_label(${json.freeform.key})`) >= 0\n                    ) {\n                        continue\n                    }\n                    context\n                        .enter(\"render\")\n                        .err(\n                            `The rendering for language ${ln} does not contain \\`{${json.freeform.key}}\\`. This is a bug, as this rendering should show exactly this freeform key!`\n                        )\n                }\n            }\n        }\n        if (json.render && json[\"question\"] && json.freeform === undefined) {\n            context.err(\n                `Detected a tagrendering which takes input without freeform key in ${context}; the question is ${new Translation(\n                    json[\"question\"]\n                ).textFor(\"en\")}`\n            )\n        }\n\n        const freeformType = json[\"freeform\"]?.[\"type\"]\n        if (freeformType) {\n            if (Validators.availableTypes.indexOf(freeformType) < 0) {\n                context\n                    .enters(\"freeform\", \"type\")\n                    .err(\n                        \"Unknown type: \" +\n                            freeformType +\n                            \"; try one of \" +\n                            Validators.availableTypes.join(\", \")\n                    )\n            }\n        }\n\n        return json\n    }\n}\n\nexport class ValidateTagRenderings extends Fuse<TagRenderingConfigJson> {\n    constructor(layerConfig?: LayerConfigJson, doesImageExist?: DoesImageExist) {\n        super(\n            \"Various validation on tagRenderingConfigs\",\n            new DetectShadowedMappings(layerConfig),\n            new DetectConflictingAddExtraTags(),\n            new DetectMappingsWithImages(doesImageExist),\n            new On(\"render\", new ValidatePossibleLinks()),\n            new On(\"question\", new ValidatePossibleLinks()),\n            new On(\"questionHint\", new ValidatePossibleLinks()),\n            new On(\"mappings\", new Each(new On(\"then\", new ValidatePossibleLinks()))),\n            new MiscTagRenderingChecks()\n        )\n    }\n}\n\nexport class PrevalidateLayer extends DesugaringStep<LayerConfigJson> {\n    private readonly _isBuiltin: boolean\n    private readonly _doesImageExist: DoesImageExist\n    /**\n     * The paths where this layer is originally saved. Triggers some extra checks\n     */\n    private readonly _path: string\n    private readonly _studioValidations: boolean\n\n    constructor(path: string, isBuiltin, doesImageExist, studioValidations) {\n        super(\"Runs various checks against common mistakes for a layer\", [], \"PrevalidateLayer\")\n        this._path = path\n        this._isBuiltin = isBuiltin\n        this._doesImageExist = doesImageExist\n        this._studioValidations = studioValidations\n    }\n\n    convert(json: LayerConfigJson, context: ConversionContext): LayerConfigJson {\n        if (json.id === undefined) {\n            context.enter(\"id\").err(`Not a valid layer: id is undefined`)\n        } else {\n            if (json.id?.toLowerCase() !== json.id) {\n                context.enter(\"id\").err(`The id of a layer should be lowercase: ${json.id}`)\n            }\n            if (json.id?.match(/[a-z0-9-_]/) == null) {\n                context.enter(\"id\").err(`The id of a layer should match [a-z0-9-_]*: ${json.id}`)\n            }\n        }\n\n        if (json.source === undefined) {\n            context\n                .enter(\"source\")\n                .err(\n                    \"No source section is defined; please define one as data is not loaded otherwise\"\n                )\n        } else {\n            if (json.source === \"special\" || json.source === \"special:library\") {\n            } else if (json.source && json.source[\"osmTags\"] === undefined) {\n                context\n                    .enters(\"source\", \"osmTags\")\n                    .err(\n                        \"No osmTags defined in the source section - these should always be present, even for geojson layer\"\n                    )\n            } else {\n                const osmTags = TagUtils.Tag(json.source[\"osmTags\"], context + \"source.osmTags\")\n                if (osmTags.isNegative()) {\n                    context\n                        .enters(\"source\", \"osmTags\")\n                        .err(\n                            \"The source states tags which give a very wide selection: it only uses negative expressions, which will result in too much and unexpected data. Add at least one required tag. The tags are:\\n\\t\" +\n                                osmTags.asHumanString(false, false, {})\n                        )\n                }\n            }\n\n            if (json.source[\"geoJsonSource\"] !== undefined) {\n                context\n                    .enters(\"source\", \"geoJsonSource\")\n                    .err(\"Use 'geoJson' instead of 'geoJsonSource'\")\n            }\n\n            if (json.source[\"geojson\"] !== undefined) {\n                context\n                    .enters(\"source\", \"geojson\")\n                    .err(\"Use 'geoJson' instead of 'geojson' (the J is a capital letter)\")\n            }\n        }\n\n        if (\n            json.syncSelection !== undefined &&\n            LayerConfig.syncSelectionAllowed.indexOf(json.syncSelection) < 0\n        ) {\n            context\n                .enter(\"syncSelection\")\n                .err(\n                    \"Invalid sync-selection: must be one of \" +\n                        LayerConfig.syncSelectionAllowed.map((v) => `'${v}'`).join(\", \") +\n                        \" but got '\" +\n                        json.syncSelection +\n                        \"'\"\n                )\n        }\n\n        if (json.source === \"special\") {\n            if (!Constants.priviliged_layers.find((x) => x == json.id)) {\n                context.err(\n                    \"Layer \" +\n                        json.id +\n                        \" uses 'special' as source.osmTags. However, this layer is not a priviliged layer\"\n                )\n            }\n        }\n\n        if (context.hasErrors()) {\n            return undefined\n        }\n\n        if (json.tagRenderings !== undefined && json.tagRenderings.length > 0) {\n            new On(\"tagRendering\", new Each(new ValidateTagRenderings(json)))\n            if (json.title === undefined && json.source !== \"special:library\") {\n                context.err(\n                    \"This layer does not have a title defined but it does have tagRenderings. Not having a title will disable the popups, resulting in an unclickable element. Please add a title. If not having a popup is intended and the tagrenderings need to be kept (e.g. in a library layer), set `title: null` to disable this error.\"\n                )\n            }\n            if (json.title === null) {\n                context.info(\n                    \"Title is `null`. This results in an element that cannot be clicked - even though tagRenderings is set.\"\n                )\n            }\n\n            {\n                // Check for multiple, identical builtin questions - usability for studio users\n                const duplicates = Utils.Duplicates(\n                    <string[]>json.tagRenderings.filter((tr) => typeof tr === \"string\")\n                )\n                for (let i = 0; i < json.tagRenderings.length; i++) {\n                    const tagRendering = json.tagRenderings[i]\n                    if (typeof tagRendering === \"string\" && duplicates.indexOf(tagRendering) > 0) {\n                        context\n                            .enters(\"tagRenderings\", i)\n                            .err(`This builtin question is used multiple times (${tagRendering})`)\n                    }\n                }\n            }\n        }\n\n        if (json[\"builtin\"] !== undefined) {\n            context.err(\"This layer hasn't been expanded: \" + json)\n            return null\n        }\n\n        if (json.minzoom > Constants.minZoomLevelToAddNewPoint) {\n            const c = context.enter(\"minzoom\")\n            const msg = `Minzoom is ${json.minzoom}, this should be at most ${Constants.minZoomLevelToAddNewPoint} as a preset is set. Why? Selecting the pin for a new item will zoom in to level before adding the point. Having a greater minzoom will hide the points, resulting in possible duplicates`\n            if (json.presets?.length > 0) {\n                c.err(msg)\n            } else {\n                c.warn(msg)\n            }\n        }\n        {\n            // duplicate ids in tagrenderings check\n            const duplicates = Utils.Dedup(\n                Utils.Duplicates(Utils.NoNull((json.tagRenderings ?? []).map((tr) => tr[\"id\"])))\n            )\n            if (duplicates.length > 0) {\n                context\n                    .enter(\"tagRenderings\")\n                    .err(\"Some tagrenderings have a duplicate id: \" + duplicates.join(\", \"))\n            }\n        }\n\n        if (json.deletion !== undefined && json.deletion instanceof DeleteConfig) {\n            if (json.deletion.softDeletionTags === undefined) {\n                context\n                    .enter(\"deletion\")\n                    .warn(\"No soft-deletion tags in deletion block for layer \" + json.id)\n            }\n        }\n\n        try {\n        } catch (e) {\n            context.err(\"Could not validate layer due to: \" + e + e.stack)\n        }\n\n        if (this._studioValidations) {\n            if (!json.description) {\n                context.enter(\"description\").err(\"A description is required\")\n            }\n            if (!json.name) {\n                context.enter(\"name\").err(\"A name is required\")\n            }\n        }\n\n        if (this._isBuiltin) {\n            // Some checks for legacy elements\n\n            if (json[\"overpassTags\"] !== undefined) {\n                context.err(\n                    \"Layer \" +\n                        json.id +\n                        'still uses the old \\'overpassTags\\'-format. Please use \"source\": {\"osmTags\": <tags>}\\' instead of \"overpassTags\": <tags> (note: this isn\\'t your fault, the custom theme generator still spits out the old format)'\n                )\n            }\n            const forbiddenTopLevel = [\n                \"icon\",\n                \"wayHandling\",\n                \"roamingRenderings\",\n                \"roamingRendering\",\n                \"label\",\n                \"width\",\n                \"color\",\n                \"colour\",\n                \"iconOverlays\",\n            ]\n            for (const forbiddenKey of forbiddenTopLevel) {\n                if (json[forbiddenKey] !== undefined)\n                    context.err(\"Layer \" + json.id + \" still has a forbidden key \" + forbiddenKey)\n            }\n            if (json[\"hideUnderlayingFeaturesMinPercentage\"] !== undefined) {\n                context.err(\n                    \"Layer \" + json.id + \" contains an old 'hideUnderlayingFeaturesMinPercentage'\"\n                )\n            }\n\n            if (\n                json.isShown !== undefined &&\n                (json.isShown[\"render\"] !== undefined || json.isShown[\"mappings\"] !== undefined)\n            ) {\n                context.warn(\"Has a tagRendering as `isShown`\")\n            }\n        }\n        if (this._isBuiltin) {\n            // Check location of layer file\n            const expected: string = `assets/layers/${json.id}/${json.id}.json`\n            if (this._path != undefined && this._path.indexOf(expected) < 0) {\n                context.err(\n                    \"Layer is in an incorrect place. The path is \" +\n                        this._path +\n                        \", but expected \" +\n                        expected\n                )\n            }\n        }\n        if (this._isBuiltin) {\n            // Check for correct IDs\n            if (json.tagRenderings?.some((tr) => tr[\"id\"] === \"\")) {\n                const emptyIndexes: number[] = []\n                for (let i = 0; i < json.tagRenderings.length; i++) {\n                    const tagRendering = json.tagRenderings[i]\n                    if (tagRendering[\"id\"] === \"\") {\n                        emptyIndexes.push(i)\n                    }\n                }\n                context\n                    .enter([\"tagRenderings\", ...emptyIndexes])\n                    .err(\n                        `Some tagrendering-ids are empty or have an emtpy string; this is not allowed (at ${emptyIndexes.join(\n                            \",\"\n                        )}])`\n                    )\n            }\n\n            const duplicateIds = Utils.Duplicates(\n                (json.tagRenderings ?? [])?.map((f) => f[\"id\"]).filter((id) => id !== \"questions\")\n            )\n            if (duplicateIds.length > 0 && !Utils.runningFromConsole) {\n                context\n                    .enter(\"tagRenderings\")\n                    .err(`Some tagRenderings have a duplicate id: ${duplicateIds}`)\n            }\n\n            if (json.description === undefined) {\n                if (typeof json.source === null) {\n                    context.err(\"A priviliged layer must have a description\")\n                } else {\n                    context.warn(\"A builtin layer should have a description\")\n                }\n            }\n        }\n\n        if (json.filter) {\n            new On(\"filter\", new Each(new ValidateFilter())).convert(json, context)\n        }\n\n        if (json.tagRenderings !== undefined) {\n            new On(\n                \"tagRenderings\",\n                new Each(new ValidateTagRenderings(json, this._doesImageExist))\n            ).convert(json, context)\n        }\n\n        if (json.pointRendering !== null && json.pointRendering !== undefined) {\n            if (!Array.isArray(json.pointRendering)) {\n                throw (\n                    \"pointRendering in \" +\n                    json.id +\n                    \" is not iterable, it is: \" +\n                    typeof json.pointRendering\n                )\n            }\n            for (let i = 0; i < json.pointRendering.length; i++) {\n                const pointRendering = json.pointRendering[i]\n                if (pointRendering.marker === undefined) {\n                    continue\n                }\n                for (const icon of pointRendering?.marker) {\n                    const indexM = pointRendering?.marker.indexOf(icon)\n                    if (!icon.icon) {\n                        continue\n                    }\n                    if (icon.icon[\"condition\"]) {\n                        context\n                            .enters(\"pointRendering\", i, \"marker\", indexM, \"icon\", \"condition\")\n                            .err(\n                                \"Don't set a condition in a marker as this will result in an invisible but clickable element. Use extra filters in the source instead.\"\n                            )\n                    }\n                }\n            }\n        }\n\n        if (json.presets !== undefined) {\n            if (typeof json.source === \"string\") {\n                context.enter(\"presets\").err(\"A special layer cannot have presets\")\n            }\n            // Check that a preset will be picked up by the layer itself\n            const baseTags = TagUtils.Tag(json.source[\"osmTags\"])\n            for (let i = 0; i < json.presets.length; i++) {\n                const preset = json.presets[i]\n                if (!preset.tags) {\n                    context.enters(\"presets\", i, \"tags\").err(\"No tags defined for this preset\")\n                    continue\n                }\n                if (!preset.tags) {\n                    context.enters(\"presets\", i, \"title\").err(\"No title defined for this preset\")\n                }\n\n                const tags = new And(preset.tags.map((t) => TagUtils.Tag(t)))\n                const properties = {}\n                for (const tag of tags.asChange({ id: \"node/-1\" })) {\n                    properties[tag.k] = tag.v\n                }\n                const doMatch = baseTags.matchesProperties(properties)\n                if (!doMatch) {\n                    context\n                        .enters(\"presets\", i, \"tags\")\n                        .err(\n                            \"This preset does not match the required tags of this layer. This implies that a newly added point will not show up.\\n    A newly created point will have properties: \" +\n                                tags.asHumanString(false, false, {}) +\n                                \"\\n    The required tags are: \" +\n                                baseTags.asHumanString(false, false, {})\n                        )\n                }\n            }\n        }\n        return json\n    }\n}\n\nexport class ValidateLayer extends Conversion<\n    LayerConfigJson,\n    { parsed: LayerConfig; raw: LayerConfigJson }\n> {\n    private readonly _skipDefaultLayers: boolean\n    private readonly _prevalidation: PrevalidateLayer\n\n    constructor(\n        path: string,\n        isBuiltin: boolean,\n        doesImageExist: DoesImageExist,\n        studioValidations: boolean = false,\n        skipDefaultLayers: boolean = false\n    ) {\n        super(\"Doesn't change anything, but emits warnings and errors\", [], \"ValidateLayer\")\n        this._prevalidation = new PrevalidateLayer(\n            path,\n            isBuiltin,\n            doesImageExist,\n            studioValidations\n        )\n        this._skipDefaultLayers = skipDefaultLayers\n    }\n\n    convert(\n        json: LayerConfigJson,\n        context: ConversionContext\n    ): { parsed: LayerConfig; raw: LayerConfigJson } {\n        context = context.inOperation(this.name)\n        if (typeof json === \"string\") {\n            context.err(\n                `Not a valid layer: the layerConfig is a string. 'npm run generate:layeroverview' might be needed`\n            )\n            return undefined\n        }\n\n        if (this._skipDefaultLayers && Constants.added_by_default.indexOf(<any>json.id) >= 0) {\n            return { parsed: undefined, raw: json }\n        }\n\n        this._prevalidation.convert(json, context.inOperation(this._prevalidation.name))\n\n        if (context.hasErrors()) {\n            return undefined\n        }\n\n        let layerConfig: LayerConfig\n        try {\n            layerConfig = new LayerConfig(json, \"validation\", true)\n        } catch (e) {\n            context.err(\"Could not parse layer due to:\" + e)\n            return undefined\n        }\n        for (let i = 0; i < (layerConfig.calculatedTags ?? []).length; i++) {\n            const [_, code, __] = layerConfig.calculatedTags[i]\n            try {\n                new Function(\"feat\", \"return \" + code + \";\")\n            } catch (e) {\n                context\n                    .enters(\"calculatedTags\", i)\n                    .err(\n                        `Invalid function definition: the custom javascript is invalid:${e}. The offending javascript code is:\\n    ${code}`\n                    )\n            }\n        }\n\n        return { raw: json, parsed: layerConfig }\n    }\n}\n\nexport class ValidateFilter extends DesugaringStep<FilterConfigJson> {\n    constructor() {\n        super(\"Detect common errors in the filters\", [], \"ValidateFilter\")\n    }\n\n    convert(filter: FilterConfigJson, context: ConversionContext): FilterConfigJson {\n        if (typeof filter === \"string\") {\n            // Calling another filter, we skip\n            return filter\n        }\n        for (const option of filter.options) {\n            for (let i = 0; i < option.fields?.length ?? 0; i++) {\n                const field = option.fields[i]\n                const type = field.type ?? \"string\"\n                if (Validators.availableTypes.find((t) => t === type) === undefined) {\n                    context\n                        .enters(\"fields\", i)\n                        .err(\n                            `Invalid filter: ${type} is not a valid textfield type.\\n\\tTry one of ${Array.from(\n                                Validators.availableTypes\n                            ).join(\",\")}`\n                        )\n                }\n            }\n        }\n        return filter\n    }\n}\n\nexport class DetectDuplicateFilters extends DesugaringStep<{\n    layers: LayerConfigJson[]\n    themes: LayoutConfigJson[]\n}> {\n    constructor() {\n        super(\n            \"Tries to detect layers where a shared filter can be used (or where similar filters occur)\",\n            [],\n            \"DetectDuplicateFilters\"\n        )\n    }\n\n    convert(\n        json: { layers: LayerConfigJson[]; themes: LayoutConfigJson[] },\n        context: ConversionContext\n    ): { layers: LayerConfigJson[]; themes: LayoutConfigJson[] } {\n        const { layers, themes } = json\n        const perOsmTag = new Map<\n            string,\n            {\n                layer: LayerConfigJson\n                layout: LayoutConfigJson | undefined\n                filter: FilterConfigJson\n            }[]\n        >()\n\n        for (const layer of layers) {\n            this.addLayerFilters(layer, perOsmTag)\n        }\n\n        for (const theme of themes) {\n            if (theme.id === \"personal\") {\n                continue\n            }\n            for (const layer of theme.layers) {\n                if (typeof layer === \"string\") {\n                    continue\n                }\n                if (layer[\"builtin\"] !== undefined) {\n                    continue\n                }\n                this.addLayerFilters(<LayerConfigJson>layer, perOsmTag, theme)\n            }\n        }\n\n        // At this point, we have gathered all filters per tag - time to find duplicates\n        perOsmTag.forEach((value, key) => {\n            if (value.length <= 1) {\n                // Seen this key just once, it is unique\n                return\n            }\n            let msg = \"Possible duplicate filter: \" + key\n            for (const { filter, layer, layout } of value) {\n                let id = \"\"\n                if (layout !== undefined) {\n                    id = layout.id + \":\"\n                }\n                msg += `\\n      - ${id}${layer.id}.${filter.id}`\n            }\n            context.warn(msg)\n        })\n\n        return json\n    }\n\n    /**\n     * Add all filter options into 'perOsmTag'\n     */\n    private addLayerFilters(\n        layer: LayerConfigJson,\n        perOsmTag: Map<\n            string,\n            {\n                layer: LayerConfigJson\n                layout: LayoutConfigJson | undefined\n                filter: FilterConfigJson\n            }[]\n        >,\n        layout?: LayoutConfigJson | undefined\n    ): void {\n        if (layer.filter === undefined || layer.filter === null) {\n            return\n        }\n        if (layer.filter[\"sameAs\"] !== undefined) {\n            return\n        }\n        for (const filter of <(string | FilterConfigJson)[]>layer.filter) {\n            if (typeof filter === \"string\") {\n                continue\n            }\n\n            if (filter[\"#\"]?.indexOf(\"ignore-possible-duplicate\") >= 0) {\n                continue\n            }\n\n            for (const option of filter.options) {\n                if (option.osmTags === undefined) {\n                    continue\n                }\n                const key = JSON.stringify(option.osmTags)\n                if (!perOsmTag.has(key)) {\n                    perOsmTag.set(key, [])\n                }\n                perOsmTag.get(key).push({\n                    layer,\n                    filter,\n                    layout,\n                })\n            }\n        }\n    }\n}\n\nexport class DetectDuplicatePresets extends DesugaringStep<LayoutConfig> {\n    constructor() {\n        super(\n            \"Detects mappings which have identical (english) names or identical mappings.\",\n            [\"presets\"],\n            \"DetectDuplicatePresets\"\n        )\n    }\n\n    convert(json: LayoutConfig, context: ConversionContext): LayoutConfig {\n        const presets: PresetConfig[] = [].concat(...json.layers.map((l) => l.presets))\n\n        const enNames = presets.map((p) => p.title.textFor(\"en\"))\n        if (new Set(enNames).size != enNames.length) {\n            const dups = Utils.Duplicates(enNames)\n            const layersWithDup = json.layers.filter((l) =>\n                l.presets.some((p) => dups.indexOf(p.title.textFor(\"en\")) >= 0)\n            )\n            const layerIds = layersWithDup.map((l) => l.id)\n            context.err(\n                `This themes has multiple presets which are named:${dups}, namely layers ${layerIds.join(\n                    \", \"\n                )} this is confusing for contributors and is probably the result of reusing the same layer multiple times. Use \\`{\"override\": {\"=presets\": []}}\\` to remove some presets`\n            )\n        }\n\n        const optimizedTags = <TagsFilter[]>presets.map((p) => new And(p.tags).optimize())\n        for (let i = 0; i < presets.length; i++) {\n            const presetATags = optimizedTags[i]\n            const presetA = presets[i]\n            for (let j = i + 1; j < presets.length; j++) {\n                const presetBTags = optimizedTags[j]\n                const presetB = presets[j]\n                if (\n                    Utils.SameObject(presetATags, presetBTags) &&\n                    Utils.sameList(\n                        presetA.preciseInput.snapToLayers,\n                        presetB.preciseInput.snapToLayers\n                    )\n                ) {\n                    context.err(\n                        `This themes has multiple presets with the same tags: ${presetATags.asHumanString(\n                            false,\n                            false,\n                            {}\n                        )}, namely the preset '${presets[i].title.textFor(\"en\")}' and '${presets[\n                            j\n                        ].title.textFor(\"en\")}'`\n                    )\n                }\n            }\n        }\n\n        return json\n    }\n}\n","import { Conversion } from \"./Conversion\"\nimport LayerConfig from \"../LayerConfig\"\nimport { LayerConfigJson } from \"../Json/LayerConfigJson\"\nimport Translations from \"../../../UI/i18n/Translations\"\nimport { Translation, TypedTranslation } from \"../../../UI/i18n/Translation\"\nimport { ConversionContext } from \"./ConversionContext\"\n\nexport default class CreateNoteImportLayer extends Conversion<LayerConfigJson, LayerConfigJson> {\n    /**\n     * A closed note is included if it is less then 'n'-days closed\n     * @private\n     */\n    private readonly _includeClosedNotesDays: number\n\n    constructor(includeClosedNotesDays = 0) {\n        super(\n            [\n                \"Advanced conversion which deducts a layer showing all notes that are 'importable' (i.e. a note that contains a link to some MapComplete theme, with hash '#import').\",\n                \"The import buttons and matches will be based on the presets of the given theme\",\n            ].join(\"\\n\\n\"),\n            [],\n            \"CreateNoteImportLayer\"\n        )\n        this._includeClosedNotesDays = includeClosedNotesDays\n    }\n\n    convert(layerJson: LayerConfigJson, context: ConversionContext): LayerConfigJson {\n        const t = Translations.t.importLayer\n\n        /**\n         * The note itself will contain `tags=k=v;k=v;k=v;...\n         * This must be matched with a regex.\n         * This is a simple JSON-object as how it'll be put into the layerConfigJson directly\n         */\n        const isShownIfAny: any[] = []\n        const layer = new LayerConfig(layerJson, \"while constructing a note-import layer\")\n        for (const preset of layer.presets) {\n            const mustMatchAll = []\n            for (const tag of preset.tags) {\n                const key = tag.key\n                const value = tag.value\n                const condition = \"_tags~(^|.*;)\" + key + \"=\" + value + \"($|;.*)\"\n                mustMatchAll.push(condition)\n            }\n            isShownIfAny.push({ and: mustMatchAll })\n        }\n\n        const title = layer.presets[0].title\n\n        const importButton = {}\n        {\n            const translations = trs(t.importButton, {\n                layerId: layer.id,\n                title: layer.presets[0].title,\n            })\n            for (const key in translations) {\n                if (key !== \"_context\") {\n                    importButton[key] = \"{\" + translations[key] + \"}\"\n                } else {\n                    importButton[key] = translations[key]\n                }\n            }\n        }\n\n        function embed(prefix, translation: Translation, postfix) {\n            const result = {}\n            for (const language in translation.translations) {\n                result[language] = prefix + translation.translations[language] + postfix\n            }\n            result[\"_context\"] = translation.context\n            return result\n        }\n\n        function tr(translation: Translation) {\n            return { ...translation.translations, _context: translation.context }\n        }\n\n        function trs<T>(translation: TypedTranslation<T>, subs: T): Record<string, string> {\n            return { ...translation.Subs(subs).translations, _context: translation.context }\n        }\n\n        return {\n            id: \"note_import_\" + layer.id,\n            // By disabling the name, the import-layers won't pollute the filter view \"name\": t.layerName.Subs({title: layer.title.render}).translations,\n            description: trs(t.description, { title: layer.title.render }),\n            source: {\n                osmTags: {\n                    and: [\"id~*\"],\n                },\n                geoJson:\n                    \"https://api.openstreetmap.org/api/0.6/notes.json?limit=10000&closed=\" +\n                    this._includeClosedNotesDays +\n                    \"&bbox={x_min},{y_min},{x_max},{y_max}\",\n                geoJsonZoomLevel: 10,\n                maxCacheAge: 0,\n            },\n            /* We need to set 'pass_all_features'\n       There are probably many note_import-layers, and we don't want the first one to gobble up all notes and then discard them...\n       */\n            passAllFeatures: true,\n            minzoom: Math.min(12, layerJson.minzoom - 2),\n            title: {\n                render: trs(t.popupTitle, { title }),\n            },\n            calculatedTags: [\n                \"_first_comment=get(feat)('comments')[0].text.toLowerCase()\",\n                \"_trigger_index=(() => {const lines = feat.properties['_first_comment'].split('\\\\n'); const matchesMapCompleteURL = lines.map(l => l.match(\\\".*https://mapcomplete.\\\\(org|osm.be\\\\)/\\\\([a-zA-Z_-]+\\\\)\\\\(.html\\\\)?.*#import\\\")); const matchedIndexes = matchesMapCompleteURL.map((doesMatch, i) => [doesMatch !== null, i]).filter(v => v[0]).map(v => v[1]); return matchedIndexes[0] })()\",\n                \"_comments_count=get(feat)('comments').length\",\n                \"_intro=(() => {const lines = get(feat)('comments')[0].text.split('\\\\n'); lines.splice(get(feat)('_trigger_index')-1, lines.length); return lines.filter(l => l !== '').join('<br/>');})()\",\n                \"_tags=(() => {let lines = get(feat)('comments')[0].text.split('\\\\n').map(l => l.trim()); lines.splice(0, get(feat)('_trigger_index') + 1); lines = lines.filter(l => l != ''); return lines.join(';');})()\",\n            ],\n            isShown: {\n                and: [\"_trigger_index~*\", { or: isShownIfAny }],\n            },\n            titleIcons: [\n                {\n                    render: \"<a href='https://openstreetmap.org/note/{id}' target='_blank'><img src='./assets/svg/osm-logo-us.svg'></a>\",\n                },\n            ],\n            tagRenderings: [\n                {\n                    id: \"Intro\",\n                    render: \"{_intro}\",\n                },\n                {\n                    id: \"conversation\",\n                    render: \"{visualize_note_comments(comments,1)}\",\n                    condition: \"_comments_count>1\",\n                },\n                {\n                    id: \"import\",\n                    render: importButton,\n                    condition: \"closed_at=\",\n                },\n                {\n                    id: \"close_note_\",\n                    render: embed(\n                        \"{close_note(\",\n                        t.notFound.Subs({ title }),\n                        \", ./assets/svg/close.svg, id, This feature does not exist, 18)}\"\n                    ),\n                    condition: \"closed_at=\",\n                },\n                {\n                    id: \"close_note_mapped\",\n                    render: embed(\n                        \"{close_note(\",\n                        t.alreadyMapped.Subs({ title }),\n                        \", ./assets/svg/duplicate.svg, id, Already mapped, 18)}\"\n                    ),\n                    condition: \"closed_at=\",\n                },\n                {\n                    id: \"handled\",\n                    render: tr(t.importHandled),\n                    condition: \"closed_at~*\",\n                },\n                {\n                    id: \"comment\",\n                    render: \"{add_note_comment()}\",\n                },\n                {\n                    id: \"add_image\",\n                    render: \"{add_image_to_note()}\",\n                },\n                {\n                    id: \"nearby_images\",\n                    render: tr(t.nearbyImagesIntro),\n                },\n                {\n                    id: \"all_tags\",\n                    render: \"{all_tags()}\",\n                    metacondition: {\n                        or: [\n                            \"__featureSwitchIsDebugging=true\",\n                            \"mapcomplete-show_tags=full\",\n                            \"mapcomplete-show_debug=yes\",\n                        ],\n                    },\n                },\n            ],\n            pointRendering: [\n                {\n                    location: [\"point\"],\n                    marker: [\n                        {\n                            icon: \"circle\",\n                            color: \"#fff\",\n                        },\n                        {\n                            icon: {\n                                render: \"help\",\n                                mappings: [\n                                    {\n                                        if: { or: [\"closed_at~*\", \"_imported=yes\"] },\n                                        then: \"checkmark\",\n                                    },\n                                ],\n                            },\n                            color: \"#00\",\n                        },\n                    ],\n                    iconSize: \"40,40\",\n                    anchor: \"center\",\n                },\n            ],\n        }\n    }\n}\n","import TagRenderingConfig from \"./TagRenderingConfig\"\nimport { ExtraFuncParams, ExtraFunctions } from \"../../Logic/ExtraFunctions\"\nimport LayerConfig from \"./LayerConfig\"\nimport { SpecialVisualization } from \"../../UI/SpecialVisualization\"\nimport SpecialVisualizations from \"../../UI/SpecialVisualizations\"\nimport { Exception } from \"sass\"\n\nexport default class DependencyCalculator {\n    public static GetTagRenderingDependencies(tr: TagRenderingConfig): string[] {\n        if (tr === undefined) {\n            throw \"Got undefined tag rendering in getTagRenderingDependencies\"\n        }\n        const deps: string[] = []\n\n        // All translated snippets\n        const parts: string[] = [].concat(...tr.EnumerateTranslations().map((tr) => tr.AllValues()))\n\n        for (const part of parts) {\n            const specialVizs: { func: SpecialVisualization; args: string[] }[] =\n                SpecialVisualizations.constructSpecification(part)\n                    .filter((p) => typeof p !== \"string\")\n                    .map((p) => <{ func: SpecialVisualization; args: string[] }>p)\n                    .filter((o) => o?.func?.getLayerDependencies !== undefined)\n            for (const specialViz of specialVizs) {\n                deps.push(...specialViz.func.getLayerDependencies(specialViz.args))\n            }\n        }\n        return deps\n    }\n\n    /**\n     * Returns a set of all other layer-ids that this layer needs to function.\n     * E.g. if this layers does snap to another layer in the preset, this other layer id will be mentioned\n     */\n    public static getLayerDependencies(\n        layer: LayerConfig\n    ): { neededLayer: string; reason: string; context?: string; neededBy: string }[] {\n        const deps: { neededLayer: string; reason: string; context?: string; neededBy: string }[] =\n            []\n\n        for (let i = 0; layer.presets !== undefined && i < layer.presets.length; i++) {\n            const preset = layer.presets[i]\n            const snapTo = preset.preciseInput?.snapToLayers\n            if (snapTo && !Array.isArray(snapTo)) {\n                throw new Error(\n                    `snapToLayers is not an array; it is ${snapTo}(used in preset ${i} for: ${layer.id})`\n                )\n            }\n            preset.preciseInput?.snapToLayers?.forEach((id) => {\n                deps.push({\n                    neededLayer: id,\n                    reason: \"a preset snaps to this layer\",\n                    context: \"presets[\" + i + \"]\",\n                    neededBy: layer.id,\n                })\n            })\n        }\n\n        for (const tr of layer.AllTagRenderings()) {\n            for (const dep of DependencyCalculator.GetTagRenderingDependencies(tr)) {\n                deps.push({\n                    neededLayer: dep,\n                    reason: \"a tagrendering needs this layer\",\n                    context: tr.id,\n                    neededBy: layer.id,\n                })\n            }\n        }\n\n        if (layer.calculatedTags?.length > 0) {\n            const obj = {\n                type: \"Feature\",\n                geometry: {\n                    type: \"Point\",\n                    coordinates: [0, 0],\n                },\n                properties: {\n                    id: \"node/1\",\n                },\n            }\n            let currentKey = undefined\n            let currentLine = undefined\n            const params: ExtraFuncParams = {\n                getFeatureById: (_) => undefined,\n                getFeaturesWithin: (layerId, _) => {\n                    if (layerId === \"*\") {\n                        // This is a wildcard\n                        return []\n                    }\n\n                    // The important line: steal the dependencies!\n                    deps.push({\n                        neededLayer: layerId,\n                        reason: \"a calculated tag loads features from this layer\",\n                        context:\n                            \"calculatedTag[\" +\n                            currentLine +\n                            \"] which calculates the value for \" +\n                            currentKey,\n                        neededBy: layer.id,\n                    })\n\n                    return []\n                },\n            }\n            const helpers = ExtraFunctions.constructHelpers(params)\n            // ... Run the calculated tag code, which will trigger the getFeaturesWithin above...\n            for (let i = 0; i < layer.calculatedTags.length; i++) {\n                const [key, code] = layer.calculatedTags[i]\n                currentLine = i // Leak the state...\n                currentKey = key\n                try {\n                    const func = new Function(\n                        \"feat\",\n                        \"{\" + ExtraFunctions.types.join(\",\") + \"}\",\n                        \"return \" + code + \";\"\n                    )\n                    const result = func(obj, helpers)\n                    obj.properties[key] = JSON.stringify(result)\n                } catch (e) {}\n            }\n        }\n\n        return deps\n    }\n}\n","import {\n    Concat,\n    Conversion,\n    DesugaringContext,\n    DesugaringStep,\n    Each,\n    Fuse,\n    On,\n    Pass,\n    SetDefault,\n} from \"./Conversion\"\nimport { LayoutConfigJson } from \"../Json/LayoutConfigJson\"\nimport { PrepareLayer } from \"./PrepareLayer\"\nimport { LayerConfigJson } from \"../Json/LayerConfigJson\"\nimport { Utils } from \"../../../Utils\"\nimport Constants from \"../../Constants\"\nimport CreateNoteImportLayer from \"./CreateNoteImportLayer\"\nimport LayerConfig from \"../LayerConfig\"\nimport { TagRenderingConfigJson } from \"../Json/TagRenderingConfigJson\"\nimport DependencyCalculator from \"../DependencyCalculator\"\nimport { AddContextToTranslations } from \"./AddContextToTranslations\"\nimport ValidationUtils from \"./ValidationUtils\"\nimport { ConversionContext } from \"./ConversionContext\"\n\nclass SubstituteLayer extends Conversion<string | LayerConfigJson, LayerConfigJson[]> {\n    private readonly _state: DesugaringContext\n\n    constructor(state: DesugaringContext) {\n        super(\n            \"Converts the identifier of a builtin layer into the actual layer, or converts a 'builtin' syntax with override in the fully expanded form\",\n            [],\n            \"SubstituteLayer\"\n        )\n        this._state = state\n    }\n\n    convert(json: string | LayerConfigJson, context: ConversionContext): LayerConfigJson[] {\n        const state = this._state\n\n        function reportNotFound(name: string) {\n            const knownLayers = Array.from(state.sharedLayers.keys())\n            const withDistance = knownLayers.map((lname) => [\n                lname,\n                Utils.levenshteinDistance(name, lname),\n            ])\n            withDistance.sort((a, b) => a[1] - b[1])\n            const ids = withDistance.map((n) => n[0])\n            // Known builtin layers are \"+.join(\",\")+\"\\n    For more information, see \"\n            context.err(`The layer with name ${name} was not found as a builtin layer. Perhaps you meant ${ids[0]}, ${ids[1]} or ${ids[2]}?\n For an overview of all available layers, refer to https://github.com/pietervdvn/MapComplete/blob/develop/Docs/BuiltinLayers.md`)\n        }\n\n        if (typeof json === \"string\") {\n            const found = state.sharedLayers.get(json)\n            if (found === undefined) {\n                reportNotFound(json)\n                return null\n            }\n            return [found]\n        }\n\n        if (json[\"builtin\"] === undefined) {\n            return [json]\n        }\n\n        let names = json[\"builtin\"]\n        if (typeof names === \"string\") {\n            names = [names]\n        }\n        const layers = []\n\n        for (const name of names) {\n            const found = Utils.Clone(state.sharedLayers.get(name))\n            if (found === undefined) {\n                reportNotFound(name)\n                continue\n            }\n            if (\n                json[\"override\"][\"tagRenderings\"] !== undefined &&\n                (found[\"tagRenderings\"] ?? []).length > 0\n            ) {\n                context.err(\n                    `When overriding a layer, an override is not allowed to override into tagRenderings. Use \"+tagRenderings\" or \"tagRenderings+\" instead to prepend or append some questions.`\n                )\n            }\n            try {\n                Utils.Merge(json[\"override\"], found)\n                layers.push(found)\n            } catch (e) {\n                context.err(\n                    `Could not apply an override due to: ${e}.\\nThe override is: ${JSON.stringify(\n                        json[\"override\"]\n                    )}`\n                )\n            }\n\n            if (json[\"hideTagRenderingsWithLabels\"]) {\n                const hideLabels: Set<string> = new Set(json[\"hideTagRenderingsWithLabels\"])\n                // These labels caused at least one deletion\n                const usedLabels: Set<string> = new Set<string>()\n                const filtered = []\n                for (const tr of found.tagRenderings) {\n                    const labels = tr[\"labels\"]\n                    if (labels !== undefined) {\n                        const forbiddenLabel = labels.findIndex((l) => hideLabels.has(l))\n                        if (forbiddenLabel >= 0) {\n                            usedLabels.add(labels[forbiddenLabel])\n                            context.info(\n                                \"Dropping tagRendering \" +\n                                    tr[\"id\"] +\n                                    \" as it has a forbidden label: \" +\n                                    labels[forbiddenLabel]\n                            )\n                            continue\n                        }\n                    }\n\n                    if (hideLabels.has(tr[\"id\"])) {\n                        usedLabels.add(tr[\"id\"])\n                        context.info(\n                            \"Dropping tagRendering \" + tr[\"id\"] + \" as its id is a forbidden label\"\n                        )\n                        continue\n                    }\n\n                    if (hideLabels.has(tr[\"group\"])) {\n                        usedLabels.add(tr[\"group\"])\n                        context.info(\n                            \"Dropping tagRendering \" +\n                                tr[\"id\"] +\n                                \" as its group `\" +\n                                tr[\"group\"] +\n                                \"` is a forbidden label\"\n                        )\n                        continue\n                    }\n\n                    filtered.push(tr)\n                }\n                const unused = Array.from(hideLabels).filter((l) => !usedLabels.has(l))\n                if (unused.length > 0) {\n                    context.err(\n                        \"This theme specifies that certain tagrenderings have to be removed based on forbidden layers. One or more of these layers did not match any tagRenderings and caused no deletions: \" +\n                            unused.join(\", \") +\n                            \"\\n   This means that this label can be removed or that the original tagRendering that should be deleted does not have this label anymore\"\n                    )\n                }\n                found.tagRenderings = filtered\n            }\n        }\n        return layers\n    }\n}\n\nclass AddDefaultLayers extends DesugaringStep<LayoutConfigJson> {\n    private readonly _state: DesugaringContext\n\n    constructor(state: DesugaringContext) {\n        super(\n            \"Adds the default layers, namely: \" + Constants.added_by_default.join(\", \"),\n            [\"layers\"],\n            \"AddDefaultLayers\"\n        )\n        this._state = state\n    }\n\n    convert(json: LayoutConfigJson, context: ConversionContext): LayoutConfigJson {\n        const state = this._state\n        json.layers = [...(json.layers ?? [])]\n        const alreadyLoaded = new Set(json.layers.map((l) => l[\"id\"]))\n\n        for (const layerName of Constants.added_by_default) {\n            const v = state.sharedLayers.get(layerName)\n            if (v === undefined) {\n                context.err(\n                    \"Default layer \" +\n                        layerName +\n                        \" not found. \" +\n                        state.sharedLayers.size +\n                        \" layers are available\"\n                )\n                continue\n            }\n            if (alreadyLoaded.has(v.id)) {\n                context.warn(\n                    \"Layout \" +\n                        context +\n                        \" already has a layer with name \" +\n                        v.id +\n                        \"; skipping inclusion of this builtin layer\"\n                )\n                continue\n            }\n            json.layers.push(v)\n        }\n\n        return json\n    }\n}\n\nclass AddImportLayers extends DesugaringStep<LayoutConfigJson> {\n    constructor() {\n        super(\n            \"For every layer in the 'layers'-list, create a new layer which'll import notes. (Note that priviliged layers and layers which have a geojson-source set are ignored)\",\n            [\"layers\"],\n            \"AddImportLayers\"\n        )\n    }\n\n    convert(json: LayoutConfigJson, context: ConversionContext): LayoutConfigJson {\n        if (!(json.enableNoteImports ?? true)) {\n            context.info(\n                \"Not creating a note import layers for theme \" + json.id + \" as they are disabled\"\n            )\n            return json\n        }\n\n        json = { ...json }\n        const allLayers: LayerConfigJson[] = <LayerConfigJson[]>json.layers\n        json.layers = [...json.layers]\n\n        const creator = new CreateNoteImportLayer()\n        for (let i1 = 0; i1 < allLayers.length; i1++) {\n            const layer = allLayers[i1]\n            if (layer.source === undefined) {\n                // Priviliged layers are skipped\n                continue\n            }\n\n            if (layer.source[\"geoJson\"] !== undefined) {\n                // Layer which don't get their data from OSM are skipped\n                continue\n            }\n\n            if (layer.title === undefined || layer.name === undefined) {\n                // Anonymous layers and layers without popup are skipped\n                continue\n            }\n\n            if (layer.presets === undefined || layer.presets.length == 0) {\n                // A preset is needed to be able to generate a new point\n                continue\n            }\n\n            try {\n                const importLayerResult = creator.convert(\n                    layer,\n                    context.inOperation(this.name).enter(i1)\n                )\n                if (importLayerResult !== undefined) {\n                    json.layers.push(importLayerResult)\n                }\n            } catch (e) {\n                context.err(\"Could not generate an import-layer for \" + layer.id + \" due to \" + e)\n            }\n        }\n\n        return json\n    }\n}\n\nclass AddContextToTranslationsInLayout extends DesugaringStep<LayoutConfigJson> {\n    constructor() {\n        super(\n            \"Adds context to translations, including the prefix 'themes:json.id'; this is to make sure terms in an 'overrides' or inline layer are linkable too\",\n            [\"_context\"],\n            \"AddContextToTranlationsInLayout\"\n        )\n    }\n\n    convert(json: LayoutConfigJson, context: ConversionContext): LayoutConfigJson {\n        const conversion = new AddContextToTranslations<LayoutConfigJson>(\"themes:\")\n        return conversion.convert(json, context)\n    }\n}\n\nclass ApplyOverrideAll extends DesugaringStep<LayoutConfigJson> {\n    constructor() {\n        super(\n            \"Applies 'overrideAll' onto every 'layer'. The 'overrideAll'-field is removed afterwards\",\n            [\"overrideAll\", \"layers\"],\n            \"ApplyOverrideAll\"\n        )\n    }\n\n    convert(json: LayoutConfigJson, context: ConversionContext): LayoutConfigJson {\n        const overrideAll = json.overrideAll\n        if (overrideAll === undefined) {\n            return json\n        }\n\n        json = { ...json }\n\n        delete json.overrideAll\n        const newLayers = []\n        for (let layer of json.layers) {\n            layer = Utils.Clone(<LayerConfigJson>layer)\n            Utils.Merge(overrideAll, layer)\n            newLayers.push(layer)\n        }\n        json.layers = newLayers\n        return json\n    }\n}\n\nclass AddDependencyLayersToTheme extends DesugaringStep<LayoutConfigJson> {\n    private readonly _state: DesugaringContext\n\n    constructor(state: DesugaringContext) {\n        super(\n            `If a layer has a dependency on another layer, these layers are added automatically on the theme. (For example: defibrillator depends on 'walls_and_buildings' to snap onto. This layer is added automatically)\n\n            Note that these layers are added _at the start_ of the layer list, meaning that they will see _every_ feature.\n            Furthermore, \\`passAllFeatures\\` will be set, so that they won't steal away features from further layers.\n            Some layers (e.g. \\`all_buildings_and_walls\\' or \\'streets_with_a_name\\') are invisible, so by default, \\'force_load\\' is set too.\n            `,\n            [\"layers\"],\n            \"AddDependencyLayersToTheme\"\n        )\n        this._state = state\n    }\n\n    private static CalculateDependencies(\n        alreadyLoaded: LayerConfigJson[],\n        allKnownLayers: Map<string, LayerConfigJson>,\n        themeId: string\n    ): { config: LayerConfigJson; reason: string }[] {\n        const dependenciesToAdd: { config: LayerConfigJson; reason: string }[] = []\n        const loadedLayerIds: Set<string> = new Set<string>(alreadyLoaded.map((l) => l.id))\n\n        // Verify cross-dependencies\n        let unmetDependencies: {\n            neededLayer: string\n            neededBy: string\n            reason: string\n            context?: string\n        }[] = []\n        do {\n            const dependencies: {\n                neededLayer: string\n                reason: string\n                context?: string\n                neededBy: string\n            }[] = []\n\n            for (const layerConfig of alreadyLoaded) {\n                try {\n                    const layerDeps = DependencyCalculator.getLayerDependencies(\n                        new LayerConfig(layerConfig, themeId + \"(dependencies)\")\n                    )\n                    dependencies.push(...layerDeps)\n                } catch (e) {\n                    console.error(e)\n                    throw (\n                        \"Detecting layer dependencies for \" + layerConfig.id + \" failed due to \" + e\n                    )\n                }\n            }\n\n            for (const dependency of dependencies) {\n                if (loadedLayerIds.has(dependency.neededLayer)) {\n                    // We mark the needed layer as 'mustLoad'\n                    alreadyLoaded.find((l) => l.id === dependency.neededLayer).forceLoad = true\n                }\n            }\n\n            // During the generate script, builtin layers are verified but not loaded - so we have to add them manually here\n            // Their existence is checked elsewhere, so this is fine\n            unmetDependencies = dependencies.filter((dep) => !loadedLayerIds.has(dep.neededLayer))\n            for (const unmetDependency of unmetDependencies) {\n                if (loadedLayerIds.has(unmetDependency.neededLayer)) {\n                    continue\n                }\n                const dep = Utils.Clone(allKnownLayers.get(unmetDependency.neededLayer))\n                const reason =\n                    \"This layer is needed by \" +\n                    unmetDependency.neededBy +\n                    \" because \" +\n                    unmetDependency.reason +\n                    \" (at \" +\n                    unmetDependency.context +\n                    \")\"\n                if (dep === undefined) {\n                    const message = [\n                        \"Loading a dependency failed: layer \" +\n                            unmetDependency.neededLayer +\n                            \" is not found, neither as layer of \" +\n                            themeId +\n                            \" nor as builtin layer.\",\n                        reason,\n                        \"Loaded layers are: \" + alreadyLoaded.map((l) => l.id).join(\",\"),\n                    ]\n                    throw message.join(\"\\n\\t\")\n                }\n\n                dep.forceLoad = true\n                dep.passAllFeatures = true\n                dep.description = reason\n                dependenciesToAdd.unshift({\n                    config: dep,\n                    reason,\n                })\n                loadedLayerIds.add(dep.id)\n                unmetDependencies = unmetDependencies.filter(\n                    (d) => d.neededLayer !== unmetDependency.neededLayer\n                )\n            }\n        } while (unmetDependencies.length > 0)\n\n        return dependenciesToAdd\n    }\n\n    convert(theme: LayoutConfigJson, context: ConversionContext): LayoutConfigJson {\n        const state = this._state\n        const allKnownLayers: Map<string, LayerConfigJson> = state.sharedLayers\n        const knownTagRenderings: Map<string, TagRenderingConfigJson> = state.tagRenderings\n        const layers: LayerConfigJson[] = <LayerConfigJson[]>theme.layers // Layers should be expanded at this point\n\n        knownTagRenderings.forEach((value, key) => {\n            value[\"id\"] = key\n        })\n\n        const dependencies = AddDependencyLayersToTheme.CalculateDependencies(\n            layers,\n            allKnownLayers,\n            theme.id\n        )\n        for (const dependency of dependencies) {\n        }\n        if (dependencies.length > 0) {\n            for (const dependency of dependencies) {\n                context.info(\n                    \"Added \" + dependency.config.id + \" to the theme. \" + dependency.reason\n                )\n            }\n        }\n        layers.unshift(...dependencies.map((l) => l.config))\n\n        return {\n            ...theme,\n            layers: layers,\n        }\n    }\n}\n\nclass PreparePersonalTheme extends DesugaringStep<LayoutConfigJson> {\n    private readonly _state: DesugaringContext\n\n    constructor(state: DesugaringContext) {\n        super(\"Adds every public layer to the personal theme\", [\"layers\"], \"PreparePersonalTheme\")\n        this._state = state\n    }\n\n    convert(json: LayoutConfigJson, context: ConversionContext): LayoutConfigJson {\n        if (json.id !== \"personal\") {\n            return json\n        }\n\n        // The only thing this _really_ does, is adding the layer-ids into 'layers'\n        // All other preparations are done by the 'override-all'-block in personal.json\n\n        json.layers = Array.from(this._state.sharedLayers.keys())\n            .filter((l) => this._state.sharedLayers.get(l).source !== null)\n            .filter((l) => this._state.publicLayers.has(l))\n        context.info(\"The personal theme has \" + json.layers.length + \" public layers\")\n        return json\n    }\n}\n\nclass WarnForUnsubstitutedLayersInTheme extends DesugaringStep<LayoutConfigJson> {\n    constructor() {\n        super(\n            \"Generates a warning if a theme uses an unsubstituted layer\",\n            [\"layers\"],\n            \"WarnForUnsubstitutedLayersInTheme\"\n        )\n    }\n\n    convert(json: LayoutConfigJson, context: ConversionContext): LayoutConfigJson {\n        if (json.hideFromOverview === true) {\n            return json\n        }\n        if ((json.layers ?? []).length === 0) {\n            context\n                .enter(\"layers\")\n                .err(\n                    \"No layers are defined. You must define at least one layer to have a valid theme\"\n                )\n            return json\n        }\n        if (!Array.isArray(json.layers)) {\n            context\n                .enter(\"layers\")\n                .err(\"Can not iterate over layers in theme, it is a \" + JSON.stringify(json.layers))\n            return json\n        }\n        for (const layer of json.layers) {\n            if (typeof layer === \"string\") {\n                continue\n            }\n            if (layer[\"builtin\"] !== undefined) {\n                continue\n            }\n            if (layer[\"source\"][\"geojson\"] !== undefined) {\n                // We turn a blind eye for import layers\n                continue\n            }\n\n            context.warn(\n                \"The theme \" +\n                    json.id +\n                    \" has an inline layer: \" +\n                    layer[\"id\"] +\n                    \". This is discouraged.\"\n            )\n        }\n        return json\n    }\n}\n\nexport class PrepareTheme extends Fuse<LayoutConfigJson> {\n    private state: DesugaringContext\n    constructor(\n        state: DesugaringContext,\n        options?: {\n            skipDefaultLayers: false | boolean\n        }\n    ) {\n        super(\n            \"Fully prepares and expands a theme\",\n\n            new AddContextToTranslationsInLayout(),\n            new PreparePersonalTheme(state),\n            new WarnForUnsubstitutedLayersInTheme(),\n            new On(\"layers\", new Concat(new SubstituteLayer(state))),\n            new SetDefault(\"socialImage\", \"assets/SocialImage.png\", true),\n            // We expand all tagrenderings first...\n            new On(\"layers\", new Each(new PrepareLayer(state))),\n            // Then we apply the override all\n            new ApplyOverrideAll(),\n            // And then we prepare all the layers _again_ in case that an override all contained unexpanded tagrenderings!\n            new On(\"layers\", new Each(new PrepareLayer(state))),\n            options?.skipDefaultLayers\n                ? new Pass(\"AddDefaultLayers is disabled due to the set flag\")\n                : new AddDefaultLayers(state),\n            new AddDependencyLayersToTheme(state),\n            new AddImportLayers()\n        )\n        this.state = state\n    }\n\n    convert(json: LayoutConfigJson, context: ConversionContext): LayoutConfigJson {\n        const result = super.convert(json, context)\n        if ((this.state.publicLayers?.size ?? 0) === 0) {\n            // THis is a bootstrapping run, no need to already set this flag\n            return result\n        }\n\n        const needsNodeDatabase = result.layers?.some((l: LayerConfigJson) =>\n            l.tagRenderings?.some((tr) =>\n                ValidationUtils.getSpecialVisualisations(<any>tr)?.some(\n                    (special) => special.needsNodeDatabase\n                )\n            )\n        )\n        if (needsNodeDatabase) {\n            context.info(\n                \"Setting 'enableNodeDatabase' as this theme uses a special visualisation which needs to keep track of _all_ nodes\"\n            )\n            result.enableNodeDatabase = true\n        }\n\n        return result\n    }\n}\n","import known_themes from \"../assets/generated/known_themes.json\"\nimport LayoutConfig from \"../Models/ThemeConfig/LayoutConfig\"\nimport { LayoutConfigJson } from \"../Models/ThemeConfig/Json/LayoutConfigJson\"\n\n/**\n * Somewhat of a dictionary, which lazily parses needed themes\n */\nexport class AllKnownLayoutsLazy {\n    private readonly dict: Map<string, { data: LayoutConfig } | { func: () => LayoutConfig }> =\n        new Map()\n    constructor() {\n        for (const layoutConfigJson of known_themes[\"themes\"]) {\n            this.dict.set(layoutConfigJson.id, {\n                func: () => {\n                    const layout = new LayoutConfig(<LayoutConfigJson>layoutConfigJson, true)\n                    for (let i = 0; i < layout.layers.length; i++) {\n                        let layer = layout.layers[i]\n                        if (typeof layer === \"string\") {\n                            throw \"Layer \" + layer + \" was not expanded in \" + layout.id\n                        }\n                    }\n                    return layout\n                },\n            })\n        }\n    }\n\n    public get(key: string): LayoutConfig {\n        const thunk = this.dict.get(key)\n        if (thunk === undefined) {\n            return undefined\n        }\n        if (thunk[\"data\"]) {\n            return thunk[\"data\"]\n        }\n        const layout = thunk[\"func\"]()\n        this.dict.set(key, { data: layout })\n        return layout\n    }\n\n    public keys() {\n        return this.dict.keys()\n    }\n\n    public values() {\n        return Array.from(this.keys()).map((k) => this.get(k))\n    }\n}\n\nexport class AllKnownLayouts {\n    public static allKnownLayouts: AllKnownLayoutsLazy = new AllKnownLayoutsLazy()\n}\n"],"names":["AddContextToTranslations","DesugaringStep","prefix","__publicField","json","context","Utils","leaf","path","breadcrumb","i","pointer","obj","Translations","ValidationUtils","renderingConfigs","visualisations","renderConfig","renderingConfig","spec","cacheName","translations","m","all","translation","key","template","specials","SpecialVisualizations","p","_ExpandFilter","state","filters","filter","predifined_filters","newFilters","split","layer","expectedId","expandedFilter","f","found","suggestions","t","ExpandFilter","ExpandTagRendering","Conversion","self","options","trconfig","_a","label","withLabel","ctx","trs","result","tr","stable","name","direct","tagRenderingConfigJson","nm","indirect","n","foundTr","spl","_b","id","layerTrs","matchingTrs","id_","contextWriter","_c","ConversionContext","lookup","_d","names","candidates","layerName","_e","s","DetectInline","AddQuestionBox","questionSpecials","sp","noLabels","allLabels","seen","questionSpecial","used","a","blacklisted","_f","usedLabel","question","AddEditingElements","desugaring","specialVisualisations","usedSpecialFunctions","sv","trc","ExpandRewrite","keyToRewrite","target","targetIsTranslation","replaceRecursive","o","isTr","subtarget","rewrite","keysToRewrite","ts","guard","j","toRewrite","into","RewriteSpecial","input","special","type","vis","k","e","argNamesList","argNames","wrongArg","byDistance","x","arg","foundLanguages","translatedArgs","v","translatedArg","ln","before","after","args","languages","argName","Translation","txt","beforeText","afterText","paths","tagrenderingconfigmeta","travelled","ExpandIconBadges","badgesJson","iconBadges","iconBadge","expanded","resolved","PreparePointRendering","Fuse","On","Each","FirstOf","SetFullNodeDatabase","specs","ExpandMarkerRenderings","expander","PrepareLayer","Concat","SetDefault","ValidateLanguageCompleteness","neededLanguage","missing","DoesImageExist","knownImagePaths","checkExistsSync","ignore","image","Svg","ValidateTheme","doesImageExist","isBuiltin","sharedTagRenderings","ExtractImages","theme","LayoutConfig","images","remoteImages","img","remoteImage","filename","dups","targetLanguage","DetectDuplicatePresets","ValidateThemeAndLayers","Pipe","ValidateLayer","Pure","OverrideShadowingCheck","overrideAll","withOverride","l","w","MiscThemeChecks","PrevalidateTheme","DetectConflictingAddExtraTags","tagRendering","TagRenderingConfig","mapping","keysInMapping","duplicateKeys","DetectShadowedMappings","layerConfig","ct","defaultProperties","calculatedTagName","parsedConditions","c","ifTags","TagUtils","hideInAnswer","conditionTags","And","keyValues","properties","doesMatch","DetectMappingsWithImages","ignoreToken","ValidatePossibleLinks","str","parse_html","links","link","_CheckTranslation","allowUndefined","keys","msg","lng","CheckTranslation","MiscTagRenderingChecks","en","render","funcName","freeformType","Validators","ValidateTagRenderings","PrevalidateLayer","studioValidations","osmTags","LayerConfig","Constants","duplicates","DeleteConfig","forbiddenTopLevel","forbiddenKey","expected","emptyIndexes","duplicateIds","ValidateFilter","pointRendering","icon","indexM","baseTags","preset","tags","tag","skipDefaultLayers","_","code","__","option","presets","enNames","layerIds","optimizedTags","presetATags","presetA","presetBTags","presetB","CreateNoteImportLayer","includeClosedNotesDays","layerJson","isShownIfAny","mustMatchAll","value","condition","title","importButton","embed","postfix","language","subs","DependencyCalculator","deps","parts","part","specialVizs","specialViz","snapTo","dep","currentKey","currentLine","params","layerId","helpers","ExtraFunctions","SubstituteLayer","reportNotFound","withDistance","lname","b","ids","layers","hideLabels","usedLabels","filtered","labels","forbiddenLabel","unused","AddDefaultLayers","alreadyLoaded","AddImportLayers","allLayers","creator","i1","importLayerResult","AddContextToTranslationsInLayout","ApplyOverrideAll","newLayers","AddDependencyLayersToTheme","allKnownLayers","themeId","dependenciesToAdd","loadedLayerIds","unmetDependencies","dependencies","layerDeps","dependency","unmetDependency","reason","d","knownTagRenderings","PreparePersonalTheme","WarnForUnsubstitutedLayersInTheme","PrepareTheme","Pass","AllKnownLayoutsLazy","layoutConfigJson","known_themes","layout","thunk","AllKnownLayouts"],"mappings":"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"}