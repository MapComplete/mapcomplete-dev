{"version":3,"file":"questions-93e6fce2.js","sources":["../../src/Models/ThemeConfig/Conversion/AddContextToTranslations.ts","../../src/Models/ThemeConfig/Conversion/ValidationUtils.ts","../../src/Models/ThemeConfig/Conversion/ExpandRewrite.ts","../../src/Models/ThemeConfig/Conversion/PrepareLayer.ts","../../src/Models/ThemeConfig/Conversion/Validation.ts","../../src/Models/ThemeConfig/Conversion/CreateNoteImportLayer.ts","../../src/Models/ThemeConfig/DependencyCalculator.ts","../../src/Models/ThemeConfig/Conversion/PrepareTheme.ts"],"sourcesContent":["import { DesugaringStep } from \"./Conversion\"\nimport { Utils } from \"../../../Utils\"\nimport Translations from \"../../../UI/i18n/Translations\"\nimport { ConversionContext } from \"./ConversionContext\"\n\nexport class AddContextToTranslations<T> extends DesugaringStep<T> {\n    private readonly _prefix: string\n\n    constructor(prefix = \"\") {\n        super(\n            \"Adds a '_context' to every object that is probably a translation\",\n            [\"_context\"],\n            \"AddContextToTranslation\"\n        )\n        this._prefix = prefix\n    }\n\n    /**\n     * const theme = {\n     *   layers: [\n     *       {\n     *           builtin: [\"abc\"],\n     *           override: {\n     *               title:{\n     *                   en: \"Some title\"\n     *               }\n     *           }\n     *       }\n     *   ]\n     * }\n     * const rewritten = new AddContextToTranslations<any>(\"prefix:\").convertStrict(theme, ConversionContext.test())\n     * const expected = {\n     *   layers: [\n     *       {\n     *           builtin: [\"abc\"],\n     *           override: {\n     *               title:{\n     *                  _context: \"prefix:layers.0.override.title\"\n     *                   en: \"Some title\"\n     *               }\n     *           }\n     *       }\n     *   ]\n     * }\n     * rewritten // => expected\n     *\n     * // should use the ID if one is present instead of the index\n     * const theme = {\n     *   layers: [\n     *       {\n     *           tagRenderings:[\n     *               {id: \"some-tr\",\n     *               question:{\n     *                   en:\"Question?\"\n     *               }\n     *               }\n     *           ]\n     *       }\n     *   ]\n     * }\n     * const rewritten = new AddContextToTranslations<any>(\"prefix:\").convertStrict(theme, ConversionContext.test())\n     * const expected = {\n     *   layers: [\n     *       {\n     *           tagRenderings:[\n     *               {id: \"some-tr\",\n     *               question:{\n     *                  _context: \"prefix:layers.0.tagRenderings.some-tr.question\"\n     *                   en:\"Question?\"\n     *               }\n     *               }\n     *           ]\n     *       }\n     *   ]\n     * }\n     * rewritten // => expected\n     *\n     * // should preserve nulls\n     * const theme = {\n     *   layers: [\n     *       {\n     *           builtin: [\"abc\"],\n     *           override: {\n     *               name:null\n     *           }\n     *       }\n     *   ]\n     * }\n     * const rewritten = new AddContextToTranslations<any>(\"prefix:\").convertStrict(theme, ConversionContext.test())\n     * const expected = {\n     *   layers: [\n     *       {\n     *           builtin: [\"abc\"],\n     *           override: {\n     *               name: null\n     *           }\n     *       }\n     *   ]\n     * }\n     * rewritten // => expected\n     *\n     *\n     * // Should ignore all if '#dont-translate' is set\n     * const theme = {\n     *  \"#dont-translate\": \"*\",\n     *   layers: [\n     *       {\n     *           builtin: [\"abc\"],\n     *           override: {\n     *               title:{\n     *                   en: \"Some title\"\n     *               }\n     *           }\n     *       }\n     *   ]\n     * }\n     * const rewritten = new AddContextToTranslations<any>(\"prefix:\").convertStrict(theme, ConversionContext.test())\n     * rewritten // => theme\n     *\n     */\n    convert(json: T, context: ConversionContext): T {\n        if (json[\"#dont-translate\"] === \"*\") {\n            return json\n        }\n\n        return Utils.WalkJson(\n            json,\n            (leaf, path) => {\n                if (leaf === undefined || leaf === null) {\n                    return leaf\n                }\n                if (typeof leaf === \"object\") {\n                    // follow the path. If we encounter a number, check that there is no ID we can use instead\n                    let breadcrumb = json\n                    for (let i = 0; i < path.length; i++) {\n                        const pointer = path[i]\n                        breadcrumb = breadcrumb[pointer]\n                        if (pointer.match(\"[0-9]+\") && breadcrumb[\"id\"] !== undefined) {\n                            path[i] = breadcrumb[\"id\"]\n                        }\n                    }\n\n                    return {\n                        ...leaf,\n                        _context: this._prefix + context.path.concat(path).join(\".\"),\n                    }\n                } else {\n                    return leaf\n                }\n            },\n            (obj) => obj === undefined || obj === null || Translations.isProbablyATranslation(obj)\n        )\n    }\n}\n","import { TagRenderingConfigJson } from \"../Json/TagRenderingConfigJson\"\nimport { Utils } from \"../../../Utils\"\nimport SpecialVisualizations from \"../../../UI/SpecialVisualizations\"\nimport { RenderingSpecification, SpecialVisualization } from \"../../../UI/SpecialVisualization\"\nimport { QuestionableTagRenderingConfigJson } from \"../Json/QuestionableTagRenderingConfigJson\"\n\nexport default class ValidationUtils {\n    public static getAllSpecialVisualisations(\n        renderingConfigs: (TagRenderingConfigJson | QuestionableTagRenderingConfigJson)[]\n    ): RenderingSpecification[] {\n        const visualisations: RenderingSpecification[] = []\n        if (!Array.isArray(renderingConfigs)) {\n            throw (\n                \"Could not inspect renderingConfigs, not an array: \" +\n                JSON.stringify(renderingConfigs)\n            )\n        }\n        for (const renderConfig of renderingConfigs) {\n            visualisations.push(...ValidationUtils.getSpecialVisualisationsWithArgs(renderConfig))\n        }\n        return visualisations\n    }\n\n    /**\n     * Gives all the (function names of) used special visualisations\n     * @param renderingConfig\n     */\n    public static getSpecialVisualisations(\n        renderingConfig: TagRenderingConfigJson\n    ): SpecialVisualization[] {\n        return ValidationUtils.getSpecialVisualisationsWithArgs(renderingConfig).map(\n            (spec) => spec[\"func\"]\n        )\n    }\n\n    public static getSpecialVisualisationsWithArgs(\n        renderingConfig: TagRenderingConfigJson\n    ): RenderingSpecification[] {\n        if (!renderingConfig) {\n            return []\n        }\n        const cacheName = \"__specialVisualisationsWithArgs_cache\"\n        if (renderingConfig[cacheName]) {\n            return renderingConfig[cacheName]\n        }\n        if (!Array.isArray(renderingConfig.mappings ?? [])) {\n            throw (\n                \"Mappings of renderingconfig \" +\n                (renderingConfig[\"id\"] ?? renderingConfig.render ?? \"\") +\n                \" are supposed to be an array but it is: \" +\n                JSON.stringify(renderingConfig.mappings)\n            )\n        }\n        const translations: any[] = Utils.NoNull([\n            renderingConfig.render,\n            ...(renderingConfig.mappings ?? []).map((m) => m.then),\n        ])\n        const all: RenderingSpecification[] = []\n        for (let translation of translations) {\n            if (typeof translation == \"string\") {\n                translation = { \"*\": translation }\n            }\n\n            for (const key in translation) {\n                const template = translation[key]\n                const parts = SpecialVisualizations.constructSpecification(template)\n                const specials = parts.filter((p) => typeof p !== \"string\")\n                all.push(...specials)\n            }\n        }\n\n        // _Very_ dirty hack\n        Object.defineProperty(renderingConfig, cacheName, {\n            value: all,\n            enumerable: false,\n            configurable: true,\n            writable: true,\n        })\n\n        return all\n    }\n}\n","import { Conversion } from \"./Conversion\"\nimport RewritableConfigJson from \"../Json/RewritableConfigJson\"\nimport Translations from \"../../../UI/i18n/Translations\"\nimport { ConversionContext } from \"./ConversionContext\"\nimport { Utils } from \"../../../Utils\"\n\nexport class ExpandRewrite<T> extends Conversion<T | RewritableConfigJson<T>, T[]> {\n    constructor() {\n        super(\"Applies a rewrite\", [], \"ExpandRewrite\")\n    }\n\n    /**\n     * Used for left|right group creation and replacement.\n     * Every 'keyToRewrite' will be replaced with 'target' recursively. This substitution will happen in place in the object 'tr'\n     *\n     * The 'target' object will be cloned, the changes will be applied in this clone\n     *\n     * // should substitute strings\n     * const spec = {\n     *   \"someKey\": \"somevalue {xyz}\"\n     * }\n     * ExpandRewrite.RewriteParts(\"{xyz}\", \"rewritten\", spec) // => {\"someKey\": \"somevalue rewritten\"}\n     *\n     * // should substitute all occurances in strings\n     * const spec = {\n     *   \"someKey\": \"The left|right side has {key:left|right}\"\n     * }\n     * ExpandRewrite.RewriteParts(\"left|right\", \"left\", spec) // => {\"someKey\": \"The left side has {key:left}\"}\n     *\n     */\n    public static RewriteParts<T>(keyToRewrite: string, target: string | any, tr: T): T {\n        const targetIsTranslation = Translations.isProbablyATranslation(target)\n\n        function replaceRecursive(obj: string | any, target) {\n            if (obj === keyToRewrite) {\n                return target\n            }\n\n            if (typeof obj === \"string\") {\n                // This is a simple string - we do a simple replace\n                while (obj.indexOf(keyToRewrite) >= 0) {\n                    obj = obj.replace(keyToRewrite, target)\n                }\n                return obj\n            }\n            if (Array.isArray(obj)) {\n                // This is a list of items\n                return obj.map((o) => replaceRecursive(o, target))\n            }\n\n            if (typeof obj === \"object\") {\n                obj = { ...obj }\n\n                const isTr = targetIsTranslation && Translations.isProbablyATranslation(obj)\n\n                for (const key in obj) {\n                    let subtarget = target\n                    if (isTr) {\n                        // The target is a translation AND the current object is a translation\n                        // This means we should recursively replace with the translated value\n                        if (target[key]) {\n                            // A translation is available!\n                            subtarget = target[key]\n                        } else if (target[\"en\"]) {\n                            subtarget = target[\"en\"]\n                        } else {\n                            // Take the first\n                            subtarget = target[Object.keys(target)[0]]\n                        }\n                    }\n                    obj[key] = replaceRecursive(obj[key], subtarget)\n                }\n                return obj\n            }\n            return obj\n        }\n\n        return replaceRecursive(tr, target)\n    }\n\n    /**\n     * Used for check that a key is present in a string somewhere in the object\n     *\n     * // should substitute strings\n     * const spec = {\n     *   \"someKey\": \"somevalue {xyz}\"\n     * }\n     * ExpandRewrite.contains(\"{xyz}\", spec) // => true\n     * ExpandRewrite.contains(\"{abc}\", spec) // => false\n     *\n     */\n    public static contains<T>(keyToRewrite: string, tr: T): boolean {\n        function findRecursive(obj: string | any): boolean {\n            if (obj === keyToRewrite) {\n                return true\n            }\n\n            if (typeof obj === \"string\") {\n                // This is a simple string - we do a simple replace\n                return obj.indexOf(keyToRewrite) >= 0\n            }\n            if (Array.isArray(obj)) {\n                // This is a list of items\n                return obj.some((o) => findRecursive(o))\n            }\n\n            if (typeof obj === \"object\") {\n                obj = { ...obj }\n\n                for (const key in obj) {\n                    if (findRecursive(obj[key])) {\n                        return true\n                    }\n                }\n                return false\n            }\n            return false\n        }\n\n        return findRecursive(tr)\n    }\n\n    /**\n     * // should convert simple strings\n     * const spec = <RewritableConfigJson<string>>{\n     *     rewrite: {\n     *         sourceString: [\"xyz\",\"abc\"],\n     *         into: [\n     *             [\"X\", \"A\"],\n     *             [\"Y\", \"B\"],\n     *             [\"Z\", \"C\"]],\n     *     },\n     *     renderings: \"The value of xyz is abc\"\n     * }\n     * new ExpandRewrite().convertStrict(spec, ConversionContext.test()) // => [\"The value of X is A\", \"The value of Y is B\", \"The value of Z is C\"]\n     *\n     * // should rewrite with translations\n     * const spec = <RewritableConfigJson<any>>{\n     *     rewrite: {\n     *         sourceString: [\"xyz\",\"abc\"],\n     *         into: [\n     *             [\"X\", {en: \"value\", nl: \"waarde\"}],\n     *             [\"Y\", {en: \"some other value\", nl: \"een andere waarde\"}],\n     *     },\n     *     renderings: {en: \"The value of xyz is abc\", nl: \"De waarde van xyz is abc\"}\n     * }\n     * const expected = [\n     *  {\n     *      en: \"The value of X is value\",\n     *      nl: \"De waarde van X is waarde\"\n     *  },\n     *  {\n     *      en: \"The value of Y is some other value\",\n     *      nl: \"De waarde van Y is een andere waarde\"\n     *  }\n     * ]\n     * new ExpandRewrite().convertStrict(spec, ConversionContext.test()) // => expected\n     *\n     *\n     * // should expand sublists\n     * const spec = <RewritableConfigJson<any>>{\n     *     rewrite: {\n     *         sourceString: [\"{{key}}\",\"{{values}}\"],\n     *         into: [\n     *             [\"a\", [1,2,3] ],\n     *             [\"b\", [42, 43] ],\n     *     },\n     *     subexpand: {\"options\": [\"{{values}}\"]},\n     *     renderings: {question: \"What are values for {{key}}?\", options: [{if: \"x={{values}}\", then: \"{{values}} is value\" }] }\n     * }\n     * const expected = [\n     *  {question: \"What are values for a?\",\n     *  options: [{if: \"x=1\", then: \"1 is value\" },\n     *      {if: \"x=2\", then: \"2 is value\" },\n     *      {if: \"x=3\", then: \"3 is value\" }\n     *  ] }\n     *  {question: \"What are values for b?\", options: [\n     *  {if: \"x=42\", then: \"42 is value\" },\n     *  {if: \"x=43\", then: \"43 is value\" }\n     *  ] }\n     * ]\n     * new ExpandRewrite().convertStrict(spec, ConversionContext.test()) // => expected\n     *\n     *\n     * // should expand sublists if there is one\n     * const spec = <RewritableConfigJson<any>>{\n     *     rewrite: {\n     *         sourceString: [\"{{key}}\",\"{{values}}\"],\n     *         into: [\n     *             [\"a\", [] ],\n     *             [\"b\", [42, 43] ],\n     *             [\"c\", null ],\n     *     },\n     *     subexpand: {\"options\": [\"{{values}}\"]},\n     *     renderings: [\n     *      {question: \"What is {{key}}?\", options: [{if: \"x={{values}}\", then: \"{{values}} is value\" }],\n     *      {question: \"How is {{key}}?\", options: [{a: 5}, {b: 6}] },\n     *      {question: \"Why is {{key}}?\" }\n     *    ]\n     * }\n     * const expected = [\n     *  {question: \"What is a?\",\n     *  options: []},\n     *  {question: \"How is a?\", options: [{a: 5}, {b: 6}] },\n     *  {question: \"Why is a?\" },\n     *  {question: \"What is b?\", options: [\n     *  {if: \"x=42\", then: \"42 is value\" },\n     *  {if: \"x=43\", then: \"43 is value\" }\n     *  ] },\n     *  {question: \"How is b?\", options: [{a: 5}, {b: 6}] },\n     *  {question: \"Why is b?\" },\n     *  {question: \"What is c?\"},\n     *  {question: \"How is c?\", options: [{a: 5}, {b: 6}] },\n     *  {question: \"Why is c?\" },\n     * ]\n     * new ExpandRewrite().convertStrict(spec, ConversionContext.test()) // => expected\n     */\n    convert(json: T | RewritableConfigJson<T>, context: ConversionContext): T[] {\n        if (json === null || json === undefined) {\n            return []\n        }\n\n        if (json[\"rewrite\"] === undefined) {\n            // not a rewrite\n            return [<T>json]\n        }\n\n        const rewrite = <RewritableConfigJson<T>>json\n        const keysToRewrite = rewrite.rewrite\n        const results: T[] = []\n\n        {\n            // sanity check: rewrite: [\"xyz\", \"longer_xyz\"] is not allowed as \"longer_xyz\" will never be triggered\n            for (let i = 0; i < keysToRewrite.sourceString.length; i++) {\n                const guard = keysToRewrite.sourceString[i]\n                for (let j = i + 1; j < keysToRewrite.sourceString.length; j++) {\n                    const toRewrite = keysToRewrite.sourceString[j]\n                    if (toRewrite.indexOf(guard) >= 0) {\n                        context.err(\n                            `sourcestring[${i}] is a substring of sourcestring[${j}]: ${guard} will be substituted away before ${toRewrite} is reached.`\n                        )\n                    }\n                }\n            }\n        }\n\n        {\n            // sanity check: {rewrite: [\"a\", \"b\"] should have the right amount of 'intos' in every case\n            for (let i = 0; i < rewrite.rewrite.into.length; i++) {\n                const into = keysToRewrite.into[i]\n                if (into.length !== rewrite.rewrite.sourceString.length) {\n                    context\n                        .enters(\"into\", i)\n                        .err(\n                            `Error in rewrite: there are ${rewrite.rewrite.sourceString.length} keys to rewrite, but entry ${i} has only ${into.length} values`\n                        )\n                }\n            }\n        }\n\n        let renderings = Array.isArray(rewrite.renderings)\n            ? rewrite.renderings\n            : [rewrite.renderings]\n        for (let i = 0; i < keysToRewrite.into.length; i++) {\n            let ts: T[] = <T[]>Utils.Clone(renderings)\n            for (const tx of ts) {\n                let t = <T>tx\n                const sourceKeysToIgnore: string[] = []\n                for (const listKey in rewrite.subexpand) {\n                    const original = t[listKey]\n                    if (!original) {\n                        continue\n                    }\n                    const sourceKeys = rewrite.subexpand[listKey].filter((sk) =>\n                        ExpandRewrite.contains(sk, original)\n                    )\n                    if (sourceKeys.length === 0) {\n                        // no delete t[listKey] needed, fixed values we need to retain\n                        continue\n                    }\n\n                    if (sourceKeys.length > 1) {\n                        throw (\n                            \"Too much matching sourcekeys for sublist `\" +\n                            listKey +\n                            \"`: it matches all of \" +\n                            sourceKeys.join(\", \")\n                        )\n                    }\n\n                    const sourceKey = sourceKeys[0]\n                    sourceKeysToIgnore.push(sourceKey)\n                    const rw = rewrite.rewrite\n                    const values = rw.into[i][rw.sourceString.indexOf(sourceKey)]\n\n                    if (!values) {\n                        delete t[listKey]\n                        continue\n                    }\n                    if (!Array.isArray(values)) {\n                        throw (\n                            \"Sublist expansion of `\" +\n                            listKey +\n                            \"` failed: not an array to expand with:\" +\n                            JSON.stringify(values)\n                        )\n                    }\n                    t[listKey] = [].concat(\n                        ...values.map((v) => ExpandRewrite.RewriteParts(sourceKey, v, original))\n                    )\n                }\n\n                for (let j = 0; j < keysToRewrite.sourceString.length; j++) {\n                    // The string that should be replaced everywhere in `t`\n                    const key = keysToRewrite.sourceString[j]\n                    if (sourceKeysToIgnore.indexOf(key) >= 0) {\n                        continue\n                    }\n                    // The object that `key` should be replaced with\n                    const target = keysToRewrite.into[i][j]\n                    t = ExpandRewrite.RewriteParts(key, target, t)\n                }\n                results.push(t)\n            }\n        }\n\n        return results\n    }\n}\n","import {\n    Concat,\n    Conversion,\n    DesugaringContext,\n    DesugaringStep,\n    Each,\n    FirstOf,\n    Fuse,\n    On,\n    SetDefault,\n} from \"./Conversion\"\nimport { LayerConfigJson } from \"../Json/LayerConfigJson\"\nimport {\n    MinimalTagRenderingConfigJson,\n    TagRenderingConfigJson,\n} from \"../Json/TagRenderingConfigJson\"\nimport { Utils } from \"../../../Utils\"\nimport RewritableConfigJson from \"../Json/RewritableConfigJson\"\nimport SpecialVisualizations from \"../../../UI/SpecialVisualizations\"\nimport Translations from \"../../../UI/i18n/Translations\"\nimport { Translation } from \"../../../UI/i18n/Translation\"\nimport tagrenderingconfigmeta from \"../../../../src/assets/schemas/tagrenderingconfigmeta.json\"\nimport { AddContextToTranslations } from \"./AddContextToTranslations\"\nimport FilterConfigJson from \"../Json/FilterConfigJson\"\nimport predifined_filters from \"../../../../assets/layers/filters/filters.json\"\nimport { TagConfigJson } from \"../Json/TagConfigJson\"\nimport PointRenderingConfigJson, { IconConfigJson } from \"../Json/PointRenderingConfigJson\"\nimport ValidationUtils from \"./ValidationUtils\"\nimport { RenderingSpecification } from \"../../../UI/SpecialVisualization\"\nimport { QuestionableTagRenderingConfigJson } from \"../Json/QuestionableTagRenderingConfigJson\"\nimport { ConfigMeta } from \"../../../UI/Studio/configMeta\"\nimport LineRenderingConfigJson from \"../Json/LineRenderingConfigJson\"\nimport { ConversionContext } from \"./ConversionContext\"\nimport { ExpandRewrite } from \"./ExpandRewrite\"\n\nclass ExpandFilter extends DesugaringStep<LayerConfigJson> {\n    private static readonly predefinedFilters = ExpandFilter.load_filters()\n    private _state: DesugaringContext\n\n    constructor(state: DesugaringContext) {\n        super(\n            \"Expands filters: replaces a shorthand by the value found in 'filters.json'. If the string is formatted 'layername.filtername, it will be looked up into that layer instead\",\n            [\"filter\"],\n            \"ExpandFilter\"\n        )\n        this._state = state\n    }\n\n    private static load_filters(): Map<string, FilterConfigJson> {\n        const filters = new Map<string, FilterConfigJson>()\n        for (const filter of <FilterConfigJson[]>predifined_filters.filter) {\n            filters.set(filter.id, filter)\n        }\n        return filters\n    }\n\n    convert(json: LayerConfigJson, context: ConversionContext): LayerConfigJson {\n        if (json?.filter === undefined || json?.filter === null) {\n            return json // Nothing to change here\n        }\n\n        if (json.filter[\"sameAs\"] !== undefined) {\n            return json // Nothing to change here\n        }\n\n        const newFilters: FilterConfigJson[] = []\n        const filters = <(FilterConfigJson | string)[]>json.filter\n        for (let i = 0; i < filters.length; i++) {\n            const filter = filters[i]\n            if (typeof filter !== \"string\") {\n                newFilters.push(filter)\n                continue\n            }\n\n            const matchingTr = <TagRenderingConfigJson>(\n                json.tagRenderings.find((tr) => !!tr && tr[\"id\"] === filter)\n            )\n            if (matchingTr) {\n                if (!(matchingTr.mappings?.length >= 1)) {\n                    context\n                        .enters(\"filter\", i)\n                        .err(\n                            \"Found a matching tagRendering to base a filter on, but this tagRendering does not contain any mappings\"\n                        )\n                }\n                const options = matchingTr.mappings.map((mapping) => ({\n                    question: mapping.then,\n                    osmTags: mapping.if,\n                }))\n                options.unshift({\n                    question: {\n                        en: \"All types\",\n                    },\n                    osmTags: undefined,\n                })\n                newFilters.push({\n                    id: filter,\n                    options,\n                })\n                continue\n            }\n\n            if (filter.indexOf(\".\") > 0) {\n                if (this._state.sharedLayers.size > 0) {\n                    const split = filter.split(\".\")\n                    if (split.length > 2) {\n                        context.err(\n                            \"invalid filter name: \" + filter + \", expected `layername.filterid`\"\n                        )\n                    }\n                    const layer = this._state.sharedLayers.get(split[0])\n                    if (layer === undefined) {\n                        context.err(\"Layer '\" + split[0] + \"' not found\")\n                    }\n                    const expectedId = split[1]\n                    const expandedFilter = (<(FilterConfigJson | string)[]>layer.filter).find(\n                        (f) => typeof f !== \"string\" && f.id === expectedId\n                    )\n                    newFilters.push(<FilterConfigJson>expandedFilter)\n                } else {\n                    // This is a bootstrapping-run, we can safely ignore this\n                }\n                continue\n            }\n            // Search for the filter:\n            const found = ExpandFilter.predefinedFilters.get(filter)\n            if (found === undefined) {\n                const suggestions = Utils.sortedByLevenshteinDistance(\n                    filter,\n                    Array.from(ExpandFilter.predefinedFilters.keys()),\n                    (t) => t\n                )\n                context\n                    .enter(filter)\n                    .err(\n                        \"While searching for predefined filter \" +\n                            filter +\n                            \": this filter is not found. Perhaps you meant one of: \" +\n                            suggestions\n                    )\n            }\n            newFilters.push(found)\n        }\n        return { ...json, filter: newFilters }\n    }\n}\n\nclass ExpandTagRendering extends Conversion<\n    | string\n    | TagRenderingConfigJson\n    | {\n          builtin: string | string[]\n          override: any\n      },\n    TagRenderingConfigJson[]\n> {\n    private readonly _state: DesugaringContext\n    private readonly _tagRenderingsByLabel: Map<string, TagRenderingConfigJson[]>\n    // Only used for self-reference\n    private readonly _self: LayerConfigJson\n    private readonly _options: {\n        /* If true, will copy the 'osmSource'-tags into the condition */\n        applyCondition?: true | boolean\n        noHardcodedStrings?: false | boolean\n    }\n\n    constructor(\n        state: DesugaringContext,\n        self: LayerConfigJson,\n        options?: {\n            applyCondition?: true | boolean\n            noHardcodedStrings?: false | boolean\n        }\n    ) {\n        super(\n            \"Converts a tagRenderingSpec into the full tagRendering, e.g. by substituting the tagRendering by the shared-question\",\n            [],\n            \"ExpandTagRendering\"\n        )\n        this._state = state\n        this._self = self\n        this._options = options\n        this._tagRenderingsByLabel = new Map<string, TagRenderingConfigJson[]>()\n        for (const trconfig of state.tagRenderings?.values() ?? []) {\n            for (const label of trconfig[\"labels\"] ?? []) {\n                let withLabel = this._tagRenderingsByLabel.get(label)\n                if (withLabel === undefined) {\n                    withLabel = []\n                    this._tagRenderingsByLabel.set(label, withLabel)\n                }\n                withLabel.push(trconfig)\n            }\n        }\n    }\n\n    public convert(\n        spec: string | any,\n        ctx: ConversionContext\n    ): QuestionableTagRenderingConfigJson[] {\n        const trs = this.convertOnce(spec, ctx)\n\n        const result = []\n        for (const tr of trs) {\n            if (typeof tr === \"string\" || tr[\"builtin\"] !== undefined) {\n                const stable = this.convert(tr, ctx.inOperation(\"recursive_resolve\"))\n                result.push(...stable)\n            } else {\n                result.push(tr)\n            }\n        }\n\n        return result\n    }\n\n    private lookup(name: string, ctx: ConversionContext): TagRenderingConfigJson[] | undefined {\n        const direct = this.directLookup(name)\n\n        if (direct === undefined) {\n            return undefined\n        }\n        const result: TagRenderingConfigJson[] = []\n        for (const tagRenderingConfigJson of direct) {\n            let nm: string | string[] | undefined = tagRenderingConfigJson[\"builtin\"]\n            if (nm !== undefined) {\n                let indirect: TagRenderingConfigJson[]\n                if (typeof nm === \"string\") {\n                    indirect = this.lookup(nm, ctx)\n                } else {\n                    indirect = [].concat(...nm.map((n) => this.lookup(n, ctx)))\n                }\n                for (let foundTr of indirect) {\n                    foundTr = Utils.Clone<any>(foundTr)\n                    ctx.MergeObjectsForOverride(tagRenderingConfigJson[\"override\"] ?? {}, foundTr)\n                    foundTr[\"id\"] = tagRenderingConfigJson[\"id\"] ?? foundTr[\"id\"]\n                    result.push(foundTr)\n                }\n            } else {\n                result.push(tagRenderingConfigJson)\n            }\n        }\n        return result\n    }\n\n    /**\n     * Looks up a tagRendering or group of tagRenderings based on the name.\n     */\n    private directLookup(name: string): TagRenderingConfigJson[] | undefined {\n        const state = this._state\n        if (state.tagRenderings.has(name)) {\n            return [state.tagRenderings.get(name)]\n        }\n        if (this._tagRenderingsByLabel.has(name)) {\n            return this._tagRenderingsByLabel.get(name)\n        }\n\n        if (name.indexOf(\".\") < 0) {\n            return undefined\n        }\n\n        const spl = name.split(\".\")\n        let layer = state.sharedLayers?.get(spl[0])\n        if (spl[0] === this._self?.id) {\n            layer = this._self\n        }\n\n        if (spl.length !== 2 || !layer) {\n            return undefined\n        }\n\n        const id = spl[1]\n\n        const layerTrs = <TagRenderingConfigJson[]>(\n            layer.tagRenderings.filter((tr) => tr[\"id\"] !== undefined)\n        )\n        let matchingTrs: TagRenderingConfigJson[]\n        if (id === \"*\") {\n            matchingTrs = layerTrs\n        } else if (id.startsWith(\"*\")) {\n            const id_ = id.substring(1)\n            matchingTrs = layerTrs.filter((tr) => tr[\"labels\"]?.indexOf(id_) >= 0)\n        } else {\n            matchingTrs = layerTrs.filter((tr) => tr[\"id\"] === id || tr[\"labels\"]?.indexOf(id) >= 0)\n        }\n\n        const contextWriter = new AddContextToTranslations<TagRenderingConfigJson>(\"layers:\")\n        for (let i = 0; i < matchingTrs.length; i++) {\n            let found: TagRenderingConfigJson = Utils.Clone(matchingTrs[i])\n            if (this._options?.applyCondition) {\n                // The matched tagRenderings are 'stolen' from another layer. This means that they must match the layer condition before being shown\n                if (typeof layer.source !== \"string\") {\n                    if (found.condition === undefined) {\n                        found.condition = layer.source[\"osmTags\"]\n                    } else {\n                        found.condition = { and: [found.condition, layer.source[\"osmTags\"]] }\n                    }\n                }\n            }\n\n            found = contextWriter.convertStrict(\n                found,\n                ConversionContext.construct(\n                    [layer.id, \"tagRenderings\", found[\"id\"]],\n                    [\"AddContextToTranslations\"]\n                )\n            )\n            matchingTrs[i] = found\n        }\n\n        if (matchingTrs.length !== 0) {\n            return matchingTrs\n        }\n        return undefined\n    }\n\n    private convertOnce(tr: string | any, ctx: ConversionContext): TagRenderingConfigJson[] {\n        const state = this._state\n\n        if (typeof tr === \"string\") {\n            let lookup\n            if (this._state.tagRenderings !== null) {\n                lookup = this.lookup(tr, ctx)\n            }\n            if (lookup === undefined) {\n                if (\n                    this._state.sharedLayers?.size > 0 &&\n                    ctx.path.at(-1) !== \"icon\" &&\n                    !ctx.path.find((p) => p === \"pointRendering\")\n                ) {\n                    ctx.warn(\n                        `A literal rendering was detected: ${tr}\n                      Did you perhaps forgot to add a layer name as 'layername.${tr}'? ` +\n                            Array.from(state.sharedLayers.keys()).join(\", \")\n                    )\n                }\n\n                if (this._options?.noHardcodedStrings && this._state?.sharedLayers?.size > 0) {\n                    ctx.err(\n                        \"Detected an invocation to a builtin tagRendering, but this tagrendering was not found: \" +\n                            tr +\n                            \" \\n    Did you perhaps forget to add the layer as prefix, such as `icons.\" +\n                            tr +\n                            \"`? \"\n                    )\n                }\n\n                return [\n                    <any>{\n                        render: tr,\n                        id: tr.replace(/[^a-zA-Z0-9]/g, \"\"),\n                    },\n                ]\n            }\n            return lookup\n        }\n\n        if (tr[\"builtin\"] !== undefined) {\n            let names: string | string[] = tr[\"builtin\"]\n            if (typeof names === \"string\") {\n                names = [names]\n            }\n\n            if (this._state.tagRenderings === null) {\n                return []\n            }\n\n            for (const key of Object.keys(tr)) {\n                if (\n                    key === \"builtin\" ||\n                    key === \"override\" ||\n                    key === \"id\" ||\n                    key.startsWith(\"#\")\n                ) {\n                    continue\n                }\n                ctx.err(\n                    \"An object calling a builtin can only have keys `builtin` or `override`, but a key with name `\" +\n                        key +\n                        \"` was found. This won't be picked up! The full object is: \" +\n                        JSON.stringify(tr)\n                )\n            }\n\n            const trs: TagRenderingConfigJson[] = []\n            for (const name of names) {\n                const lookup = this.lookup(name, ctx)\n                if (lookup === undefined) {\n                    let candidates = Array.from(state.tagRenderings.keys())\n                    if (name.indexOf(\".\") > 0) {\n                        const [layerName] = name.split(\".\")\n                        let layer = state.sharedLayers.get(layerName)\n                        if (layerName === this._self?.id) {\n                            layer = this._self\n                        }\n                        if (layer === undefined) {\n                            const candidates = Utils.sortedByLevenshteinDistance(\n                                layerName,\n                                Array.from(state.sharedLayers.keys()),\n                                (s) => s\n                            )\n                            if (state.sharedLayers.size === 0) {\n                                ctx.warn(\n                                    \"BOOTSTRAPPING. Rerun generate layeroverview. While reusing tagrendering: \" +\n                                        name +\n                                        \": layer \" +\n                                        layerName +\n                                        \" not found for now, but ignoring as this is a bootstrapping run. \"\n                                )\n                            } else {\n                                ctx.err(\n                                    \": While reusing tagrendering: \" +\n                                        name +\n                                        \": layer \" +\n                                        layerName +\n                                        \" not found. Maybe you meant one of \" +\n                                        candidates.slice(0, 3).join(\", \")\n                                )\n                            }\n                            continue\n                        }\n                        candidates = Utils.NoNull(layer.tagRenderings.map((tr) => tr[\"id\"])).map(\n                            (id) => layerName + \".\" + id\n                        )\n                    }\n                    candidates = Utils.sortedByLevenshteinDistance(name, candidates, (i) => i)\n                    ctx.err(\n                        \"The tagRendering with identifier \" +\n                            name +\n                            \" was not found.\\n\\tDid you mean one of \" +\n                            candidates.join(\", \") +\n                            \"?\\n(Hint: did you add a new label and are you trying to use this label at the same time? Run 'reset:layeroverview' first\"\n                    )\n                    continue\n                }\n                for (let foundTr of lookup) {\n                    foundTr = Utils.Clone<any>(foundTr)\n                    ctx.MergeObjectsForOverride(tr[\"override\"] ?? {}, foundTr)\n                    if (names.length == 1) {\n                        foundTr[\"id\"] = tr[\"id\"] ?? foundTr[\"id\"]\n                    }\n                    trs.push(foundTr)\n                }\n            }\n            return trs\n        }\n\n        return [tr]\n    }\n}\n\nclass DetectInline extends DesugaringStep<QuestionableTagRenderingConfigJson> {\n    constructor() {\n        super(\n            \"If no 'inline' is set on the freeform key, it will be automatically added. If no special renderings are used, it'll be set to true\",\n            [\"freeform.inline\"],\n            \"DetectInline\"\n        )\n    }\n\n    convert(\n        json: QuestionableTagRenderingConfigJson,\n        context: ConversionContext\n    ): QuestionableTagRenderingConfigJson {\n        if (json.freeform === undefined) {\n            return json\n        }\n        let spec: Record<string, string>\n        if (typeof json.render === \"string\") {\n            spec = { \"*\": json.render }\n        } else {\n            spec = <Record<string, string>>json.render\n        }\n        for (const key in spec) {\n            if (spec[key].indexOf(\"<a \") >= 0) {\n                // We have a link element, it probably contains something that needs to be substituted...\n                // Let's play this safe and not inline it\n                return json\n            }\n            const fullSpecification = SpecialVisualizations.constructSpecification(spec[key])\n            if (fullSpecification.length > 1) {\n                // We found a special rendering!\n                if (json.freeform.inline === true) {\n                    context.err(\n                        \"'inline' is set, but the rendering contains a special visualisation...\\n    \" +\n                            spec[key]\n                    )\n                }\n                json = JSON.parse(JSON.stringify(json))\n                json.freeform.inline = false\n                return json\n            }\n        }\n        json = JSON.parse(JSON.stringify(json))\n        if (typeof json.freeform === \"string\") {\n            context.err(\"'freeform' is a string, but should be an object\")\n            return json\n        }\n        json.freeform.inline ??= true\n        return json\n    }\n}\n\nexport class AddQuestionBox extends DesugaringStep<LayerConfigJson> {\n    constructor() {\n        super(\n            \"Adds a 'questions'-object if no question element is added yet\",\n            [\"tagRenderings\"],\n            \"AddQuestionBox\"\n        )\n    }\n\n    /**\n     * const action = new AddQuestionBox()\n     * const tagRenderings = [{id:\"questions\", render: {\"*\": \"{questions()}\" } }]\n     * const conv = action.convert({tagRenderings}, ConversionContext.construct([\"test\"], []))\n     * conv.tagRenderings // => [{id:\"questions\", render: {\"*\": \"{questions()}\" } }]\n     */\n    convert(json: LayerConfigJson, context: ConversionContext): LayerConfigJson {\n        if (\n            json.tagRenderings === undefined ||\n            json.tagRenderings.some((tr) => tr[\"id\"] === \"leftover-questions\")\n        ) {\n            return json\n        }\n        if (json.source === \"special\") {\n            return json\n        }\n        json = { ...json }\n        json.tagRenderings = [...json.tagRenderings]\n        const allSpecials: Exclude<RenderingSpecification, string>[] = <any>(\n            ValidationUtils.getAllSpecialVisualisations(\n                <QuestionableTagRenderingConfigJson[]>json.tagRenderings\n            ).filter((spec) => typeof spec !== \"string\")\n        )\n\n        const questionSpecials = allSpecials.filter((sp) => sp.func.funcName === \"questions\")\n        const noLabels = questionSpecials.filter(\n            (sp) => sp.args.length === 0 || sp.args[0].trim() === \"\"\n        )\n\n        if (noLabels.length > 1) {\n            context.err(\n                \"Multiple 'questions'-visualisations found which would show _all_ questions. Don't do this\"\n            )\n        }\n\n        // ALl labels that are used in this layer\n        const allLabels = new Set(\n            [].concat(\n                ...json.tagRenderings.map(\n                    (tr) => (<QuestionableTagRenderingConfigJson>tr).labels ?? []\n                )\n            )\n        )\n        const seen: Set<string> = new Set()\n        for (const questionSpecial of questionSpecials) {\n            if (typeof questionSpecial === \"string\") {\n                continue\n            }\n            const used = questionSpecial.args[0]\n                ?.split(\";\")\n                ?.map((a) => a.trim())\n                ?.filter((s) => s != \"\")\n            const blacklisted = questionSpecial.args[1]\n                ?.split(\";\")\n                ?.map((a) => a.trim())\n                ?.filter((s) => s != \"\")\n            if (blacklisted?.length > 0 && used?.length > 0) {\n                context.err(\n                    \"The {questions()}-special rendering only supports either a blacklist OR a whitelist, but not both.\" +\n                        \"\\n    Whitelisted: \" +\n                        used.join(\", \") +\n                        \"\\n    Blacklisted: \" +\n                        blacklisted.join(\", \")\n                )\n            }\n            for (const usedLabel of used) {\n                if (!allLabels.has(usedLabel)) {\n                    context.err(\n                        \"This layers specifies a special question element for label `\" +\n                            usedLabel +\n                            \"`, but this label doesn't exist.\\n\" +\n                            \"    Available labels are \" +\n                            Array.from(allLabels).join(\", \")\n                    )\n                }\n                seen.add(usedLabel)\n            }\n        }\n\n        if (noLabels.length == 0) {\n            /* At this point, we know which question labels are not yet handled and which already are handled, and we\n             * know there is no previous catch-all questions\n             */\n            const question: QuestionableTagRenderingConfigJson = {\n                id: \"leftover-questions\",\n                render: {\n                    \"*\": `{questions( ,${Array.from(seen).join(\";\")})}`,\n                },\n            }\n            json.tagRenderings.push(question)\n        }\n        return json\n    }\n}\n\nexport class AddEditingElements extends DesugaringStep<LayerConfigJson> {\n    static addedElements: string[] = [\n        \"minimap\",\n        \"just_created\",\n        \"split_button\",\n        \"move_button\",\n        \"delete_button\",\n        \"last_edit\",\n        \"favourite_state\",\n        \"all_tags\",\n        \"qr_code\",\n    ]\n    private readonly _desugaring: DesugaringContext\n\n    constructor(desugaring: DesugaringContext) {\n        super(\n            \"Add some editing elements, such as the delete button or the move button if they are configured. These used to be handled by the feature info box, but this has been replaced by special visualisation elements\",\n            [],\n            \"AddEditingElements\"\n        )\n        this._desugaring = desugaring\n    }\n\n    convert(json: LayerConfigJson, _: ConversionContext): LayerConfigJson {\n        if (this._desugaring.tagRenderings === null) {\n            return json\n        }\n        if (json.source === \"special\") {\n            return json\n        }\n        if (!json.title && !json.tagRenderings) {\n            return json\n        }\n        json = { ...json }\n        json.tagRenderings = [...(json.tagRenderings ?? [])]\n        const allIds = new Set<string>(json.tagRenderings.map((tr) => tr[\"id\"]))\n        const specialVisualisations = ValidationUtils.getAllSpecialVisualisations(\n            <any>json.tagRenderings\n        )\n        const usedSpecialFunctions = new Set(\n            specialVisualisations.map((sv) =>\n                typeof sv === \"string\" ? undefined : sv.func.funcName\n            )\n        )\n        if (!allIds.has(\"lod\")) {\n            json.tagRenderings.push(this._desugaring.tagRenderings.get(\"lod\"))\n        }\n        if (!usedSpecialFunctions.has(\"minimap\")) {\n            json.tagRenderings.push(this._desugaring.tagRenderings.get(\"minimap\"))\n        }\n\n        if (\n            this._desugaring.tagRenderings.has(\"just_created\") &&\n            !json.tagRenderings.some((tr) => tr === \"just_created\" || tr[\"id\"] === \"just_created\")\n        ) {\n            json.tagRenderings.unshift(this._desugaring.tagRenderings.get(\"just_created\"))\n        }\n\n        if (json.allowSplit && !usedSpecialFunctions.has(\"split_button\")) {\n            json.tagRenderings.push({\n                id: \"split-button\",\n                render: { \"*\": \"{split_button()}\" },\n            })\n            delete json.allowSplit\n        }\n\n        if (json.allowMove && !usedSpecialFunctions.has(\"move_button\")) {\n            json.tagRenderings.push({\n                id: \"move-button\",\n                render: { \"*\": \"{move_button()}\" },\n            })\n        }\n        if (json.deletion && !usedSpecialFunctions.has(\"delete_button\")) {\n            json.tagRenderings.push({\n                id: \"delete-button\",\n                render: { \"*\": \"{delete_button()}\" },\n            })\n        }\n\n        if (\n            json.source !== \"special\" &&\n            json.source !== \"special:library\" &&\n            json.tagRenderings &&\n            this._desugaring.tagRenderings.has(\"last_edit\") &&\n            !json.tagRenderings.some((tr) => tr[\"id\"] === \"last_edit\")\n        ) {\n            json.tagRenderings.push(this._desugaring.tagRenderings.get(\"last_edit\"))\n        }\n\n        if (!usedSpecialFunctions.has(\"favourite_status\")) {\n            json.tagRenderings.push({\n                id: \"favourite_status\",\n                render: { \"*\": \"{favourite_status()}\" },\n            })\n        }\n\n        if (!allIds.has(\"qr_code\")) {\n            json.tagRenderings.push(this._desugaring.tagRenderings.get(\"qr_code\"))\n        }\n\n        if (!allIds.has(\"share\")) {\n            json.tagRenderings.push(this._desugaring.tagRenderings.get(\"share\"))\n        }\n\n        if (!usedSpecialFunctions.has(\"all_tags\")) {\n            const trc: QuestionableTagRenderingConfigJson = {\n                id: \"all-tags\",\n                render: { \"*\": \"{all_tags()}\" },\n\n                metacondition: {\n                    or: [\n                        \"__featureSwitchIsDebugging=true\",\n                        \"mapcomplete-show_tags=full\",\n                        \"mapcomplete-show_debug=yes\",\n                    ],\n                },\n            }\n            json.tagRenderings?.push(trc)\n        }\n\n        return json\n    }\n}\n\n/**\n * Converts a 'special' translation into a regular translation which uses parameters\n */\nexport class RewriteSpecial extends DesugaringStep<TagRenderingConfigJson> {\n    constructor() {\n        super(\n            \"Converts a 'special' translation into a regular translation which uses parameters\",\n            [\"special\"],\n            \"RewriteSpecial\"\n        )\n    }\n\n    private static escapeStr(v: string): string {\n        return v\n            .replace(/,/g, \"&COMMA\")\n            .replace(/\\{/g, \"&LBRACE\")\n            .replace(/}/g, \"&RBRACE\")\n            .replace(/\\(/g, \"&LPARENS\")\n            .replace(/\\)/g, \"&RPARENS\")\n    }\n\n    /**\n     * Does the heavy lifting and conversion\n     *\n     * // should not do anything if no 'special'-key is present\n     * RewriteSpecial.convertIfNeeded({\"en\": \"xyz\", \"nl\": \"abc\"}, ConversionContext.test()) // => {\"en\": \"xyz\", \"nl\": \"abc\"}\n     *\n     * // should handle a simple special case\n     * RewriteSpecial.convertIfNeeded({\"special\": {\"type\":\"image_carousel\"}}, ConversionContext.test()) // => {'*': \"{image_carousel()}\"}\n     *\n     * // should handle special case with a parameter\n     * RewriteSpecial.convertIfNeeded({\"special\": {\"type\":\"image_carousel\", \"image_key\": \"some_image_key\"}}, ConversionContext.test()) // =>  {'*': \"{image_carousel(some_image_key)}\"}\n     *\n     * // should handle special case with a translated parameter\n     * const spec = {\"special\": {\"type\":\"image_upload\", \"label\": {\"en\": \"Add a picture to this object\", \"nl\": \"Voeg een afbeelding toe\"}}}\n     * const r = RewriteSpecial.convertIfNeeded(spec, ConversionContext.test())\n     * r // => {\"en\": \"{image_upload(,Add a picture to this object)}\", \"nl\": \"{image_upload(,Voeg een afbeelding toe)}\" }\n     *\n     * // should handle special case with a prefix and postfix\n     * const spec = {\"special\": {\"type\":\"image_upload\" }, before: {\"en\": \"PREFIX \"}, after: {\"en\": \" POSTFIX\", nl: \" Achtervoegsel\"} }\n     * const r = RewriteSpecial.convertIfNeeded(spec, ConversionContext.test())\n     * r // => {\"en\": \"PREFIX {image_upload(,)} POSTFIX\", \"nl\": \"PREFIX {image_upload(,)} Achtervoegsel\" }\n     *\n     * // should warn for unexpected keys\n     * const context = ConversionContext.test()\n     * RewriteSpecial.convertIfNeeded({\"special\": {type: \"image_carousel\"}, \"en\": \"xyz\"}, context) // =>  {'*': \"{image_carousel()}\"}\n     * context.getAll(\"error\")[0].message // => \"The only keys allowed next to a 'special'-block are 'before' and 'after'. Perhaps you meant to put 'en' into the special block?\"\n     *\n     * // should give an error on unknown visualisations\n     * const context = ConversionContext.test()\n     * RewriteSpecial.convertIfNeeded({\"special\": {type: \"qsdf\"}}, context) // => undefined\n     * context.getAll(\"error\")[0].message.indexOf(\"Special visualisation 'qsdf' not found\") >= 0 // => true\n     *\n     * // should give an error is 'type' is missing\n     * const context = ConversionContext.test()\n     * RewriteSpecial.convertIfNeeded({\"special\": {}}, context) // => undefined\n     * context.getAll(\"error\")[0].message // => \"A 'special'-block should define 'type' to indicate which visualisation should be used\"\n     *\n     *\n     * // an actual test\n     * const special = {\n     *     \"before\": {\n     *             \"en\": \"<h3>Entrances</h3>This building has {_entrances_count} entrances:\"\n     *           },\n     *     \"after\": {\n     *             \"en\": \"{_entrances_count_without_width_count} entrances don't have width information yet\"\n     *           },\n     *     \"special\": {\n     *           \"type\": \"multi\",\n     *           \"key\": \"_entrance_properties_with_width\",\n     *           \"tagrendering\": {\n     *             \"en\": \"An <a href='#{id}'>entrance</a> of {canonical(width)}\"\n     *           }\n     *         }}\n     * const context = ConversionContext.test()\n     * RewriteSpecial.convertIfNeeded(special, context) // => {\"en\": \"<h3>Entrances</h3>This building has {_entrances_count} entrances:{multi(_entrance_properties_with_width,An <a href='#&LBRACEid&RBRACE'>entrance</a> of &LBRACEcanonical&LPARENSwidth&RPARENS&RBRACE,)}{_entrances_count_without_width_count} entrances don't have width information yet\"}\n     * context.getAll(\"error\") // => []\n     *\n     * // another actual test\n     * const special = {\n     *     \"special\":{\n     *          \"type\": \"multi\",\n     *          \"key\": \"_nearby_bicycle_parkings:props\",\n     *          \"tagrendering\": \"<b>{id}</b> ({distance}m) {tagApply(a,b,c)}\"\n     *         }}\n     * const context = ConversionContext.test()\n     * RewriteSpecial.convertIfNeeded(special, context) // => {\"*\": \"{multi(_nearby_bicycle_parkings:props,<b>&LBRACEid&RBRACE</b> &LPARENS&LBRACEdistance&RBRACEm&RPARENS &LBRACEtagApply&LPARENSa&COMMAb&COMMAc&RPARENS&RBRACE,)}\"}\n     * context.getAll(\"error\") // => []\n     */\n    private static convertIfNeeded(\n        input:\n            | (object & {\n                  special: {\n                      type: string\n                  }\n              })\n            | any,\n        context: ConversionContext\n    ): any {\n        const special = input[\"special\"]\n        if (special === undefined) {\n            return input\n        }\n\n        const type = special[\"type\"]\n        if (type === undefined) {\n            context.err(\n                \"A 'special'-block should define 'type' to indicate which visualisation should be used\"\n            )\n            return undefined\n        }\n\n        const vis = SpecialVisualizations.specialVisualizations.find((sp) => sp.funcName === type)\n        if (vis === undefined) {\n            const options = Utils.sortedByLevenshteinDistance(\n                type,\n                SpecialVisualizations.specialVisualizations,\n                (sp) => sp.funcName\n            )\n            context.err(\n                `Special visualisation '${type}' not found. Did you perhaps mean ${options[0].funcName}, ${options[1].funcName} or ${options[2].funcName}?\\n\\tFor all known special visualisations, please see https://github.com/pietervdvn/MapComplete/blob/develop/Docs/SpecialRenderings.md`\n            )\n            return undefined\n        }\n        Array.from(Object.keys(input))\n            .filter((k) => k !== \"special\" && k !== \"before\" && k !== \"after\")\n            .map((k) => {\n                return `The only keys allowed next to a 'special'-block are 'before' and 'after'. Perhaps you meant to put '${k}' into the special block?`\n            })\n            .forEach((e) => context.err(e))\n\n        const argNamesList = vis.args.map((a) => a.name)\n        const argNames = new Set<string>(argNamesList)\n        // Check for obsolete and misspelled arguments\n        Object.keys(special)\n            .filter((k) => !argNames.has(k))\n            .filter((k) => k !== \"type\" && k !== \"before\" && k !== \"after\")\n            .map((wrongArg) => {\n                const byDistance = Utils.sortedByLevenshteinDistance(\n                    wrongArg,\n                    argNamesList,\n                    (x) => x\n                )\n                return `Unexpected argument in special block at ${context} with name '${wrongArg}'. Did you mean ${\n                    byDistance[0]\n                }?\\n\\tAll known arguments are ${argNamesList.join(\", \")}`\n            })\n            .forEach((e) => context.err(e))\n\n        // Check that all obligated arguments are present. They are obligated if they don't have a preset value\n        for (const arg of vis.args) {\n            if (arg.required !== true) {\n                continue\n            }\n            const param = special[arg.name]\n            if (param === undefined) {\n                context.err(\n                    `Obligated parameter '${arg.name}' in special rendering of type ${\n                        vis.funcName\n                    } not found.\\n    The full special rendering specification is: '${JSON.stringify(\n                        input\n                    )}'\\n    ${arg.name}: ${arg.doc}`\n                )\n            }\n        }\n\n        const foundLanguages = new Set<string>()\n        const translatedArgs = argNamesList\n            .map((nm) => special[nm])\n            .filter((v) => v !== undefined)\n            .filter((v) => Translations.isProbablyATranslation(v) || v[\"*\"] !== undefined)\n        for (const translatedArg of translatedArgs) {\n            for (const ln of Object.keys(translatedArg)) {\n                foundLanguages.add(ln)\n            }\n        }\n\n        const before = Translations.T(input.before)\n        const after = Translations.T(input.after)\n\n        for (const ln of Object.keys(before?.translations ?? {})) {\n            foundLanguages.add(ln)\n        }\n        for (const ln of Object.keys(after?.translations ?? {})) {\n            foundLanguages.add(ln)\n        }\n\n        if (foundLanguages.size === 0) {\n            const args = argNamesList\n                .map((nm) => RewriteSpecial.escapeStr(special[nm] ?? \"\"))\n                .join(\",\")\n            return {\n                \"*\": `{${type}(${args})}`,\n            }\n        }\n\n        const result = {}\n        const languages = Array.from(foundLanguages)\n        languages.sort()\n        for (const ln of languages) {\n            const args = []\n            for (const argName of argNamesList) {\n                let v = special[argName] ?? \"\"\n                if (Translations.isProbablyATranslation(v)) {\n                    v = new Translation(v).textFor(ln)\n                }\n\n                if (typeof v === \"string\") {\n                    args.push(RewriteSpecial.escapeStr(v))\n                } else if (typeof v === \"object\") {\n                    args.push(JSON.stringify(v))\n                } else {\n                    args.push(v)\n                }\n            }\n            const beforeText = before?.textFor(ln) ?? \"\"\n            const afterText = after?.textFor(ln) ?? \"\"\n            result[ln] = `${beforeText}{${type}(${args.map((a) => a).join(\",\")})}${afterText}`\n        }\n        return result\n    }\n\n    /**\n     * const tr = {\n     *     render: {special: {type: \"image_carousel\", image_key: \"image\" }},\n     *     mappings: [\n     *         {\n     *             if: \"other_image_key\",\n     *             then: {special: {type: \"image_carousel\", image_key: \"other_image_key\"}}\n     *         }\n     *     ]\n     * }\n     * const result = new RewriteSpecial().convertStrict(tr,ConversionContext.test())\n     * const expected = {render:  {'*': \"{image_carousel(image)}\"}, mappings: [{if: \"other_image_key\", then:  {'*': \"{image_carousel(other_image_key)}\"}} ]}\n     * result // => expected\n     *\n     * // Should put text before if specified\n     * const tr = {\n     *     render: {special: {type: \"image_carousel\", image_key: \"image\"}, before: {en: \"Some introduction\"} },\n     * }\n     * const result = new RewriteSpecial().convertStrict(tr,ConversionContext.test())\n     * const expected = {render:  {'en': \"Some introduction{image_carousel(image)}\"}}\n     * result // => expected\n     *\n     * // Should put text after if specified\n     * const tr = {\n     *     render: {special: {type: \"image_carousel\", image_key: \"image\"}, after: {en: \"Some footer\"} },\n     * }\n     * const result = new RewriteSpecial().convertStrict(tr,ConversionContext.test())\n     * const expected = {render:  {'en': \"{image_carousel(image)}Some footer\"}}\n     * result // => expected\n     */\n    convert(json: TagRenderingConfigJson, context: ConversionContext): TagRenderingConfigJson {\n        json = Utils.Clone(json)\n        const paths: ConfigMeta[] = tagrenderingconfigmeta\n        for (const path of paths) {\n            if (path.hints.typehint !== \"rendered\") {\n                continue\n            }\n            Utils.WalkPath(path.path, json, (leaf, travelled) =>\n                RewriteSpecial.convertIfNeeded(leaf, context.enter(travelled))\n            )\n        }\n\n        return json\n    }\n}\n\nclass ExpandIconBadges extends DesugaringStep<PointRenderingConfigJson> {\n    private _expand: ExpandTagRendering\n\n    constructor(state: DesugaringContext, layer: LayerConfigJson) {\n        super(\"Expands shorthand properties on iconBadges\", [\"iconBadges\"], \"ExpandIconBadges\")\n        this._expand = new ExpandTagRendering(state, layer)\n    }\n\n    convert(json: PointRenderingConfigJson, context: ConversionContext): PointRenderingConfigJson {\n        if (!json[\"iconBadges\"]) {\n            return json\n        }\n        const badgesJson = json.iconBadges\n\n        const iconBadges: {\n            if: TagConfigJson\n            then: string | MinimalTagRenderingConfigJson\n        }[] = []\n\n        for (let i = 0; i < badgesJson.length; i++) {\n            const iconBadge: {\n                if: TagConfigJson\n                then: string | MinimalTagRenderingConfigJson\n            } = badgesJson[i]\n            const expanded = this._expand.convert(\n                <QuestionableTagRenderingConfigJson>iconBadge.then,\n                context.enters(\"iconBadges\", i)\n            )\n            if (expanded === undefined) {\n                iconBadges.push(iconBadge)\n                continue\n            }\n\n            iconBadges.push(\n                ...expanded.map((resolved) => ({\n                    if: iconBadge.if,\n                    then: <MinimalTagRenderingConfigJson>resolved,\n                }))\n            )\n        }\n\n        return { ...json, iconBadges }\n    }\n}\n\nclass PreparePointRendering extends Fuse<PointRenderingConfigJson> {\n    constructor(state: DesugaringContext, layer: LayerConfigJson) {\n        super(\n            \"Prepares point renderings by expanding 'icon' and 'iconBadges'\",\n            new On(\n                \"marker\",\n                new Each(\n                    new On(\n                        \"icon\",\n                        new FirstOf(new ExpandTagRendering(state, layer, { applyCondition: false }))\n                    )\n                )\n            ),\n            new ExpandIconBadges(state, layer)\n        )\n    }\n}\n\nclass SetFullNodeDatabase extends DesugaringStep<LayerConfigJson> {\n    constructor() {\n        super(\n            \"sets the fullNodeDatabase-bit if needed\",\n            [\"fullNodeDatabase\"],\n            \"SetFullNodeDatabase\"\n        )\n    }\n\n    convert(json: LayerConfigJson, context: ConversionContext): LayerConfigJson {\n        const needsSpecial =\n            json.tagRenderings?.some((tr) => {\n                if (typeof tr === \"string\") {\n                    return false\n                }\n                const specs = ValidationUtils.getSpecialVisualisations(<TagRenderingConfigJson>tr)\n                return specs?.some((sp) => sp.needsNodeDatabase)\n            }) ?? false\n        if (!needsSpecial) {\n            return json\n        }\n        context.debug(\"Layer \" + json.id + \" needs the fullNodeDatabase\")\n        return { ...json, fullNodeDatabase: true }\n    }\n}\n\nclass ExpandMarkerRenderings extends DesugaringStep<IconConfigJson> {\n    private readonly _layer: LayerConfigJson\n    private readonly _state: DesugaringContext\n\n    constructor(state: DesugaringContext, layer: LayerConfigJson) {\n        super(\n            \"Expands tagRenderings in the icons, if needed\",\n            [\"icon\", \"color\"],\n            \"ExpandMarkerRenderings\"\n        )\n        this._layer = layer\n        this._state = state\n    }\n\n    convert(json: IconConfigJson, context: ConversionContext): IconConfigJson {\n        const expander = new ExpandTagRendering(this._state, this._layer)\n        const result: IconConfigJson = { icon: undefined, color: undefined }\n        if (json.icon && json.icon[\"builtin\"]) {\n            result.icon = <MinimalTagRenderingConfigJson>(\n                expander.convert(<any>json.icon, context.enter(\"icon\"))[0]\n            )\n        } else {\n            result.icon = json.icon\n        }\n        if (json.color && json.color[\"builtin\"]) {\n            result.color = <MinimalTagRenderingConfigJson>(\n                expander.convert(<any>json.color, context.enter(\"color\"))[0]\n            )\n        } else {\n            result.color = json.color\n        }\n        return result\n    }\n}\n\nclass AddFavouriteBadges extends DesugaringStep<LayerConfigJson> {\n    constructor() {\n        super(\n            \"Adds the favourite heart to the title and the rendering badges\",\n            [],\n            \"AddFavouriteBadges\"\n        )\n    }\n\n    convert(json: LayerConfigJson, _: ConversionContext): LayerConfigJson {\n        if (json.source === \"special\" || json.source === \"special:library\") {\n            return json\n        }\n        const pr = json.pointRendering?.[0]\n        if (pr) {\n            pr.iconBadges ??= []\n            if (!pr.iconBadges.some((ti) => ti.if === \"_favourite=yes\")) {\n                pr.iconBadges.push({ if: \"_favourite=yes\", then: \"circle:white;heart:red\" })\n            }\n        }\n\n        return json\n    }\n}\n\nexport class AddRatingBadge extends DesugaringStep<LayerConfigJson> {\n    constructor() {\n        super(\n            \"Adds the 'rating'-element if a reviews-element is used in the tagRenderings\",\n            [\"titleIcons\"],\n            \"AddRatingBadge\"\n        )\n    }\n\n    convert(json: LayerConfigJson, _: ConversionContext): LayerConfigJson {\n        if (!json.tagRenderings) {\n            return json\n        }\n        if (json.titleIcons.some((ti) => ti === \"icons.rating\" || ti[\"id\"] === \"rating\")) {\n            // already added\n            return json\n        }\n        if (json.id === \"favourite\") {\n            // handled separately\n            return json\n        }\n\n        const specialVis: Exclude<RenderingSpecification, string>[] = <\n            Exclude<RenderingSpecification, string>[]\n        >ValidationUtils.getAllSpecialVisualisations(<any>json.tagRenderings).filter(\n            (rs) => typeof rs !== \"string\"\n        )\n        const funcs = new Set<string>(specialVis.map((rs) => rs.func.funcName))\n\n        if (funcs.has(\"list_reviews\")) {\n            ;(<(string | TagRenderingConfigJson)[]>json.titleIcons).push(\"icons.rating\")\n        }\n        return json\n    }\n}\n\nexport class AutoTitleIcon extends DesugaringStep<LayerConfigJson> {\n    constructor() {\n        super(\n            \"The auto-icon creates a (non-clickable) title icon based on a tagRendering which has icons\",\n            [\"titleIcons\"],\n            \"AutoTitleIcon\"\n        )\n    }\n\n    private createTitleIconsBasedOn(\n        tr: QuestionableTagRenderingConfigJson\n    ): TagRenderingConfigJson | undefined {\n        const mappings: { if: TagConfigJson; then: string }[] = tr.mappings\n            ?.filter((m) => m.icon !== undefined)\n            .map((m) => {\n                const path: string = typeof m.icon === \"string\" ? m.icon : m.icon.path\n                const img = `<img class=\"m-1 h-6 w-6 low-interaction rounded\" src='${path}'/>`\n                return { if: m.if, then: img }\n            })\n        if (!mappings || mappings.length === 0) {\n            return undefined\n        }\n        return <TagRenderingConfigJson>{\n            id: \"title_icon_auto_\" + tr.id,\n            mappings,\n        }\n    }\n\n    convert(json: LayerConfigJson, context: ConversionContext): LayerConfigJson {\n        json = { ...json }\n        json.titleIcons = [...json.titleIcons]\n\n        const allAutoIndex = json.titleIcons.indexOf(<any>\"auto:*\")\n        if (allAutoIndex >= 0) {\n            const generated = Utils.NoNull(\n                json.tagRenderings.map((tr) => {\n                    if (typeof tr === \"string\") {\n                        return undefined\n                    }\n                    return this.createTitleIconsBasedOn(<any>tr)\n                })\n            )\n            json.titleIcons.splice(allAutoIndex, 1, ...generated)\n            return json\n        }\n\n        for (let i = 0; i < json.titleIcons.length; i++) {\n            const titleIcon = json.titleIcons[i]\n            if (typeof titleIcon !== \"string\") {\n                continue\n            }\n            if (!titleIcon.startsWith(\"auto:\")) {\n                continue\n            }\n            const trId = titleIcon.substring(\"auto:\".length)\n            const tr = <QuestionableTagRenderingConfigJson>(\n                json.tagRenderings.find((tr) => tr[\"id\"] === trId)\n            )\n            if (tr === undefined) {\n                context.enters(\"titleIcons\", i).err(\"TagRendering with id \" + trId + \" not found\")\n                continue\n            }\n            const generated = this.createTitleIconsBasedOn(tr)\n\n            if (!generated) {\n                context\n                    .enters(\"titleIcons\", i)\n                    .warn(\n                        \"TagRendering with id \" +\n                            trId +\n                            \" does not have any icons, not generating an icon for this\"\n                    )\n                continue\n            }\n            json.titleIcons[i] = generated\n        }\n        return json\n    }\n}\n\nexport class PrepareLayer extends Fuse<LayerConfigJson> {\n    constructor(state: DesugaringContext) {\n        super(\n            \"Fully prepares and expands a layer for the LayerConfig.\",\n            new On(\"tagRenderings\", new Each(new RewriteSpecial())),\n            new On(\"tagRenderings\", new Concat(new ExpandRewrite()).andThenF(Utils.Flatten)),\n            new On(\"tagRenderings\", (layer) => new Concat(new ExpandTagRendering(state, layer))),\n            new On(\"tagRenderings\", new Each(new DetectInline())),\n            new AddQuestionBox(),\n            new AddEditingElements(state),\n            new SetFullNodeDatabase(),\n            new On<\n                (LineRenderingConfigJson | RewritableConfigJson<LineRenderingConfigJson>)[],\n                LayerConfigJson\n            >(\"lineRendering\", new Each(new ExpandRewrite()).andThenF(Utils.Flatten)),\n            new On<PointRenderingConfigJson[], LayerConfigJson>(\n                \"pointRendering\",\n                (layer) =>\n                    new Each(new On(\"marker\", new Each(new ExpandMarkerRenderings(state, layer))))\n            ),\n            new On<PointRenderingConfigJson[], LayerConfigJson>(\n                \"pointRendering\",\n                (layer) => new Each(new PreparePointRendering(state, layer))\n            ),\n            new SetDefault(\"titleIcons\", [\"icons.defaults\"]),\n            new AddRatingBadge(),\n            new AddFavouriteBadges(),\n            new AutoTitleIcon(),\n            new On(\n                \"titleIcons\",\n                (layer) =>\n                    new Concat(new ExpandTagRendering(state, layer, { noHardcodedStrings: true }))\n            ),\n            new ExpandFilter(state)\n        )\n    }\n}\n","import { Bypass, Conversion, DesugaringStep, Each, Fuse, On } from \"./Conversion\"\nimport { LayerConfigJson } from \"../Json/LayerConfigJson\"\nimport LayerConfig from \"../LayerConfig\"\nimport { Utils } from \"../../../Utils\"\nimport Constants from \"../../Constants\"\nimport { Translation } from \"../../../UI/i18n/Translation\"\nimport { LayoutConfigJson } from \"../Json/LayoutConfigJson\"\nimport LayoutConfig from \"../LayoutConfig\"\nimport { TagRenderingConfigJson } from \"../Json/TagRenderingConfigJson\"\nimport { TagUtils } from \"../../../Logic/Tags/TagUtils\"\nimport { ExtractImages } from \"./FixImages\"\nimport { And } from \"../../../Logic/Tags/And\"\nimport Translations from \"../../../UI/i18n/Translations\"\nimport FilterConfigJson from \"../Json/FilterConfigJson\"\nimport DeleteConfig from \"../DeleteConfig\"\nimport {\n    MappingConfigJson,\n    QuestionableTagRenderingConfigJson,\n} from \"../Json/QuestionableTagRenderingConfigJson\"\nimport Validators from \"../../../UI/InputElement/Validators\"\nimport TagRenderingConfig from \"../TagRenderingConfig\"\nimport { parse as parse_html } from \"node-html-parser\"\nimport PresetConfig from \"../PresetConfig\"\nimport { TagsFilter } from \"../../../Logic/Tags/TagsFilter\"\nimport { Translatable } from \"../Json/Translatable\"\nimport { ConversionContext } from \"./ConversionContext\"\nimport { AvailableRasterLayers } from \"../../RasterLayers\"\nimport PointRenderingConfigJson from \"../Json/PointRenderingConfigJson\"\n\nclass ValidateLanguageCompleteness extends DesugaringStep<LayoutConfig> {\n    private readonly _languages: string[]\n\n    constructor(...languages: string[]) {\n        super(\n            \"Checks that the given object is fully translated in the specified languages\",\n            [],\n            \"ValidateLanguageCompleteness\"\n        )\n        this._languages = languages ?? [\"en\"]\n    }\n\n    convert(obj: LayoutConfig, context: ConversionContext): LayoutConfig {\n        const origLayers = obj.layers\n        obj.layers = [...obj.layers].filter((l) => l[\"id\"] !== \"favourite\")\n        const translations = Translation.ExtractAllTranslationsFrom(obj)\n        for (const neededLanguage of this._languages) {\n            translations\n                .filter(\n                    (t) =>\n                        t.tr.translations[neededLanguage] === undefined &&\n                        t.tr.translations[\"*\"] === undefined\n                )\n                .forEach((missing) => {\n                    context\n                        .enter(missing.context.split(\".\"))\n                        .err(\n                            `The theme ${obj.id} should be translation-complete for ` +\n                                neededLanguage +\n                                \", but it lacks a translation for \" +\n                                missing.context +\n                                \".\\n\\tThe known translation is \" +\n                                missing.tr.textFor(\"en\")\n                        )\n                })\n        }\n        obj.layers = origLayers\n        return obj\n    }\n}\n\nexport class DoesImageExist extends DesugaringStep<string> {\n    private readonly _knownImagePaths: Set<string>\n    private readonly _ignore?: Set<string>\n    private readonly doesPathExist: (path: string) => boolean = undefined\n\n    constructor(\n        knownImagePaths: Set<string>,\n        checkExistsSync: (path: string) => boolean = undefined,\n        ignore?: Set<string>\n    ) {\n        super(\"Checks if an image exists\", [], \"DoesImageExist\")\n        this._ignore = ignore\n        this._knownImagePaths = knownImagePaths\n        this.doesPathExist = checkExistsSync\n    }\n\n    convert(image: string, context: ConversionContext): string {\n        if (this._ignore?.has(image)) {\n            return image\n        }\n\n        if (image.indexOf(\"{\") >= 0) {\n            context.debug(\"Ignoring image with { in the path: \" + image)\n            return image\n        }\n\n        if (image === \"assets/SocialImage.png\") {\n            return image\n        }\n        if (image.match(/[a-z]*/)) {\n            if (Constants.defaultPinIcons.indexOf(image) >= 0) {\n                // This is a builtin img, e.g. 'checkmark' or 'crosshair'\n                return image\n            }\n        }\n\n        if (image.startsWith(\"<\") && image.endsWith(\">\")) {\n            // This is probably HTML, you're on your own here\n            return image\n        }\n\n        if (!this._knownImagePaths.has(image)) {\n            if (this.doesPathExist === undefined) {\n                context.err(\n                    `Image with path ${image} not found or not attributed; it is used in ${context}`\n                )\n            } else if (!this.doesPathExist(image)) {\n                context.err(\n                    `Image with path ${image} does not exist.\\n     Check for typo's and missing directories in the path.`\n                )\n            } else {\n                context.err(\n                    `Image with path ${image} is not attributed (but it exists); execute 'npm run query:licenses' to add the license information and/or run 'npm run generate:licenses' to compile all the license info`\n                )\n            }\n        }\n        return image\n    }\n}\n\nexport class ValidateTheme extends DesugaringStep<LayoutConfigJson> {\n    private static readonly _availableLayers = AvailableRasterLayers.allIds()\n    /**\n     * The paths where this layer is originally saved. Triggers some extra checks\n     * @private\n     */\n    private readonly _path?: string\n    private readonly _isBuiltin: boolean\n    //private readonly _sharedTagRenderings: Map<string, any>\n    private readonly _validateImage: DesugaringStep<string>\n    private readonly _extractImages: ExtractImages = undefined\n\n    constructor(\n        doesImageExist: DoesImageExist,\n        path: string,\n        isBuiltin: boolean,\n        sharedTagRenderings?: Set<string>\n    ) {\n        super(\"Doesn't change anything, but emits warnings and errors\", [], \"ValidateTheme\")\n        this._validateImage = doesImageExist\n        this._path = path\n        this._isBuiltin = isBuiltin\n        if (sharedTagRenderings) {\n            this._extractImages = new ExtractImages(this._isBuiltin, sharedTagRenderings)\n        }\n    }\n\n    convert(json: LayoutConfigJson, context: ConversionContext): LayoutConfigJson {\n        const theme = new LayoutConfig(json, this._isBuiltin)\n        {\n            // Legacy format checks\n            if (this._isBuiltin) {\n                if (json[\"units\"] !== undefined) {\n                    context.err(\n                        \"The theme \" +\n                            json.id +\n                            \" has units defined - these should be defined on the layer instead. (Hint: use overrideAll: { '+units': ... }) \"\n                    )\n                }\n                if (json[\"roamingRenderings\"] !== undefined) {\n                    context.err(\n                        \"Theme \" +\n                            json.id +\n                            \" contains an old 'roamingRenderings'. Use an 'overrideAll' instead\"\n                    )\n                }\n            }\n        }\n        if (!json.title) {\n            context.enter(\"title\").err(`The theme ${json.id} does not have a title defined.`)\n        }\n        if (!json.icon) {\n            context.enter(\"icon\").err(\"A theme should have an icon\")\n        }\n        if (this._isBuiltin && this._extractImages !== undefined) {\n            // Check images: are they local, are the licenses there, is the theme icon square, ...\n            const images = this._extractImages.convert(json, context.inOperation(\"ValidateTheme\"))\n            const remoteImages = images.filter((img) => img.path.indexOf(\"http\") == 0)\n            for (const remoteImage of remoteImages) {\n                context.err(\n                    \"Found a remote image: \" +\n                        remoteImage.path +\n                        \" in theme \" +\n                        json.id +\n                        \", please download it.\"\n                )\n            }\n            for (const image of images) {\n                this._validateImage.convert(image.path, context.enters(image.context))\n            }\n        }\n\n        try {\n            if (this._isBuiltin) {\n                if (theme.id !== theme.id.toLowerCase()) {\n                    context.err(\"Theme ids should be in lowercase, but it is \" + theme.id)\n                }\n\n                const filename = this._path.substring(\n                    this._path.lastIndexOf(\"/\") + 1,\n                    this._path.length - 5\n                )\n                if (theme.id !== filename) {\n                    context.err(\n                        \"Theme ids should be the same as the name.json, but we got id: \" +\n                            theme.id +\n                            \" and filename \" +\n                            filename +\n                            \" (\" +\n                            this._path +\n                            \")\"\n                    )\n                }\n                this._validateImage.convert(theme.icon, context.enter(\"icon\"))\n            }\n            const dups = Utils.Duplicates(json.layers.map((layer) => layer[\"id\"]))\n            if (dups.length > 0) {\n                context.err(\n                    `The theme ${json.id} defines multiple layers with id ${dups.join(\", \")}`\n                )\n            }\n            if (json[\"mustHaveLanguage\"] !== undefined) {\n                new ValidateLanguageCompleteness(...json[\"mustHaveLanguage\"]).convert(\n                    theme,\n                    context\n                )\n            }\n            if (!json.hideFromOverview && theme.id !== \"personal\" && this._isBuiltin) {\n                // The first key in the the title-field must be english, otherwise the title in the loading page will be the different language\n                const targetLanguage = theme.title.SupportedLanguages()[0]\n                if (targetLanguage !== \"en\") {\n                    context.err(\n                        `TargetLanguage is not 'en' for public theme ${theme.id}, it is ${targetLanguage}. Move 'en' up in the title of the theme and set it as the first key`\n                    )\n                }\n\n                // Official, public themes must have a full english translation\n                new ValidateLanguageCompleteness(\"en\").convert(theme, context)\n            }\n        } catch (e) {\n            console.error(e)\n            context.err(\"Could not validate the theme due to: \" + e)\n        }\n\n        if (theme.id !== \"personal\") {\n            new DetectDuplicatePresets().convert(theme, context)\n        }\n\n        if (!theme.title) {\n            context.enter(\"title\").err(\"A theme must have a title\")\n        }\n\n        if (!theme.description) {\n            context.enter(\"description\").err(\"A theme must have a description\")\n        }\n\n        if (theme.overpassUrl && typeof theme.overpassUrl === \"string\") {\n            context\n                .enter(\"overpassUrl\")\n                .err(\"The overpassURL is a string, use a list of strings instead. Wrap it with [ ]\")\n        }\n\n        if (json.defaultBackgroundId) {\n            const backgroundId = json.defaultBackgroundId\n\n            const isCategory =\n                backgroundId === \"photo\" || backgroundId === \"map\" || backgroundId === \"osmbasedmap\"\n\n            if (!isCategory && !ValidateTheme._availableLayers.has(backgroundId)) {\n                const options = Array.from(ValidateTheme._availableLayers)\n                const nearby = Utils.sortedByLevenshteinDistance(backgroundId, options, (t) => t)\n                context\n                    .enter(\"defaultBackgroundId\")\n                    .err(\n                        `This layer ID is not known: ${backgroundId}. Perhaps you meant one of ${nearby\n                            .slice(0, 5)\n                            .join(\", \")}`\n                    )\n            }\n        }\n\n        for (let i = 0; i < theme.layers.length; i++) {\n            const layer = theme.layers[i]\n            if (!layer.id.match(\"[a-z][a-z0-9_]*\")) {\n                context\n                    .enters(\"layers\", i, \"id\")\n                    .err(\"Invalid ID:\" + layer.id + \"should match [a-z][a-z0-9_]*\")\n            }\n        }\n\n        return json\n    }\n}\n\nexport class ValidateThemeAndLayers extends Fuse<LayoutConfigJson> {\n    constructor(\n        doesImageExist: DoesImageExist,\n        path: string,\n        isBuiltin: boolean,\n        sharedTagRenderings?: Set<string>\n    ) {\n        super(\n            \"Validates a theme and the contained layers\",\n            new ValidateTheme(doesImageExist, path, isBuiltin, sharedTagRenderings),\n            new On(\n                \"layers\",\n                new Each(\n                    new Bypass(\n                        (layer) => Constants.added_by_default.indexOf(<any>layer.id) < 0,\n                        new ValidateLayerConfig(undefined, isBuiltin, doesImageExist, false, true)\n                    )\n                )\n            )\n        )\n    }\n}\n\nclass OverrideShadowingCheck extends DesugaringStep<LayoutConfigJson> {\n    constructor() {\n        super(\n            \"Checks that an 'overrideAll' does not override a single override\",\n            [],\n            \"OverrideShadowingCheck\"\n        )\n    }\n\n    convert(json: LayoutConfigJson, context: ConversionContext): LayoutConfigJson {\n        const overrideAll = json.overrideAll\n        if (overrideAll === undefined) {\n            return json\n        }\n\n        const withOverride = json.layers.filter((l) => l[\"override\"] !== undefined)\n\n        for (const layer of withOverride) {\n            for (const key in overrideAll) {\n                if (key.endsWith(\"+\") || key.startsWith(\"+\")) {\n                    // This key will _add_ to the list, not overwrite it - so no warning is needed\n                    continue\n                }\n                if (\n                    layer[\"override\"][key] !== undefined ||\n                    layer[\"override\"][\"=\" + key] !== undefined\n                ) {\n                    const w =\n                        \"The override of layer \" +\n                        JSON.stringify(layer[\"builtin\"]) +\n                        \" has a shadowed property: \" +\n                        key +\n                        \" is overriden by overrideAll of the theme\"\n                    context.err(w)\n                }\n            }\n        }\n\n        return json\n    }\n}\n\nclass MiscThemeChecks extends DesugaringStep<LayoutConfigJson> {\n    constructor() {\n        super(\"Miscelleanous checks on the theme\", [], \"MiscThemesChecks\")\n    }\n\n    convert(json: LayoutConfigJson, context: ConversionContext): LayoutConfigJson {\n        if (json.id !== \"personal\" && (json.layers === undefined || json.layers.length === 0)) {\n            context.err(\"The theme \" + json.id + \" has no 'layers' defined\")\n        }\n        if (json.socialImage === \"\") {\n            context.warn(\"Social image for theme \" + json.id + \" is the emtpy string\")\n        }\n        if (json[\"clustering\"]) {\n            context.warn(\"Obsolete field `clustering` is still around\")\n        }\n        {\n            for (let i = 0; i < json.layers.length; i++) {\n                const l = json.layers[i]\n                if (l[\"override\"]?.[\"source\"] === undefined) {\n                    continue\n                }\n                if (l[\"override\"]?.[\"source\"]?.[\"geoJson\"]) {\n                    continue // We don't care about external data as we won't cache it anyway\n                }\n                if (l[\"override\"][\"id\"] !== undefined) {\n                    continue\n                }\n                context\n                    .enters(\"layers\", i)\n                    .err(\"A layer which changes the source-tags must also change the ID\")\n            }\n        }\n\n        if (json[\"overideAll\"]) {\n            context\n                .enter(\"overideAll\")\n                .err(\n                    \"'overrideAll' is spelled with _two_ `r`s. You only wrote a single one of them.\"\n                )\n        }\n        return json\n    }\n}\n\nexport class PrevalidateTheme extends Fuse<LayoutConfigJson> {\n    constructor() {\n        super(\n            \"Various consistency checks on the raw JSON\",\n            new MiscThemeChecks(),\n            new OverrideShadowingCheck()\n        )\n    }\n}\n\nexport class DetectConflictingAddExtraTags extends DesugaringStep<TagRenderingConfigJson> {\n    constructor() {\n        super(\n            \"The `if`-part in a mapping might set some keys. Those keys are not allowed to be set in the `addExtraTags`, as this might result in conflicting values\",\n            [],\n            \"DetectConflictingAddExtraTags\"\n        )\n    }\n\n    convert(json: TagRenderingConfigJson, context: ConversionContext): TagRenderingConfigJson {\n        if (!(json.mappings?.length > 0)) {\n            return json\n        }\n\n        try {\n            const tagRendering = new TagRenderingConfig(json, context.path.join(\".\"))\n\n            for (let i = 0; i < tagRendering.mappings.length; i++) {\n                const mapping = tagRendering.mappings[i]\n                if (!mapping.addExtraTags) {\n                    continue\n                }\n                const keysInMapping = new Set(mapping.if.usedKeys())\n\n                const keysInAddExtraTags = mapping.addExtraTags.map((t) => t.key)\n\n                const duplicateKeys = keysInAddExtraTags.filter((k) => keysInMapping.has(k))\n                if (duplicateKeys.length > 0) {\n                    context\n                        .enters(\"mappings\", i)\n                        .err(\n                            \"AddExtraTags overrides a key that is set in the `if`-clause of this mapping. Selecting this answer might thus first set one value (needed to match as answer) and then override it with a different value, resulting in an unsaveable question. The offending `addExtraTags` is \" +\n                                duplicateKeys.join(\", \")\n                        )\n                }\n            }\n\n            return json\n        } catch (e) {\n            context.err(\"Could not check for conflicting extra tags due to: \" + e)\n            return undefined\n        }\n    }\n}\n\nexport class DetectNonErasedKeysInMappings extends DesugaringStep<QuestionableTagRenderingConfigJson> {\n    constructor() {\n        super(\n            \"A tagRendering might set a freeform key (e.g. `name` and have an option that _should_ erase this name, e.g. `noname=yes`). Under normal circumstances, every mapping/freeform should affect all touched keys\",\n            [],\n            \"DetectNonErasedKeysInMappings\"\n        )\n    }\n\n    convert(\n        json: QuestionableTagRenderingConfigJson,\n        context: ConversionContext\n    ): QuestionableTagRenderingConfigJson {\n        if (json.multiAnswer) {\n            // No need to check this here, this has its own validation\n            return json\n        }\n        if (!json.question) {\n            // No need to check the writable tags, as this cannot write\n            return json\n        }\n\n        function addAll(keys: { forEach: (f: (s: string) => void) => void }, addTo: Set<string>) {\n            keys?.forEach((k) => addTo.add(k))\n        }\n\n        const freeformKeys: Set<string> = new Set()\n        if (json.freeform) {\n            freeformKeys.add(json.freeform.key)\n            for (const tag of json.freeform.addExtraTags ?? []) {\n                const tagParsed = TagUtils.Tag(tag)\n                addAll(tagParsed.usedKeys(), freeformKeys)\n            }\n        }\n\n        const mappingKeys: Set<string>[] = []\n        for (const mapping of json.mappings ?? []) {\n            if (mapping.hideInAnswer === true) {\n                mappingKeys.push(undefined)\n                continue\n            }\n            const thisMappingKeys: Set<string> = new Set<string>()\n            addAll(TagUtils.Tag(mapping.if).usedKeys(), thisMappingKeys)\n            for (const tag of mapping.addExtraTags ?? []) {\n                addAll(TagUtils.Tag(tag).usedKeys(), thisMappingKeys)\n            }\n            mappingKeys.push(thisMappingKeys)\n        }\n\n        const neededKeys = new Set<string>()\n\n        addAll(freeformKeys, neededKeys)\n        for (const mappingKey of mappingKeys) {\n            addAll(mappingKey, neededKeys)\n        }\n\n        neededKeys.delete(\"fixme\") // fixme gets a free pass\n\n        if (json.freeform) {\n            for (const neededKey of neededKeys) {\n                if (!freeformKeys.has(neededKey)) {\n                    context\n                        .enters(\"freeform\")\n                        .warn(\n                            \"The freeform block does not modify the key `\" +\n                                neededKey +\n                                \"` which is set in a mapping. Use `addExtraTags` to overwrite it\"\n                        )\n                }\n            }\n        }\n\n        for (let i = 0; i < json.mappings?.length; i++) {\n            const mapping = json.mappings[i]\n            if (mapping.hideInAnswer === true) {\n                continue\n            }\n            const keys = mappingKeys[i]\n            for (const neededKey of neededKeys) {\n                if (!keys.has(neededKey)) {\n                    context\n                        .enters(\"mappings\", i)\n                        .warn(\n                            \"This mapping does not modify the key `\" +\n                                neededKey +\n                                \"` which is set in a mapping or by the freeform block. Use `addExtraTags` to overwrite it\"\n                        )\n                }\n            }\n        }\n\n        return json\n    }\n}\n\nexport class DetectShadowedMappings extends DesugaringStep<TagRenderingConfigJson> {\n    private readonly _calculatedTagNames: string[]\n\n    constructor(layerConfig?: LayerConfigJson) {\n        super(\"Checks that the mappings don't shadow each other\", [], \"DetectShadowedMappings\")\n        this._calculatedTagNames = DetectShadowedMappings.extractCalculatedTagNames(layerConfig)\n    }\n\n    /**\n     *\n     * DetectShadowedMappings.extractCalculatedTagNames({calculatedTags: [\"_abc:=js()\"]}) // => [\"_abc\"]\n     * DetectShadowedMappings.extractCalculatedTagNames({calculatedTags: [\"_abc=js()\"]}) // => [\"_abc\"]\n     */\n    private static extractCalculatedTagNames(\n        layerConfig?: LayerConfigJson | { calculatedTags: string[] }\n    ) {\n        return (\n            layerConfig?.calculatedTags?.map((ct) => {\n                if (ct.indexOf(\":=\") >= 0) {\n                    return ct.split(\":=\")[0]\n                }\n                return ct.split(\"=\")[0]\n            }) ?? []\n        )\n    }\n\n    /**\n     *\n     * // should detect a simple shadowed mapping\n     * const tr = {mappings: [\n     *            {\n     *                if: {or: [\"key=value\", \"x=y\"]},\n     *                then: \"Case A\"\n     *            },\n     *            {\n     *                if: \"key=value\",\n     *                then: \"Shadowed\"\n     *            }\n     *        ]\n     *    }\n     * const context = ConversionContext.test()\n     * const r = new DetectShadowedMappings().convert(tr, context);\n     * context.getAll(\"error\").length // => 1\n     * context.getAll(\"error\")[0].message.indexOf(\"The mapping key=value is fully matched by a previous mapping (namely 0)\") >= 0 // => true\n     *\n     * const tr = {mappings: [\n     *         {\n     *             if: {or: [\"key=value\", \"x=y\"]},\n     *             then: \"Case A\"\n     *         },\n     *         {\n     *             if: {and: [\"key=value\", \"x=y\"]},\n     *             then: \"Shadowed\"\n     *         }\n     *     ]\n     * }\n     * const context = ConversionContext.test()\n     * const r = new DetectShadowedMappings().convert(tr, context);\n     * context.getAll(\"error\").length // => 1\n     * context.getAll(\"error\")[0].message.indexOf(\"The mapping key=value & x=y is fully matched by a previous mapping (namely 0)\") >= 0 // => true\n     */\n    convert(json: TagRenderingConfigJson, context: ConversionContext): TagRenderingConfigJson {\n        if (json.mappings === undefined || json.mappings.length === 0) {\n            return json\n        }\n        const defaultProperties = {}\n        for (const calculatedTagName of this._calculatedTagNames) {\n            defaultProperties[calculatedTagName] =\n                \"some_calculated_tag_value_for_\" + calculatedTagName\n        }\n        const parsedConditions = json.mappings.map((m, i) => {\n            const c = context.enters(\"mappings\", i)\n            const ifTags = TagUtils.Tag(m.if, c.enter(\"if\"))\n            const hideInAnswer = m[\"hideInAnswer\"]\n            if (hideInAnswer !== undefined && hideInAnswer !== false && hideInAnswer !== true) {\n                const conditionTags = TagUtils.Tag(hideInAnswer)\n                // Merge the condition too!\n                return new And([conditionTags, ifTags])\n            }\n            return ifTags\n        })\n        for (let i = 0; i < json.mappings.length; i++) {\n            if (!parsedConditions[i]?.isUsableAsAnswer()) {\n                // There is no straightforward way to convert this mapping.if into a properties-object, so we simply skip this one\n                // Yes, it might be shadowed, but running this check is to difficult right now\n                continue\n            }\n            const keyValues = parsedConditions[i].asChange(defaultProperties)\n            const properties = {}\n            keyValues.forEach(({ k, v }) => {\n                properties[k] = v\n            })\n            for (let j = 0; j < i; j++) {\n                const doesMatch = parsedConditions[j].matchesProperties(properties)\n                if (\n                    doesMatch &&\n                    json.mappings[j][\"hideInAnswer\"] === true &&\n                    json.mappings[i][\"hideInAnswer\"] !== true\n                ) {\n                    context.warn(\n                        `Mapping ${i} is shadowed by mapping ${j}. However, mapping ${j} has 'hideInAnswer' set, which will result in a different rendering in question-mode.`\n                    )\n                } else if (doesMatch) {\n                    // The current mapping is shadowed!\n                    context.err(`Mapping ${i} is shadowed by mapping ${j} and will thus never be shown:\n    The mapping ${parsedConditions[i].asHumanString(\n        false,\n        false,\n        {}\n    )} is fully matched by a previous mapping (namely ${j}), which matches:\n    ${parsedConditions[j].asHumanString(false, false, {})}.\n\n    To fix this problem, you can try to:\n    - Move the shadowed mapping up\n    - Do you want to use a different text in 'question mode'? Add 'hideInAnswer=true' to the first mapping\n    - Use \"addExtraTags\": [\"key=value\", ...] in order to avoid a different rendering\n         (e.g. [{\"if\": \"fee=no\",                     \"then\": \"Free to use\", \"hideInAnswer\":true},\n                {\"if\": {\"and\":[\"fee=no\",\"charge=\"]}, \"then\": \"Free to use\"}]\n          can be replaced by\n               [{\"if\":\"fee=no\", \"then\": \"Free to use\", \"addExtraTags\": [\"charge=\"]}]\n`)\n                }\n            }\n        }\n\n        return json\n    }\n}\n\nexport class DetectMappingsWithImages extends DesugaringStep<TagRenderingConfigJson> {\n    private readonly _doesImageExist: DoesImageExist\n\n    constructor(doesImageExist: DoesImageExist) {\n        super(\n            \"Checks that 'then'clauses in mappings don't have images, but use 'icon' instead\",\n            [],\n            \"DetectMappingsWithImages\"\n        )\n        this._doesImageExist = doesImageExist\n    }\n\n    /**\n     * const context = ConversionContext.test()\n     * const r = new DetectMappingsWithImages(new DoesImageExist(new Set<string>())).convert({\n     *     \"mappings\": [\n     *         {\n     *             \"if\": \"bicycle_parking=stands\",\n     *             \"then\": {\n     *                 \"en\": \"Staple racks <img style='width: 25%' src='./assets/layers/bike_parking/staple.svg'>\",\n     *                 \"nl\": \"Nietjes <img style='width: 25%'' src='./assets/layers/bike_parking/staple.svg'>\",\n     *                 \"fr\": \"Arceaux <img style='width: 25%'' src='./assets/layers/bike_parking/staple.svg'>\",\n     *                 \"gl\": \"De roda (Stands) <img style='width: 25%'' src='./assets/layers/bike_parking/staple.svg'>\",\n     *                 \"de\": \"Fahrradbgel <img style='width: 25%'' src='./assets/layers/bike_parking/staple.svg'>\",\n     *                 \"hu\": \"Korlt <img style='width: 25%' src='./assets/layers/bike_parking/staple.svg'>\",\n     *                 \"it\": \"Archetti <img style='width: 25%' src='./assets/layers/bike_parking/staple.svg'>\",\n     *                 \"zh_Hant\": \" <img style='width: 25%' src='./assets/layers/bike_parking/staple.svg'>\"\n     *             }\n     *         }]\n     * }, context);\n     * context.hasErrors() // => true\n     * context.getAll(\"error\").some(msg => msg.message.indexOf(\"./assets/layers/bike_parking/staple.svg\") >= 0) // => true\n     */\n    convert(json: TagRenderingConfigJson, context: ConversionContext): TagRenderingConfigJson {\n        if (json.mappings === undefined || json.mappings.length === 0) {\n            return json\n        }\n        const ignoreToken = \"ignore-image-in-then\"\n        for (let i = 0; i < json.mappings.length; i++) {\n            const mapping = json.mappings[i]\n            const ignore = mapping[\"#\"]?.indexOf(ignoreToken) >= 0\n            const images = Utils.Dedup(Translations.T(mapping.then)?.ExtractImages() ?? [])\n            const ctx = context.enters(\"mappings\", i)\n            if (images.length > 0) {\n                if (!ignore) {\n                    ctx.err(\n                        `A mapping has an image in the 'then'-clause. Remove the image there and use \\`\"icon\": <your-image>\\` instead. The images found are ${images.join(\n                            \", \"\n                        )}. (This check can be turned of by adding \"#\": \"${ignoreToken}\" in the mapping, but this is discouraged`\n                    )\n                } else {\n                    ctx.info(\n                        `Ignored image ${images.join(\n                            \", \"\n                        )} in 'then'-clause of a mapping as this check has been disabled`\n                    )\n\n                    for (const image of images) {\n                        this._doesImageExist.convert(image, ctx)\n                    }\n                }\n            } else if (ignore) {\n                ctx.warn(`Unused '${ignoreToken}' - please remove this`)\n            }\n        }\n\n        return json\n    }\n}\n\nclass ValidatePossibleLinks extends DesugaringStep<string | Record<string, string>> {\n    constructor() {\n        super(\n            \"Given a possible set of translations, validates that <a href=... target='_blank'> does have `rel='noopener'` set\",\n            [],\n            \"ValidatePossibleLinks\"\n        )\n    }\n\n    public isTabnabbingProne(str: string): boolean {\n        const p = parse_html(str)\n        const links = Array.from(p.getElementsByTagName(\"a\"))\n        if (links.length == 0) {\n            return false\n        }\n        for (const link of Array.from(links)) {\n            if (link.getAttribute(\"target\") !== \"_blank\") {\n                continue\n            }\n            const rel = new Set<string>(link.getAttribute(\"rel\")?.split(\" \") ?? [])\n            if (rel.has(\"noopener\")) {\n                continue\n            }\n            const source = link.getAttribute(\"href\")\n            if (source.startsWith(\"http\")) {\n                // No variable part - we assume the link is safe\n                continue\n            }\n            return true\n        }\n        return false\n    }\n\n    convert(\n        json: string | Record<string, string>,\n        context: ConversionContext\n    ): string | Record<string, string> {\n        if (typeof json === \"string\") {\n            if (this.isTabnabbingProne(json)) {\n                context.err(\n                    \"The string \" +\n                        json +\n                        \" has a link targeting `_blank`, but it doesn't have `rel='noopener'` set. This gives rise to reverse tabnapping\"\n                )\n            }\n        } else {\n            for (const k in json) {\n                if (this.isTabnabbingProne(json[k])) {\n                    context.err(\n                        `The translation for ${k} '${json[k]}' has a link targeting \\`_blank\\`, but it doesn't have \\`rel='noopener'\\` set. This gives rise to reverse tabnapping`\n                    )\n                }\n            }\n        }\n        return json\n    }\n}\n\nclass CheckTranslation extends DesugaringStep<Translatable> {\n    public static readonly allowUndefined: CheckTranslation = new CheckTranslation(true)\n    public static readonly noUndefined: CheckTranslation = new CheckTranslation()\n    private readonly _allowUndefined: boolean\n\n    constructor(allowUndefined: boolean = false) {\n        super(\n            \"Checks that a translation is valid and internally consistent\",\n            [\"*\"],\n            \"CheckTranslation\"\n        )\n        this._allowUndefined = allowUndefined\n    }\n\n    convert(json: Translatable, context: ConversionContext): Translatable {\n        if (json === undefined || json === null) {\n            if (!this._allowUndefined) {\n                context.err(\"Expected a translation, but got \" + json)\n            }\n            return json\n        }\n        if (typeof json === \"string\") {\n            return json\n        }\n        const keys = Object.keys(json)\n        if (keys.length === 0) {\n            context.err(\"No actual values are given in this translation, it is completely empty\")\n            return json\n        }\n        const en = json[\"en\"]\n        if (!en && json[\"*\"] === undefined) {\n            const msg = \"Received a translation without english version\"\n            context.warn(msg)\n        }\n\n        for (const key of keys) {\n            const lng = json[key]\n            if (lng === \"\") {\n                context.enter(lng).err(\"Got an empty string in translation for language \" + key)\n            }\n\n            // TODO validate that all subparts are here\n        }\n\n        return json\n    }\n}\n\nclass MiscTagRenderingChecks extends DesugaringStep<TagRenderingConfigJson> {\n    constructor() {\n        super(\"Miscellaneous checks on the tagrendering\", [\"special\"], \"MiscTagRenderingChecks\")\n    }\n\n    convert(\n        json: TagRenderingConfigJson | QuestionableTagRenderingConfigJson,\n        context: ConversionContext\n    ): TagRenderingConfigJson {\n        if (json[\"special\"] !== undefined) {\n            context.err(\n                'Detected `special` on the top level. Did you mean `{\"render\":{ \"special\": ... }}`'\n            )\n        }\n\n        if (Object.keys(json).length === 1 && typeof json[\"render\"] === \"string\") {\n            context.warn(\n                `use the content directly instead of {render: ${JSON.stringify(json[\"render\"])}}`\n            )\n        }\n\n        {\n            for (const key of [\"question\", \"questionHint\", \"render\"]) {\n                CheckTranslation.allowUndefined.convert(json[key], context.enter(key))\n            }\n            for (let i = 0; i < json.mappings?.length ?? 0; i++) {\n                const mapping: MappingConfigJson = json.mappings[i]\n                CheckTranslation.noUndefined.convert(\n                    mapping.then,\n                    context.enters(\"mappings\", i, \"then\")\n                )\n                if (!mapping.if) {\n                    console.log(\n                        \"Checking mappings\",\n                        i,\n                        \"if\",\n                        mapping.if,\n                        context.path.join(\".\"),\n                        mapping.then\n                    )\n                    context.enters(\"mappings\", i, \"if\").err(\"No `if` is defined\")\n                }\n                if (mapping.addExtraTags) {\n                    for (let j = 0; j < mapping.addExtraTags.length; j++) {\n                        if (!mapping.addExtraTags[j]) {\n                            context\n                                .enters(\"mappings\", i, \"addExtraTags\", j)\n                                .err(\n                                    \"Detected a 'null' or 'undefined' value. Either specify a tag or delete this item\"\n                                )\n                        }\n                    }\n                }\n                const en = mapping?.then?.[\"en\"]\n                if (en && this.detectYesOrNo(en)) {\n                    console.log(\"Found a match with yes or no: \", { en })\n                    context\n                        .enters(\"mappings\", i, \"then\")\n                        .warn(\n                            \"A mapping should not start with 'yes' or 'no'. If the attribute is known, it will only show 'yes' or 'no' <i>without</i> the question, resulting in a weird phrasing in the information box\"\n                        )\n                }\n            }\n        }\n        if (json[\"group\"]) {\n            context.err('Groups are deprecated, use `\"label\": [\"' + json[\"group\"] + '\"]` instead')\n        }\n\n        if (json[\"question\"] && json.freeform?.key === undefined && json.mappings === undefined) {\n            context.err(\n                \"A question is defined, but no mappings nor freeform (key) are. Add at least one of them\"\n            )\n        }\n        if (json[\"question\"] && !json.freeform && (json.mappings?.length ?? 0) == 1) {\n            context.err(\"A question is defined, but there is only one option to choose from.\")\n        }\n        if (json[\"questionHint\"] && !json[\"question\"]) {\n            context\n                .enter(\"questionHint\")\n                .err(\n                    \"A questionHint is defined, but no question is given. As such, the questionHint will never be shown\"\n                )\n        }\n\n        if (json.icon?.[\"size\"]) {\n            context\n                .enters(\"icon\", \"size\")\n                .err(\n                    \"size is not a valid attribute. Did you mean 'class'? Class can be one of `small`, `medium` or `large`\"\n                )\n        }\n\n        if (json.freeform) {\n            if (json.render === undefined) {\n                context\n                    .enter(\"render\")\n                    .err(\n                        \"This tagRendering allows to set a value to key \" +\n                            json.freeform.key +\n                            \", but does not define a `render`. Please, add a value here which contains `{\" +\n                            json.freeform.key +\n                            \"}`\"\n                    )\n            } else {\n                const render = new Translation(<any>json.render)\n                for (const ln in render.translations) {\n                    if (ln.startsWith(\"_\")) {\n                        continue\n                    }\n                    const txt: string = render.translations[ln]\n                    if (txt === \"\") {\n                        context.enter(\"render\").err(\" Rendering for language \" + ln + \" is empty\")\n                    }\n                    if (\n                        txt.indexOf(\"{\" + json.freeform.key + \"}\") >= 0 ||\n                        txt.indexOf(\"&LBRACE\" + json.freeform.key + \"&RBRACE\") >= 0\n                    ) {\n                        continue\n                    }\n                    if (txt.indexOf(\"{\" + json.freeform.key + \":\") >= 0) {\n                        continue\n                    }\n\n                    if (\n                        json.freeform[\"type\"] === \"opening_hours\" &&\n                        txt.indexOf(\"{opening_hours_table(\") >= 0\n                    ) {\n                        continue\n                    }\n                    const keyFirstArg = [\"canonical\", \"fediverse_link\", \"translated\"]\n                    if (\n                        keyFirstArg.some(\n                            (funcName) => txt.indexOf(`{${funcName}(${json.freeform.key}`) >= 0\n                        )\n                    ) {\n                        continue\n                    }\n                    if (\n                        json.freeform[\"type\"] === \"wikidata\" &&\n                        txt.indexOf(\"{wikipedia(\" + json.freeform.key) >= 0\n                    ) {\n                        continue\n                    }\n                    if (json.freeform.key === \"wikidata\" && txt.indexOf(\"{wikipedia()\") >= 0) {\n                        continue\n                    }\n                    if (\n                        json.freeform[\"type\"] === \"wikidata\" &&\n                        txt.indexOf(`{wikidata_label(${json.freeform.key})`) >= 0\n                    ) {\n                        continue\n                    }\n                    if (json.freeform.key.indexOf(\"wikidata\") >= 0) {\n                        context\n                            .enter(\"render\")\n                            .err(\n                                `The rendering for language ${ln} does not contain \\`{${json.freeform.key}}\\`. Did you perhaps forget to set \"freeform.type: 'wikidata'\"?`\n                            )\n                    }\n                    context\n                        .enter(\"render\")\n                        .err(\n                            `The rendering for language ${ln} does not contain \\`{${json.freeform.key}}\\`. This is a bug, as this rendering should show exactly this freeform key!`\n                        )\n                }\n            }\n        }\n        if (json.render && json[\"question\"] && json.freeform === undefined) {\n            context.err(\n                `Detected a tagrendering which takes input without freeform key in ${context}; the question is ${new Translation(\n                    json[\"question\"]\n                ).textFor(\"en\")}`\n            )\n        }\n\n        const freeformType = json[\"freeform\"]?.[\"type\"]\n        if (freeformType) {\n            if (Validators.availableTypes.indexOf(freeformType) < 0) {\n                context\n                    .enters(\"freeform\", \"type\")\n                    .err(\n                        \"Unknown type: \" +\n                            freeformType +\n                            \"; try one of \" +\n                            Validators.availableTypes.join(\", \")\n                    )\n            }\n        }\n\n        if (context.hasErrors()) {\n            return undefined\n        }\n        return json\n    }\n\n    /**\n     * const obj = new MiscTagRenderingChecks()\n     * obj.detectYesOrNo(\"Yes, this place has\") // => true\n     * obj.detectYesOrNo(\"Yes\") // => true\n     * obj.detectYesOrNo(\"No, this place does not have...\") // => true\n     * obj.detectYesOrNo(\"This place does not have...\") // => false\n     */\n    private detectYesOrNo(en: string): boolean {\n        return en.toLowerCase().match(/^(yes|no)([,:;.?]|$)/) !== null\n    }\n}\n\nexport class ValidateTagRenderings extends Fuse<TagRenderingConfigJson> {\n    constructor(layerConfig?: LayerConfigJson, doesImageExist?: DoesImageExist) {\n        super(\n            \"Various validation on tagRenderingConfigs\",\n            new MiscTagRenderingChecks(),\n            new DetectShadowedMappings(layerConfig),\n            new DetectConflictingAddExtraTags(),\n            // TODO enable   new DetectNonErasedKeysInMappings(),\n            new DetectMappingsWithImages(doesImageExist),\n            new On(\"render\", new ValidatePossibleLinks()),\n            new On(\"question\", new ValidatePossibleLinks()),\n            new On(\"questionHint\", new ValidatePossibleLinks()),\n            new On(\"mappings\", new Each(new On(\"then\", new ValidatePossibleLinks()))),\n            new MiscTagRenderingChecks()\n        )\n    }\n}\n\nexport class PrevalidateLayer extends DesugaringStep<LayerConfigJson> {\n    private readonly _isBuiltin: boolean\n    private readonly _doesImageExist: DoesImageExist\n    /**\n     * The paths where this layer is originally saved. Triggers some extra checks\n     */\n    private readonly _path: string\n    private readonly _studioValidations: boolean\n    private readonly _validatePointRendering = new ValidatePointRendering()\n\n    constructor(\n        path: string,\n        isBuiltin: boolean,\n        doesImageExist: DoesImageExist,\n        studioValidations: boolean\n    ) {\n        super(\"Runs various checks against common mistakes for a layer\", [], \"PrevalidateLayer\")\n        this._path = path\n        this._isBuiltin = isBuiltin\n        this._doesImageExist = doesImageExist\n        this._studioValidations = studioValidations\n    }\n\n    convert(json: LayerConfigJson, context: ConversionContext): LayerConfigJson {\n        if (json.id === undefined) {\n            context.enter(\"id\").err(`Not a valid layer: id is undefined`)\n        } else {\n            if (json.id?.toLowerCase() !== json.id) {\n                context.enter(\"id\").err(`The id of a layer should be lowercase: ${json.id}`)\n            }\n            const layerRegex = /[a-zA-Z][a-zA-Z_0-9]+/\n            if (json.id.match(layerRegex) === null) {\n                context.enter(\"id\").err(\"Invalid ID. A layer ID should match \" + layerRegex.source)\n            }\n        }\n\n        if (json.source === undefined) {\n            context\n                .enter(\"source\")\n                .err(\n                    \"No source section is defined; please define one as data is not loaded otherwise\"\n                )\n        } else {\n            if (json.source === \"special\" || json.source === \"special:library\") {\n            } else if (json.source && json.source[\"osmTags\"] === undefined) {\n                context\n                    .enters(\"source\", \"osmTags\")\n                    .err(\n                        \"No osmTags defined in the source section - these should always be present, even for geojson layer\"\n                    )\n            } else {\n                const osmTags = TagUtils.Tag(json.source[\"osmTags\"], context + \"source.osmTags\")\n                if (osmTags.isNegative()) {\n                    context\n                        .enters(\"source\", \"osmTags\")\n                        .err(\n                            \"The source states tags which give a very wide selection: it only uses negative expressions, which will result in too much and unexpected data. Add at least one required tag. The tags are:\\n\\t\" +\n                                osmTags.asHumanString(false, false, {})\n                        )\n                }\n            }\n\n            if (json.source[\"geoJsonSource\"] !== undefined) {\n                context\n                    .enters(\"source\", \"geoJsonSource\")\n                    .err(\"Use 'geoJson' instead of 'geoJsonSource'\")\n            }\n\n            if (json.source[\"geojson\"] !== undefined) {\n                context\n                    .enters(\"source\", \"geojson\")\n                    .err(\"Use 'geoJson' instead of 'geojson' (the J is a capital letter)\")\n            }\n        }\n\n        if (\n            json.syncSelection !== undefined &&\n            LayerConfig.syncSelectionAllowed.indexOf(json.syncSelection) < 0\n        ) {\n            context\n                .enter(\"syncSelection\")\n                .err(\n                    \"Invalid sync-selection: must be one of \" +\n                        LayerConfig.syncSelectionAllowed.map((v) => `'${v}'`).join(\", \") +\n                        \" but got '\" +\n                        json.syncSelection +\n                        \"'\"\n                )\n        }\n        if (json[\"pointRenderings\"]?.length > 0) {\n            context\n                .enter(\"pointRenderings\")\n                .err(\"Detected a 'pointRenderingS', it is written singular\")\n        }\n\n        if (\n            !(json.pointRendering?.length > 0) &&\n            json.pointRendering !== null &&\n            json.source !== \"special\" &&\n            json.source !== \"special:library\"\n        ) {\n            context.enter(\"pointRendering\").err(\"There are no pointRenderings at all...\")\n        }\n\n        json.pointRendering?.forEach((pr, i) =>\n            this._validatePointRendering.convert(pr, context.enters(\"pointeRendering\", i))\n        )\n\n        if (json[\"mapRendering\"]) {\n            context.enter(\"mapRendering\").err(\"This layer has a legacy 'mapRendering'\")\n        }\n\n        if (json.presets?.length > 0) {\n            if (!(json.pointRendering?.length > 0)) {\n                context.enter(\"presets\").warn(\"A preset is defined, but there is no pointRendering\")\n            }\n        }\n\n        if (json.source === \"special\") {\n            if (!Constants.priviliged_layers.find((x) => x == json.id)) {\n                context.err(\n                    \"Layer \" +\n                        json.id +\n                        \" uses 'special' as source.osmTags. However, this layer is not a priviliged layer\"\n                )\n            }\n        }\n\n        if (context.hasErrors()) {\n            return undefined\n        }\n\n        if (json.tagRenderings !== undefined && json.tagRenderings.length > 0) {\n            new On(\"tagRenderings\", new Each(new ValidateTagRenderings(json)))\n            if (json.title === undefined && json.source !== \"special:library\") {\n                context\n                    .enter(\"title\")\n                    .err(\n                        \"This layer does not have a title defined but it does have tagRenderings. Not having a title will disable the popups, resulting in an unclickable element. Please add a title. If not having a popup is intended and the tagrenderings need to be kept (e.g. in a library layer), set `title: null` to disable this error.\"\n                    )\n            }\n            if (json.title === null) {\n                context.info(\n                    \"Title is `null`. This results in an element that cannot be clicked - even though tagRenderings is set.\"\n                )\n            }\n\n            {\n                // Check for multiple, identical builtin questions - usability for studio users\n                const duplicates = Utils.Duplicates(\n                    <string[]>json.tagRenderings.filter((tr) => typeof tr === \"string\")\n                )\n                for (let i = 0; i < json.tagRenderings.length; i++) {\n                    const tagRendering = json.tagRenderings[i]\n                    if (typeof tagRendering === \"string\" && duplicates.indexOf(tagRendering) > 0) {\n                        context\n                            .enters(\"tagRenderings\", i)\n                            .err(`This builtin question is used multiple times (${tagRendering})`)\n                    }\n                }\n            }\n        }\n\n        if (json[\"builtin\"] !== undefined) {\n            context.err(\"This layer hasn't been expanded: \" + json)\n            return null\n        }\n\n        if (json.minzoom > Constants.minZoomLevelToAddNewPoint) {\n            const c = context.enter(\"minzoom\")\n            const msg = `Minzoom is ${json.minzoom}, this should be at most ${Constants.minZoomLevelToAddNewPoint} as a preset is set. Why? Selecting the pin for a new item will zoom in to level before adding the point. Having a greater minzoom will hide the points, resulting in possible duplicates`\n            if (json.presets?.length > 0) {\n                c.err(msg)\n            } else {\n                c.warn(msg)\n            }\n        }\n        {\n            // duplicate ids in tagrenderings check\n            const duplicates = Utils.NoNull(\n                Utils.Duplicates(Utils.NoNull((json.tagRenderings ?? []).map((tr) => tr[\"id\"])))\n            )\n            if (duplicates.length > 0) {\n                // It is tempting to add an index to this warning; however, due to labels the indices here might be different from the index in the tagRendering list\n                context\n                    .enter(\"tagRenderings\")\n                    .err(\n                        \"Some tagrenderings have a duplicate id: \" +\n                            duplicates.join(\", \") +\n                            \"\\n\" +\n                            JSON.stringify(\n                                json.tagRenderings.filter((tr) => duplicates.indexOf(tr[\"id\"]) >= 0)\n                            )\n                    )\n            }\n        }\n\n        if (json.deletion !== undefined && json.deletion instanceof DeleteConfig) {\n            if (json.deletion.softDeletionTags === undefined) {\n                context\n                    .enter(\"deletion\")\n                    .warn(\"No soft-deletion tags in deletion block for layer \" + json.id)\n            }\n        }\n\n        try {\n        } catch (e) {\n            context.err(\"Could not validate layer due to: \" + e + e.stack)\n        }\n\n        if (this._studioValidations) {\n            if (!json.description) {\n                context.enter(\"description\").err(\"A description is required\")\n            }\n            if (!json.name) {\n                context.enter(\"name\").err(\"A name is required\")\n            }\n        }\n\n        if (this._isBuiltin) {\n            // Some checks for legacy elements\n\n            if (json[\"overpassTags\"] !== undefined) {\n                context.err(\n                    \"Layer \" +\n                        json.id +\n                        'still uses the old \\'overpassTags\\'-format. Please use \"source\": {\"osmTags\": <tags>}\\' instead of \"overpassTags\": <tags> (note: this isn\\'t your fault, the custom theme generator still spits out the old format)'\n                )\n            }\n            const forbiddenTopLevel = [\n                \"icon\",\n                \"wayHandling\",\n                \"roamingRenderings\",\n                \"roamingRendering\",\n                \"label\",\n                \"width\",\n                \"color\",\n                \"colour\",\n                \"iconOverlays\",\n            ]\n            for (const forbiddenKey of forbiddenTopLevel) {\n                if (json[forbiddenKey] !== undefined)\n                    context.err(\"Layer \" + json.id + \" still has a forbidden key \" + forbiddenKey)\n            }\n            if (json[\"hideUnderlayingFeaturesMinPercentage\"] !== undefined) {\n                context.err(\n                    \"Layer \" + json.id + \" contains an old 'hideUnderlayingFeaturesMinPercentage'\"\n                )\n            }\n\n            if (\n                json.isShown !== undefined &&\n                (json.isShown[\"render\"] !== undefined || json.isShown[\"mappings\"] !== undefined)\n            ) {\n                context.warn(\"Has a tagRendering as `isShown`\")\n            }\n        }\n        if (this._isBuiltin) {\n            // Check location of layer file\n            const expected: string = `assets/layers/${json.id}/${json.id}.json`\n            if (this._path != undefined && this._path.indexOf(expected) < 0) {\n                context.err(\n                    \"Layer is in an incorrect place. The path is \" +\n                        this._path +\n                        \", but expected \" +\n                        expected\n                )\n            }\n        }\n        if (this._isBuiltin) {\n            // Check for correct IDs\n            if (json.tagRenderings?.some((tr) => tr[\"id\"] === \"\")) {\n                const emptyIndexes: number[] = []\n                for (let i = 0; i < json.tagRenderings.length; i++) {\n                    const tagRendering = json.tagRenderings[i]\n                    if (tagRendering[\"id\"] === \"\") {\n                        emptyIndexes.push(i)\n                    }\n                }\n                context\n                    .enter([\"tagRenderings\", ...emptyIndexes])\n                    .err(\n                        `Some tagrendering-ids are empty or have an emtpy string; this is not allowed (at ${emptyIndexes.join(\n                            \",\"\n                        )}])`\n                    )\n            }\n\n            const duplicateIds = Utils.Duplicates(\n                (json.tagRenderings ?? [])?.map((f) => f[\"id\"]).filter((id) => id !== \"questions\")\n            )\n            if (duplicateIds.length > 0 && !Utils.runningFromConsole) {\n                context\n                    .enter(\"tagRenderings\")\n                    .err(`Some tagRenderings have a duplicate id: ${duplicateIds}`)\n            }\n\n            if (json.description === undefined) {\n                if (typeof json.source === null) {\n                    context.err(\"A priviliged layer must have a description\")\n                } else {\n                    context.warn(\"A builtin layer should have a description\")\n                }\n            }\n        }\n\n        if (json.filter) {\n            new On(\"filter\", new Each(new ValidateFilter())).convert(json, context)\n        }\n\n        if (json.tagRenderings !== undefined) {\n            new On(\n                \"tagRenderings\",\n                new Each(new ValidateTagRenderings(json, this._doesImageExist))\n            ).convert(json, context)\n        }\n\n        if (json.pointRendering !== null && json.pointRendering !== undefined) {\n            if (!Array.isArray(json.pointRendering)) {\n                throw (\n                    \"pointRendering in \" +\n                    json.id +\n                    \" is not iterable, it is: \" +\n                    typeof json.pointRendering\n                )\n            }\n            for (let i = 0; i < json.pointRendering.length; i++) {\n                const pointRendering = json.pointRendering[i]\n                if (pointRendering.marker === undefined) {\n                    continue\n                }\n                for (const icon of pointRendering?.marker) {\n                    const indexM = pointRendering?.marker.indexOf(icon)\n                    if (!icon.icon) {\n                        continue\n                    }\n                    if (icon.icon[\"condition\"]) {\n                        context\n                            .enters(\"pointRendering\", i, \"marker\", indexM, \"icon\", \"condition\")\n                            .err(\n                                \"Don't set a condition in a marker as this will result in an invisible but clickable element. Use extra filters in the source instead.\"\n                            )\n                    }\n                }\n            }\n        }\n\n        if (json.presets !== undefined) {\n            if (typeof json.source === \"string\") {\n                context.enter(\"presets\").err(\"A special layer cannot have presets\")\n            }\n            // Check that a preset will be picked up by the layer itself\n            const baseTags = TagUtils.Tag(json.source[\"osmTags\"])\n            for (let i = 0; i < json.presets.length; i++) {\n                const preset = json.presets[i]\n                if (!preset) {\n                    context.enters(\"presets\", i).err(\"This preset is undefined\")\n                    continue\n                }\n                if (!preset.tags) {\n                    context.enters(\"presets\", i, \"tags\").err(\"No tags defined for this preset\")\n                    continue\n                }\n                if (!preset.tags) {\n                    context.enters(\"presets\", i, \"title\").err(\"No title defined for this preset\")\n                }\n\n                const tags = new And(preset.tags.map((t) => TagUtils.Tag(t)))\n                const properties = {}\n                for (const tag of tags.asChange({ id: \"node/-1\" })) {\n                    properties[tag.k] = tag.v\n                }\n                const doMatch = baseTags.matchesProperties(properties)\n                if (!doMatch) {\n                    context\n                        .enters(\"presets\", i, \"tags\")\n                        .err(\n                            \"This preset does not match the required tags of this layer. This implies that a newly added point will not show up.\\n    A newly created point will have properties: \" +\n                                tags.asHumanString(false, false, {}) +\n                                \"\\n    The required tags are: \" +\n                                baseTags.asHumanString(false, false, {})\n                        )\n                }\n            }\n        }\n        return json\n    }\n}\n\nexport class ValidateLayerConfig extends DesugaringStep<LayerConfigJson> {\n    private readonly validator: ValidateLayer\n\n    constructor(\n        path: string,\n        isBuiltin: boolean,\n        doesImageExist: DoesImageExist,\n        studioValidations: boolean = false,\n        skipDefaultLayers: boolean = false\n    ) {\n        super(\"Thin wrapper around 'ValidateLayer\", [], \"ValidateLayerConfig\")\n        this.validator = new ValidateLayer(\n            path,\n            isBuiltin,\n            doesImageExist,\n            studioValidations,\n            skipDefaultLayers\n        )\n    }\n\n    convert(json: LayerConfigJson, context: ConversionContext): LayerConfigJson {\n        const prepared = this.validator.convert(json, context)\n        if (!prepared) {\n            context.err(\"Preparing layer failed\")\n            return undefined\n        }\n        return prepared?.raw\n    }\n}\n\nclass ValidatePointRendering extends DesugaringStep<PointRenderingConfigJson> {\n    constructor() {\n        super(\"Various checks for pointRenderings\", [], \"ValidatePOintRendering\")\n    }\n\n    convert(json: PointRenderingConfigJson, context: ConversionContext): PointRenderingConfigJson {\n        if (json.marker === undefined && json.label === undefined) {\n            context.err(`A point rendering should define at least an marker or a label`)\n        }\n\n        if (json[\"markers\"]) {\n            context\n                .enter(\"markers\")\n                .err(\n                    `Detected a field 'markerS' in pointRendering. It is written as a singular case`\n                )\n        }\n        if (json.marker && !Array.isArray(json.marker)) {\n            context.enter(\"marker\").err(\"The marker in a pointRendering should be an array\")\n        }\n        if (json.location.length == 0) {\n            context\n                .enter(\"location\")\n                .err(\n                    \"A pointRendering should have at least one 'location' to defined where it should be rendered. \"\n                )\n        }\n        return json\n    }\n}\n\nexport class ValidateLayer extends Conversion<\n    LayerConfigJson,\n    { parsed: LayerConfig; raw: LayerConfigJson }\n> {\n    private readonly _skipDefaultLayers: boolean\n    private readonly _prevalidation: PrevalidateLayer\n\n    constructor(\n        path: string,\n        isBuiltin: boolean,\n        doesImageExist: DoesImageExist,\n        studioValidations: boolean = false,\n        skipDefaultLayers: boolean = false\n    ) {\n        super(\"Doesn't change anything, but emits warnings and errors\", [], \"ValidateLayer\")\n        this._prevalidation = new PrevalidateLayer(\n            path,\n            isBuiltin,\n            doesImageExist,\n            studioValidations\n        )\n        this._skipDefaultLayers = skipDefaultLayers\n    }\n\n    convert(\n        json: LayerConfigJson,\n        context: ConversionContext\n    ): { parsed: LayerConfig; raw: LayerConfigJson } {\n        context = context.inOperation(this.name)\n        if (typeof json === \"string\") {\n            context.err(\n                `Not a valid layer: the layerConfig is a string. 'npm run generate:layeroverview' might be needed`\n            )\n            return undefined\n        }\n\n        if (this._skipDefaultLayers && Constants.added_by_default.indexOf(<any>json.id) >= 0) {\n            return { parsed: undefined, raw: json }\n        }\n\n        this._prevalidation.convert(json, context.inOperation(this._prevalidation.name))\n\n        if (context.hasErrors()) {\n            return undefined\n        }\n\n        let layerConfig: LayerConfig\n        try {\n            layerConfig = new LayerConfig(json, \"validation\", true)\n        } catch (e) {\n            context.err(\"Could not parse layer due to:\" + e)\n            return undefined\n        }\n\n        for (let i = 0; i < (layerConfig.calculatedTags ?? []).length; i++) {\n            const [_, code, __] = layerConfig.calculatedTags[i]\n            try {\n                new Function(\"feat\", \"return \" + code + \";\")\n            } catch (e) {\n                context\n                    .enters(\"calculatedTags\", i)\n                    .err(\n                        `Invalid function definition: the custom javascript is invalid:${e}. The offending javascript code is:\\n    ${code}`\n                    )\n            }\n        }\n\n        for (let i = 0; i < layerConfig.titleIcons.length; i++) {\n            const titleIcon = layerConfig.titleIcons[i]\n            if (<any>titleIcon.render === \"icons.defaults\") {\n                context.enters(\"titleIcons\", i).err(\"Detected a literal 'icons.defaults'\")\n            }\n            if (<any>titleIcon.render === \"icons.rating\") {\n                context.enters(\"titleIcons\", i).err(\"Detected a literal 'icons.rating'\")\n            }\n        }\n\n        for (let i = 0; i < json.presets?.length; i++) {\n            const preset = json.presets[i]\n            if (\n                preset.snapToLayer === undefined &&\n                preset.maxSnapDistance !== undefined &&\n                preset.maxSnapDistance !== null\n            ) {\n                context\n                    .enters(\"presets\", i, \"maxSnapDistance\")\n                    .err(\"A maxSnapDistance is given, but there is no layer given to snap to\")\n            }\n        }\n\n        if (json[\"doCount\"]) {\n            context.enters(\"doCount\").err(\"Use `isCounted` instead of `doCount`\")\n        }\n\n        if (json.source) {\n            const src = json.source\n            if (src[\"isOsmCache\"] !== undefined) {\n                context.enters(\"source\").err(\"isOsmCache is deprecated\")\n            }\n            if (src[\"maxCacheAge\"] !== undefined) {\n                context\n                    .enters(\"source\")\n                    .err(\"maxCacheAge is deprecated; it is \" + src[\"maxCacheAge\"])\n            }\n        }\n\n        if(json.allowMove?.[\"enableAccuraccy\"] !== undefined){\n            context.enters(\"allowMove\", \"enableAccuracy\").err(\"`enableAccuracy` is written with two C in the first occurrence and only one in the last\")\n        }\n\n        return { raw: json, parsed: layerConfig }\n    }\n}\n\nexport class ValidateFilter extends DesugaringStep<FilterConfigJson> {\n    constructor() {\n        super(\"Detect common errors in the filters\", [], \"ValidateFilter\")\n    }\n\n    convert(filter: FilterConfigJson, context: ConversionContext): FilterConfigJson {\n        if (typeof filter === \"string\") {\n            // Calling another filter, we skip\n            return filter\n        }\n        for (const option of filter.options) {\n            for (let i = 0; i < option.fields?.length ?? 0; i++) {\n                const field = option.fields[i]\n                const type = field.type ?? \"string\"\n                if (Validators.availableTypes.find((t) => t === type) === undefined) {\n                    context\n                        .enters(\"fields\", i)\n                        .err(\n                            `Invalid filter: ${type} is not a valid textfield type.\\n\\tTry one of ${Array.from(\n                                Validators.availableTypes\n                            ).join(\",\")}`\n                        )\n                }\n            }\n        }\n        return filter\n    }\n}\n\nexport class DetectDuplicateFilters extends DesugaringStep<{\n    layers: LayerConfigJson[]\n    themes: LayoutConfigJson[]\n}> {\n    constructor() {\n        super(\n            \"Tries to detect layers where a shared filter can be used (or where similar filters occur)\",\n            [],\n            \"DetectDuplicateFilters\"\n        )\n    }\n\n    convert(\n        json: { layers: LayerConfigJson[]; themes: LayoutConfigJson[] },\n        context: ConversionContext\n    ): { layers: LayerConfigJson[]; themes: LayoutConfigJson[] } {\n        const { layers, themes } = json\n        const perOsmTag = new Map<\n            string,\n            {\n                layer: LayerConfigJson\n                layout: LayoutConfigJson | undefined\n                filter: FilterConfigJson\n            }[]\n        >()\n\n        for (const layer of layers) {\n            this.addLayerFilters(layer, perOsmTag)\n        }\n\n        for (const theme of themes) {\n            if (theme.id === \"personal\") {\n                continue\n            }\n            for (const layer of theme.layers) {\n                if (typeof layer === \"string\") {\n                    continue\n                }\n                if (layer[\"builtin\"] !== undefined) {\n                    continue\n                }\n                this.addLayerFilters(<LayerConfigJson>layer, perOsmTag, theme)\n            }\n        }\n\n        // At this point, we have gathered all filters per tag - time to find duplicates\n        perOsmTag.forEach((value, key) => {\n            if (value.length <= 1) {\n                // Seen this key just once, it is unique\n                return\n            }\n            let msg = \"Possible duplicate filter: \" + key\n            for (const { filter, layer, layout } of value) {\n                let id = \"\"\n                if (layout !== undefined) {\n                    id = layout.id + \":\"\n                }\n                msg += `\\n      - ${id}${layer.id}.${filter.id}`\n            }\n            context.warn(msg)\n        })\n\n        return json\n    }\n\n    /**\n     * Add all filter options into 'perOsmTag'\n     */\n    private addLayerFilters(\n        layer: LayerConfigJson,\n        perOsmTag: Map<\n            string,\n            {\n                layer: LayerConfigJson\n                layout: LayoutConfigJson | undefined\n                filter: FilterConfigJson\n            }[]\n        >,\n        layout?: LayoutConfigJson | undefined\n    ): void {\n        if (layer.filter === undefined || layer.filter === null) {\n            return\n        }\n        if (layer.filter[\"sameAs\"] !== undefined) {\n            return\n        }\n        for (const filter of <(string | FilterConfigJson)[]>layer.filter) {\n            if (typeof filter === \"string\") {\n                continue\n            }\n\n            if (filter[\"#\"]?.indexOf(\"ignore-possible-duplicate\") >= 0) {\n                continue\n            }\n\n            for (const option of filter.options) {\n                if (option.osmTags === undefined) {\n                    continue\n                }\n                const key = JSON.stringify(option.osmTags)\n                if (!perOsmTag.has(key)) {\n                    perOsmTag.set(key, [])\n                }\n                perOsmTag.get(key).push({\n                    layer,\n                    filter,\n                    layout,\n                })\n            }\n        }\n    }\n}\n\nexport class DetectDuplicatePresets extends DesugaringStep<LayoutConfig> {\n    constructor() {\n        super(\n            \"Detects mappings which have identical (english) names or identical mappings.\",\n            [\"presets\"],\n            \"DetectDuplicatePresets\"\n        )\n    }\n\n    convert(json: LayoutConfig, context: ConversionContext): LayoutConfig {\n        const presets: PresetConfig[] = [].concat(...json.layers.map((l) => l.presets))\n\n        const enNames = presets.map((p) => p.title.textFor(\"en\"))\n        if (new Set(enNames).size != enNames.length) {\n            const dups = Utils.Duplicates(enNames)\n            const layersWithDup = json.layers.filter((l) =>\n                l.presets.some((p) => dups.indexOf(p.title.textFor(\"en\")) >= 0)\n            )\n            const layerIds = layersWithDup.map((l) => l.id)\n            context.err(\n                `This themes has multiple presets which are named:${dups}, namely layers ${layerIds.join(\n                    \", \"\n                )} this is confusing for contributors and is probably the result of reusing the same layer multiple times. Use \\`{\"override\": {\"=presets\": []}}\\` to remove some presets`\n            )\n        }\n\n        const optimizedTags = <TagsFilter[]>presets.map((p) => new And(p.tags).optimize())\n        for (let i = 0; i < presets.length; i++) {\n            const presetATags = optimizedTags[i]\n            const presetA = presets[i]\n            for (let j = i + 1; j < presets.length; j++) {\n                const presetBTags = optimizedTags[j]\n                const presetB = presets[j]\n                if (\n                    Utils.SameObject(presetATags, presetBTags) &&\n                    Utils.sameList(\n                        presetA.preciseInput.snapToLayers,\n                        presetB.preciseInput.snapToLayers\n                    )\n                ) {\n                    context.err(\n                        `This themes has multiple presets with the same tags: ${presetATags.asHumanString(\n                            false,\n                            false,\n                            {}\n                        )}, namely the preset '${presets[i].title.textFor(\"en\")}' and '${presets[\n                            j\n                        ].title.textFor(\"en\")}'`\n                    )\n                }\n            }\n        }\n\n        return json\n    }\n}\n\nexport class ValidateThemeEnsemble extends Conversion<\n    LayoutConfig[],\n    Map<\n        string,\n        {\n            tags: TagsFilter\n            foundInTheme: string[]\n            isCounted: boolean\n        }\n    >\n> {\n    constructor() {\n        super(\n            \"Validates that all themes together are logical, i.e. no duplicate ids exists within (overriden) themes\",\n            [],\n            \"ValidateThemeEnsemble\"\n        )\n    }\n\n    convert(\n        json: LayoutConfig[],\n        context: ConversionContext\n    ): Map<\n        string,\n        {\n            tags: TagsFilter\n            foundInTheme: string[]\n            isCounted: boolean\n        }\n    > {\n        const idToSource = new Map<\n            string,\n            { tags: TagsFilter; foundInTheme: string[]; isCounted: boolean }\n        >()\n\n        for (const theme of json) {\n            for (const layer of theme.layers) {\n                if (typeof layer.source === \"string\") {\n                    continue\n                }\n                if (Constants.priviliged_layers.indexOf(<any>layer.id) >= 0) {\n                    continue\n                }\n                if (!layer.source) {\n                    console.log(theme, layer, layer.source)\n                    context.enters(theme.id, \"layers\", \"source\", layer.id).err(\"No source defined\")\n                    continue\n                }\n                if (layer.source.geojsonSource) {\n                    continue\n                }\n                const id = layer.id\n                const tags = layer.source.osmTags\n                if (!idToSource.has(id)) {\n                    idToSource.set(id, { tags, foundInTheme: [theme.id], isCounted: layer.doCount })\n                    continue\n                }\n\n                const oldTags = idToSource.get(id).tags\n                const oldTheme = idToSource.get(id).foundInTheme\n                if (oldTags.shadows(tags) && tags.shadows(oldTags)) {\n                    // All is good, all is well\n                    oldTheme.push(theme.id)\n                    idToSource.get(id).isCounted ||= layer.doCount\n                    continue\n                }\n                context.err(\n                    [\n                        \"The layer with id '\" +\n                            id +\n                            \"' is found in multiple themes with different tag definitions:\",\n                        \"\\t In theme \" + oldTheme + \":\\t\" + oldTags.asHumanString(false, false, {}),\n                        \"\\tIn theme \" + theme.id + \":\\t\" + tags.asHumanString(false, false, {}),\n                    ].join(\"\\n\")\n                )\n            }\n        }\n\n        return idToSource\n    }\n}\n","import { Conversion } from \"./Conversion\"\nimport LayerConfig from \"../LayerConfig\"\nimport { LayerConfigJson } from \"../Json/LayerConfigJson\"\nimport Translations from \"../../../UI/i18n/Translations\"\nimport { Translation, TypedTranslation } from \"../../../UI/i18n/Translation\"\nimport { ConversionContext } from \"./ConversionContext\"\n\nexport default class CreateNoteImportLayer extends Conversion<LayerConfigJson, LayerConfigJson> {\n    /**\n     * A closed note is included if it is less then 'n'-days closed\n     * @private\n     */\n    private readonly _includeClosedNotesDays: number\n\n    constructor(includeClosedNotesDays = 0) {\n        super(\n            [\n                \"Advanced conversion which deducts a layer showing all notes that are 'importable' (i.e. a note that contains a link to some MapComplete theme, with hash '#import').\",\n                \"The import buttons and matches will be based on the presets of the given theme\",\n            ].join(\"\\n\\n\"),\n            [],\n            \"CreateNoteImportLayer\"\n        )\n        this._includeClosedNotesDays = includeClosedNotesDays\n    }\n\n    convert(layerJson: LayerConfigJson, _: ConversionContext): LayerConfigJson {\n        const t = Translations.t.importLayer\n\n        /**\n         * The note itself will contain `tags=k=v;k=v;k=v;...\n         * This must be matched with a regex.\n         * This is a simple JSON-object as how it'll be put into the layerConfigJson directly\n         */\n        const isShownIfAny: any[] = []\n        const layer = new LayerConfig(layerJson, \"while constructing a note-import layer\")\n        for (const preset of layer.presets) {\n            const mustMatchAll = []\n            for (const tag of preset.tags) {\n                const key = tag.key\n                const value = tag.value\n                const condition = \"_tags~(^|.*;)\" + key + \"=\" + value + \"($|;.*)\"\n                mustMatchAll.push(condition)\n            }\n            isShownIfAny.push({ and: mustMatchAll })\n        }\n\n        const title = layer.presets[0].title\n\n        const importButton = {}\n        {\n            const translations = trs(t.importButton, {\n                layerId: layer.id,\n                title: layer.presets[0].title,\n            })\n            for (const key in translations) {\n                if (key !== \"_context\") {\n                    importButton[key] = \"{\" + translations[key] + \"}\"\n                } else {\n                    importButton[key] = translations[key]\n                }\n            }\n        }\n\n        function embed(prefix, translation: Translation, postfix) {\n            const result = {}\n            for (const language in translation.translations) {\n                result[language] = prefix + translation.translations[language] + postfix\n            }\n            result[\"_context\"] = translation.context\n            return result\n        }\n\n        function tr(translation: Translation) {\n            return { ...translation.translations, _context: translation.context }\n        }\n\n        function trs<T>(translation: TypedTranslation<T>, subs: T): Record<string, string> {\n            return { ...translation.Subs(subs).translations, _context: translation.context }\n        }\n\n        return {\n            id: \"note_import_\" + layer.id,\n            // By disabling the name, the import-layers won't pollute the filter view \"name\": t.layerName.Subs({title: layer.title.render}).translations,\n            description: trs(t.description, { title: layer.title.render }),\n            source: {\n                osmTags: {\n                    and: [\"id~[0-9]+\", \"comment_url~.*notes/[0-9]*/comment.json\"],\n                },\n                geoJson:\n                    \"https://api.openstreetmap.org/api/0.6/notes.json?limit=10000&closed=\" +\n                    this._includeClosedNotesDays +\n                    \"&bbox={x_min},{y_min},{x_max},{y_max}\",\n                geoJsonZoomLevel: 10,\n            },\n            /* We need to set 'pass_all_features'\n       There are probably many note_import-layers, and we don't want the first one to gobble up all notes and then discard them...\n       */\n            passAllFeatures: true,\n            minzoom: Math.min(12, layerJson.minzoom - 2),\n            title: {\n                render: trs(t.popupTitle, { title }),\n            },\n            calculatedTags: [\n                \"_first_comment=get(feat)('comments')[0].text.toLowerCase()\",\n                \"_trigger_index=(() => {const lines = feat.properties['_first_comment'].split('\\\\n'); const matchesMapCompleteURL = lines.map(l => l.match(\\\".*https://mapcomplete.\\\\(org|osm.be\\\\)/\\\\([a-zA-Z_-]+\\\\)\\\\(.html\\\\)?.*#import\\\")); const matchedIndexes = matchesMapCompleteURL.map((doesMatch, i) => [doesMatch !== null, i]).filter(v => v[0]).map(v => v[1]); return matchedIndexes[0] })()\",\n                \"_comments_count=get(feat)('comments').length\",\n                \"_intro=(() => {const lines = get(feat)('comments')[0].text.split('\\\\n'); lines.splice(get(feat)('_trigger_index')-1, lines.length); return lines.filter(l => l !== '').join('<br/>');})()\",\n                \"_tags=(() => {let lines = get(feat)('comments')[0].text.split('\\\\n').map(l => l.trim()); lines.splice(0, get(feat)('_trigger_index') + 1); lines = lines.filter(l => l != ''); return lines.join(';');})()\",\n            ],\n            isShown: {\n                and: [\"_trigger_index~*\", { or: isShownIfAny }],\n            },\n            titleIcons: [\n                {\n                    render: \"<a href='https://openstreetmap.org/note/{id}' target='_blank'><img src='./assets/svg/osm-logo-us.svg'></a>\",\n                },\n            ],\n            tagRenderings: [\n                {\n                    id: \"Intro\",\n                    render: \"{_intro}\",\n                },\n                {\n                    id: \"conversation\",\n                    render: \"{visualize_note_comments(comments,1)}\",\n                    condition: \"_comments_count>1\",\n                },\n                {\n                    id: \"import\",\n                    render: importButton,\n                    condition: \"closed_at=\",\n                },\n                {\n                    id: \"close_note_\",\n                    render: embed(\n                        \"{close_note(\",\n                        t.notFound.Subs({ title }),\n                        \", ./assets/svg/close.svg, id, This feature does not exist, 18)}\"\n                    ),\n                    condition: \"closed_at=\",\n                },\n                {\n                    id: \"close_note_mapped\",\n                    render: embed(\n                        \"{close_note(\",\n                        t.alreadyMapped.Subs({ title }),\n                        \", ./assets/svg/duplicate.svg, id, Already mapped, 18)}\"\n                    ),\n                    condition: \"closed_at=\",\n                },\n                {\n                    id: \"handled\",\n                    render: tr(t.importHandled),\n                    condition: \"closed_at~*\",\n                },\n                {\n                    id: \"comment\",\n                    render: \"{add_note_comment()}\",\n                },\n                {\n                    id: \"add_image\",\n                    render: \"{add_image_to_note()}\",\n                },\n                {\n                    id: \"nearby_images\",\n                    render: tr(t.nearbyImagesIntro),\n                },\n                {\n                    id: \"all_tags\",\n                    render: \"{all_tags()}\",\n                    metacondition: {\n                        or: [\n                            \"__featureSwitchIsDebugging=true\",\n                            \"mapcomplete-show_tags=full\",\n                            \"mapcomplete-show_debug=yes\",\n                        ],\n                    },\n                },\n            ],\n            pointRendering: [\n                {\n                    location: [\"point\"],\n                    marker: [\n                        {\n                            icon: \"circle\",\n                            color: \"#fff\",\n                        },\n                        {\n                            icon: {\n                                render: \"help\",\n                                mappings: [\n                                    {\n                                        if: { or: [\"closed_at~*\", \"_imported=yes\"] },\n                                        then: \"checkmark\",\n                                    },\n                                ],\n                            },\n                            color: \"#00\",\n                        },\n                    ],\n                    iconSize: \"40,40\",\n                    anchor: \"center\",\n                },\n            ],\n        }\n    }\n}\n","import TagRenderingConfig from \"./TagRenderingConfig\"\nimport { ExtraFuncParams, ExtraFunctions } from \"../../Logic/ExtraFunctions\"\nimport LayerConfig from \"./LayerConfig\"\nimport { SpecialVisualization } from \"../../UI/SpecialVisualization\"\nimport SpecialVisualizations from \"../../UI/SpecialVisualizations\"\n\nexport default class DependencyCalculator {\n    public static GetTagRenderingDependencies(tr: TagRenderingConfig): string[] {\n        if (tr === undefined) {\n            throw \"Got undefined tag rendering in getTagRenderingDependencies\"\n        }\n        const deps: string[] = []\n\n        // All translated snippets\n        const parts: string[] = [].concat(...tr.EnumerateTranslations().map((tr) => tr.AllValues()))\n\n        for (const part of parts) {\n            const specialVizs: { func: SpecialVisualization; args: string[] }[] =\n                SpecialVisualizations.constructSpecification(part)\n                    .filter((p) => typeof p !== \"string\")\n                    .map((p) => <{ func: SpecialVisualization; args: string[] }>p)\n                    .filter((o) => o?.func?.getLayerDependencies !== undefined)\n            for (const specialViz of specialVizs) {\n                deps.push(...specialViz.func.getLayerDependencies(specialViz.args))\n            }\n        }\n        return deps\n    }\n\n    /**\n     * Returns a set of all other layer-ids that this layer needs to function.\n     * E.g. if this layers does snap to another layer in the preset, this other layer id will be mentioned\n     */\n    public static getLayerDependencies(\n        layer: LayerConfig\n    ): { neededLayer: string; reason: string; context?: string; neededBy: string }[] {\n        const deps: { neededLayer: string; reason: string; context?: string; neededBy: string }[] =\n            []\n\n        for (let i = 0; layer.presets !== undefined && i < layer.presets.length; i++) {\n            const preset = layer.presets[i]\n            const snapTo = preset.preciseInput?.snapToLayers\n            if (snapTo && !Array.isArray(snapTo)) {\n                throw new Error(\n                    `snapToLayers is not an array; it is ${snapTo}(used in preset ${i} for: ${layer.id})`\n                )\n            }\n            preset.preciseInput?.snapToLayers?.forEach((id) => {\n                deps.push({\n                    neededLayer: id,\n                    reason: \"a preset snaps to this layer\",\n                    context: \"presets[\" + i + \"]\",\n                    neededBy: layer.id,\n                })\n            })\n        }\n\n        for (const tr of layer.AllTagRenderings()) {\n            for (const dep of DependencyCalculator.GetTagRenderingDependencies(tr)) {\n                deps.push({\n                    neededLayer: dep,\n                    reason: \"a tagrendering needs this layer\",\n                    context: tr.id,\n                    neededBy: layer.id,\n                })\n            }\n        }\n\n        if (layer.calculatedTags?.length > 0) {\n            const obj = {\n                type: \"Feature\",\n                geometry: {\n                    type: \"Point\",\n                    coordinates: [0, 0],\n                },\n                properties: {\n                    id: \"node/1\",\n                },\n            }\n            let currentKey = undefined\n            let currentLine = undefined\n            const params: ExtraFuncParams = {\n                getFeatureById: (_) => undefined,\n                getFeaturesWithin: (layerId, _) => {\n                    if (layerId === \"*\") {\n                        // This is a wildcard\n                        return []\n                    }\n\n                    // The important line: steal the dependencies!\n                    deps.push({\n                        neededLayer: layerId,\n                        reason: \"a calculated tag loads features from this layer\",\n                        context:\n                            \"calculatedTag[\" +\n                            currentLine +\n                            \"] which calculates the value for \" +\n                            currentKey,\n                        neededBy: layer.id,\n                    })\n\n                    return []\n                },\n            }\n            const helpers = ExtraFunctions.constructHelpers(params)\n            // ... Run the calculated tag code, which will trigger the getFeaturesWithin above...\n            for (let i = 0; i < layer.calculatedTags.length; i++) {\n                const [key, code] = layer.calculatedTags[i]\n                currentLine = i // Leak the state...\n                currentKey = key\n                try {\n                    const func = new Function(\n                        \"feat\",\n                        \"{\" + ExtraFunctions.types.join(\",\") + \"}\",\n                        \"return \" + code + \";\"\n                    )\n                    const result = func(obj, helpers)\n                    obj.properties[key] = JSON.stringify(result)\n                } catch (e) {}\n            }\n        }\n\n        return deps\n    }\n}\n","import {\n    Concat,\n    Conversion,\n    DesugaringContext,\n    DesugaringStep,\n    Each,\n    Fuse,\n    On,\n    Pass,\n    SetDefault,\n} from \"./Conversion\"\nimport { LayoutConfigJson } from \"../Json/LayoutConfigJson\"\nimport { PrepareLayer } from \"./PrepareLayer\"\nimport { LayerConfigJson } from \"../Json/LayerConfigJson\"\nimport { Utils } from \"../../../Utils\"\nimport Constants from \"../../Constants\"\nimport CreateNoteImportLayer from \"./CreateNoteImportLayer\"\nimport LayerConfig from \"../LayerConfig\"\nimport { TagRenderingConfigJson } from \"../Json/TagRenderingConfigJson\"\nimport DependencyCalculator from \"../DependencyCalculator\"\nimport { AddContextToTranslations } from \"./AddContextToTranslations\"\nimport ValidationUtils from \"./ValidationUtils\"\nimport { ConversionContext } from \"./ConversionContext\"\n\nclass SubstituteLayer extends Conversion<string | LayerConfigJson, LayerConfigJson[]> {\n    private readonly _state: DesugaringContext\n\n    constructor(state: DesugaringContext) {\n        super(\n            \"Converts the identifier of a builtin layer into the actual layer, or converts a 'builtin' syntax with override in the fully expanded form. Note that 'tagRenderings+' will be inserted before 'leftover-questions'\",\n            [],\n            \"SubstituteLayer\"\n        )\n        this._state = state\n    }\n\n    convert(json: string | LayerConfigJson, context: ConversionContext): LayerConfigJson[] {\n        const state = this._state\n\n        function reportNotFound(name: string) {\n            const knownLayers = Array.from(state.sharedLayers.keys())\n            const withDistance = knownLayers.map((lname) => [\n                lname,\n                Utils.levenshteinDistance(name, lname),\n            ])\n            withDistance.sort((a, b) => a[1] - b[1])\n            const ids = withDistance.map((n) => n[0])\n            // Known builtin layers are \"+.join(\",\")+\"\\n    For more information, see \"\n            context.err(`The layer with name ${name} was not found as a builtin layer. Perhaps you meant ${ids[0]}, ${ids[1]} or ${ids[2]}?\n For an overview of all available layers, refer to https://github.com/pietervdvn/MapComplete/blob/develop/Docs/BuiltinLayers.md`)\n        }\n\n        if (typeof json === \"string\") {\n            const found = state.sharedLayers.get(json)\n            if (found === undefined) {\n                reportNotFound(json)\n                return null\n            }\n            return [found]\n        }\n\n        if (json[\"builtin\"] === undefined) {\n            return [json]\n        }\n\n        let names = json[\"builtin\"]\n        if (typeof names === \"string\") {\n            names = [names]\n        }\n        const layers = []\n\n        for (const name of names) {\n            const found = Utils.Clone(state.sharedLayers.get(name))\n            found[\"_basedOn\"] = name\n            if (found === undefined) {\n                reportNotFound(name)\n                continue\n            }\n            if (\n                json[\"override\"][\"tagRenderings\"] !== undefined &&\n                (found[\"tagRenderings\"] ?? []).length > 0\n            ) {\n                context.err(\n                    `When overriding a layer, an override is not allowed to override into tagRenderings. Use \"+tagRenderings\" or \"tagRenderings+\" instead to prepend or append some questions.`\n                )\n            }\n            try {\n                const trPlus = json[\"override\"][\"tagRenderings+\"]\n                if (trPlus) {\n                    let index = found.tagRenderings.findIndex(\n                        (tr) => tr[\"id\"] === \"leftover-questions\"\n                    )\n                    if (index < 0) {\n                        index = found.tagRenderings.length\n                    }\n                    found.tagRenderings.splice(index, 0, ...trPlus)\n                    delete json[\"override\"][\"tagRenderings+\"]\n                }\n\n                context.MergeObjectsForOverride(json[\"override\"], found)\n                layers.push(found)\n            } catch (e) {\n                context.err(\n                    `Could not apply an override due to: ${e}.\\nThe override is: ${JSON.stringify(\n                        json[\"override\"]\n                    )}`\n                )\n            }\n\n            if (json[\"hideTagRenderingsWithLabels\"]) {\n                if (typeof json[\"hideTagRenderingsWithLabels\"] === \"string\") {\n                    throw (\n                        \"At \" +\n                        context +\n                        \".hideTagRenderingsWithLabels should be a list containing strings, you specified a string\"\n                    )\n                }\n                const hideLabels: Set<string> = new Set(json[\"hideTagRenderingsWithLabels\"])\n                // These labels caused at least one deletion\n                const usedLabels: Set<string> = new Set<string>()\n                const filtered = []\n                for (const tr of found.tagRenderings) {\n                    const labels = tr[\"labels\"]\n                    if (labels !== undefined) {\n                        const forbiddenLabel = labels.findIndex((l) => hideLabels.has(l))\n                        if (forbiddenLabel >= 0) {\n                            usedLabels.add(labels[forbiddenLabel])\n                            context.info(\n                                \"Dropping tagRendering \" +\n                                    tr[\"id\"] +\n                                    \" as it has a forbidden label: \" +\n                                    labels[forbiddenLabel]\n                            )\n                            continue\n                        }\n                    }\n\n                    if (hideLabels.has(tr[\"id\"])) {\n                        usedLabels.add(tr[\"id\"])\n                        context.info(\n                            \"Dropping tagRendering \" + tr[\"id\"] + \" as its id is a forbidden label\"\n                        )\n                        continue\n                    }\n\n                    if (hideLabels.has(tr[\"group\"])) {\n                        usedLabels.add(tr[\"group\"])\n                        context.info(\n                            \"Dropping tagRendering \" +\n                                tr[\"id\"] +\n                                \" as its group `\" +\n                                tr[\"group\"] +\n                                \"` is a forbidden label\"\n                        )\n                        continue\n                    }\n\n                    filtered.push(tr)\n                }\n                const unused = Array.from(hideLabels).filter((l) => !usedLabels.has(l))\n                if (unused.length > 0) {\n                    context.err(\n                        \"This theme specifies that certain tagrenderings have to be removed based on forbidden layers. One or more of these layers did not match any tagRenderings and caused no deletions: \" +\n                            unused.join(\", \") +\n                            \"\\n   This means that this label can be removed or that the original tagRendering that should be deleted does not have this label anymore\"\n                    )\n                }\n                found.tagRenderings = filtered\n            }\n        }\n        return layers\n    }\n}\n\nclass AddDefaultLayers extends DesugaringStep<LayoutConfigJson> {\n    private readonly _state: DesugaringContext\n\n    constructor(state: DesugaringContext) {\n        super(\n            \"Adds the default layers, namely: \" + Constants.added_by_default.join(\", \"),\n            [\"layers\"],\n            \"AddDefaultLayers\"\n        )\n        this._state = state\n    }\n\n    convert(json: LayoutConfigJson, context: ConversionContext): LayoutConfigJson {\n        const state = this._state\n        json.layers = Utils.NoNull([...(json.layers ?? [])])\n        const alreadyLoaded = new Set(json.layers.map((l) => l[\"id\"]))\n\n        for (const layerName of Constants.added_by_default) {\n            const v = state.sharedLayers.get(layerName)\n            if (v === undefined) {\n                const msg = `Default layer ${layerName} not found. ${state.sharedLayers.size} layers are available`\n                if (layerName === \"favourite\") {\n                    continue\n                }\n                context.err(msg)\n                continue\n            }\n            if (alreadyLoaded.has(v.id)) {\n                context.warn(\n                    \"Layout \" +\n                        context +\n                        \" already has a layer with name \" +\n                        v.id +\n                        \"; skipping inclusion of this builtin layer\"\n                )\n                continue\n            }\n            json.layers.push(v)\n        }\n\n        return json\n    }\n}\n\nclass AddImportLayers extends DesugaringStep<LayoutConfigJson> {\n    constructor() {\n        super(\n            \"For every layer in the 'layers'-list, create a new layer which'll import notes. (Note that priviliged layers and layers which have a geojson-source set are ignored)\",\n            [\"layers\"],\n            \"AddImportLayers\"\n        )\n    }\n\n    convert(json: LayoutConfigJson, context: ConversionContext): LayoutConfigJson {\n        if (!(json.enableNoteImports ?? true)) {\n            context.info(\n                \"Not creating a note import layers for theme \" + json.id + \" as they are disabled\"\n            )\n            return json\n        }\n\n        json = { ...json }\n        const allLayers: LayerConfigJson[] = <LayerConfigJson[]>json.layers\n        json.layers = [...json.layers]\n\n        const creator = new CreateNoteImportLayer()\n        for (let i1 = 0; i1 < allLayers.length; i1++) {\n            const layer = allLayers[i1]\n            if (layer.source === undefined) {\n                // Priviliged layers are skipped\n                continue\n            }\n\n            if (layer.source[\"geoJson\"] !== undefined) {\n                // Layer which don't get their data from OSM are skipped\n                continue\n            }\n\n            if (layer.title === undefined || layer.name === undefined) {\n                // Anonymous layers and layers without popup are skipped\n                continue\n            }\n\n            if (layer.presets === undefined || layer.presets.length == 0) {\n                // A preset is needed to be able to generate a new point\n                continue\n            }\n\n            try {\n                const importLayerResult = creator.convert(\n                    layer,\n                    context.inOperation(this.name).enter(i1)\n                )\n                if (importLayerResult !== undefined) {\n                    json.layers.push(importLayerResult)\n                }\n            } catch (e) {\n                context.err(\"Could not generate an import-layer for \" + layer.id + \" due to \" + e)\n            }\n        }\n\n        return json\n    }\n}\n\nclass AddContextToTranslationsInLayout extends DesugaringStep<LayoutConfigJson> {\n    constructor() {\n        super(\n            \"Adds context to translations, including the prefix 'themes:json.id'; this is to make sure terms in an 'overrides' or inline layer are linkable too\",\n            [\"_context\"],\n            \"AddContextToTranlationsInLayout\"\n        )\n    }\n\n    convert(json: LayoutConfigJson): LayoutConfigJson {\n        const conversion = new AddContextToTranslations<LayoutConfigJson>(\"themes:\")\n        // The context is used to generate the 'context' in the translation .It _must_ be `json.id` to correctly link into weblate\n        return conversion.convert(\n            json,\n            ConversionContext.construct([json.id], [\"AddContextToTranslation\"])\n        )\n    }\n}\n\nclass ApplyOverrideAll extends DesugaringStep<LayoutConfigJson> {\n    constructor() {\n        super(\n            \"Applies 'overrideAll' onto every 'layer'. The 'overrideAll'-field is removed afterwards\",\n            [\"overrideAll\", \"layers\"],\n            \"ApplyOverrideAll\"\n        )\n    }\n\n    convert(json: LayoutConfigJson, ctx: ConversionContext): LayoutConfigJson {\n        const overrideAll = json.overrideAll\n        if (overrideAll === undefined) {\n            return json\n        }\n\n        json = { ...json }\n\n        delete json.overrideAll\n        const newLayers = []\n\n        let tagRenderingsPlus = undefined\n        if (overrideAll[\"tagRenderings+\"] !== undefined) {\n            tagRenderingsPlus = overrideAll[\"tagRenderings+\"]\n            delete overrideAll[\"tagRenderings+\"]\n        }\n\n        for (let layer of json.layers) {\n            layer = Utils.Clone(<LayerConfigJson>layer)\n            ctx.MergeObjectsForOverride(overrideAll, layer)\n            if (tagRenderingsPlus) {\n                if (!layer.tagRenderings) {\n                    layer.tagRenderings = tagRenderingsPlus\n                } else {\n                    let index = layer.tagRenderings.findIndex(\n                        (tr) => tr[\"id\"] === \"leftover-questions\"\n                    )\n                    if (index < 0) {\n                        index = layer.tagRenderings.length - 1\n                    }\n                    layer.tagRenderings.splice(index, 0, ...tagRenderingsPlus)\n                }\n            }\n\n            newLayers.push(layer)\n        }\n        json.layers = newLayers\n        return json\n    }\n}\n\nclass AddDependencyLayersToTheme extends DesugaringStep<LayoutConfigJson> {\n    private readonly _state: DesugaringContext\n\n    constructor(state: DesugaringContext) {\n        super(\n            `If a layer has a dependency on another layer, these layers are added automatically on the theme. (For example: defibrillator depends on 'walls_and_buildings' to snap onto. This layer is added automatically)\n\n            Note that these layers are added _at the start_ of the layer list, meaning that they will see _every_ feature.\n            Furthermore, \\`passAllFeatures\\` will be set, so that they won't steal away features from further layers.\n            Some layers (e.g. \\`all_buildings_and_walls\\' or \\'streets_with_a_name\\') are invisible, so by default, \\'force_load\\' is set too.\n            `,\n            [\"layers\"],\n            \"AddDependencyLayersToTheme\"\n        )\n        this._state = state\n    }\n\n    private static CalculateDependencies(\n        alreadyLoaded: LayerConfigJson[],\n        allKnownLayers: Map<string, LayerConfigJson>,\n        themeId: string\n    ): { config: LayerConfigJson; reason: string }[] {\n        const dependenciesToAdd: { config: LayerConfigJson; reason: string }[] = []\n        const loadedLayerIds: Set<string> = new Set<string>(alreadyLoaded.map((l) => l?.id))\n\n        // Verify cross-dependencies\n        let unmetDependencies: {\n            neededLayer: string\n            neededBy: string\n            reason: string\n            context?: string\n        }[] = []\n        do {\n            const dependencies: {\n                neededLayer: string\n                reason: string\n                context?: string\n                neededBy: string\n            }[] = []\n\n            for (const layerConfig of alreadyLoaded) {\n                try {\n                    const layerDeps = DependencyCalculator.getLayerDependencies(\n                        new LayerConfig(layerConfig, themeId + \"(dependencies)\")\n                    )\n                    dependencies.push(...layerDeps)\n                } catch (e) {\n                    console.error(e)\n                    throw (\n                        \"Detecting layer dependencies for \" + layerConfig.id + \" failed due to \" + e\n                    )\n                }\n            }\n\n            for (const dependency of dependencies) {\n                if (loadedLayerIds.has(dependency.neededLayer)) {\n                    // We mark the needed layer as 'mustLoad'\n                    alreadyLoaded.find((l) => l.id === dependency.neededLayer).forceLoad = true\n                }\n            }\n\n            // During the generate script, builtin layers are verified but not loaded - so we have to add them manually here\n            // Their existence is checked elsewhere, so this is fine\n            unmetDependencies = dependencies.filter((dep) => !loadedLayerIds.has(dep.neededLayer))\n            for (const unmetDependency of unmetDependencies) {\n                if (loadedLayerIds.has(unmetDependency.neededLayer)) {\n                    continue\n                }\n                const dep = Utils.Clone(allKnownLayers.get(unmetDependency.neededLayer))\n                const reason =\n                    \"This layer is needed by \" +\n                    unmetDependency.neededBy +\n                    \" because \" +\n                    unmetDependency.reason +\n                    \" (at \" +\n                    unmetDependency.context +\n                    \")\"\n                if (dep === undefined) {\n                    const message = [\n                        \"Loading a dependency failed: layer \" +\n                            unmetDependency.neededLayer +\n                            \" is not found, neither as layer of \" +\n                            themeId +\n                            \" nor as builtin layer.\",\n                        reason,\n                        \"Loaded layers are: \" + alreadyLoaded.map((l) => l.id).join(\",\"),\n                    ]\n                    throw message.join(\"\\n\\t\")\n                }\n\n                dep.forceLoad = true\n                dep.passAllFeatures = true\n                dep.description = reason\n                dependenciesToAdd.unshift({\n                    config: dep,\n                    reason,\n                })\n                loadedLayerIds.add(dep.id)\n                unmetDependencies = unmetDependencies.filter(\n                    (d) => d.neededLayer !== unmetDependency.neededLayer\n                )\n            }\n        } while (unmetDependencies.length > 0)\n\n        return dependenciesToAdd\n    }\n\n    convert(theme: LayoutConfigJson, context: ConversionContext): LayoutConfigJson {\n        const state = this._state\n        const allKnownLayers: Map<string, LayerConfigJson> = state.sharedLayers\n        const knownTagRenderings: Map<string, TagRenderingConfigJson> = state.tagRenderings\n        const layers: LayerConfigJson[] = <LayerConfigJson[]>theme.layers // Layers should be expanded at this point\n\n        knownTagRenderings.forEach((value, key) => {\n            value[\"id\"] = key\n        })\n\n        const dependencies = AddDependencyLayersToTheme.CalculateDependencies(\n            layers,\n            allKnownLayers,\n            theme.id\n        )\n        if (dependencies.length > 0) {\n            for (const dependency of dependencies) {\n                context.info(\n                    \"Added \" + dependency.config.id + \" to the theme. \" + dependency.reason\n                )\n            }\n        }\n        /**\n         * Must be added to the _end_ of the layer list:\n         * - Imagine that 'walls_and_buildings' is added...\n         * - but there is a layer about a specific type of building already\n         * Adding it up front would cause 'walls_and_buildings' to be triggered\n         */\n        layers.push(...dependencies.map((l) => l.config))\n\n        return {\n            ...theme,\n            layers: layers,\n        }\n    }\n}\n\nclass PreparePersonalTheme extends DesugaringStep<LayoutConfigJson> {\n    private readonly _state: DesugaringContext\n\n    constructor(state: DesugaringContext) {\n        super(\"Adds every public layer to the personal theme\", [\"layers\"], \"PreparePersonalTheme\")\n        this._state = state\n    }\n\n    convert(json: LayoutConfigJson, context: ConversionContext): LayoutConfigJson {\n        if (json.id !== \"personal\") {\n            return json\n        }\n\n        // The only thing this _really_ does, is adding the layer-ids into 'layers'\n        // All other preparations are done by the 'override-all'-block in personal.json\n\n        json.layers = Array.from(this._state.sharedLayers.keys())\n            .filter((l) => this._state.sharedLayers.get(l).source !== null)\n            .filter((l) => this._state.publicLayers.has(l))\n        context.info(\"The personal theme has \" + json.layers.length + \" public layers\")\n        return json\n    }\n}\n\nclass WarnForUnsubstitutedLayersInTheme extends DesugaringStep<LayoutConfigJson> {\n    constructor() {\n        super(\n            \"Generates a warning if a theme uses an unsubstituted layer\",\n            [\"layers\"],\n            \"WarnForUnsubstitutedLayersInTheme\"\n        )\n    }\n\n    convert(json: LayoutConfigJson, context: ConversionContext): LayoutConfigJson {\n        if (json.hideFromOverview === true) {\n            return json\n        }\n        if ((json.layers ?? []).length === 0) {\n            context\n                .enter(\"layers\")\n                .err(\n                    \"No layers are defined. You must define at least one layer to have a valid theme\"\n                )\n            return json\n        }\n        if (!Array.isArray(json.layers)) {\n            context\n                .enter(\"layers\")\n                .err(\"Can not iterate over layers in theme, it is a \" + JSON.stringify(json.layers))\n            return json\n        }\n        for (const layer of json.layers) {\n            if (typeof layer === \"string\") {\n                continue\n            }\n            if (layer[\"builtin\"] !== undefined) {\n                continue\n            }\n            if (layer[\"source\"][\"geojson\"] !== undefined) {\n                // We turn a blind eye for import layers\n                continue\n            }\n\n            context.warn(\n                \"The theme \" +\n                    json.id +\n                    \" has an inline layer: \" +\n                    layer[\"id\"] +\n                    \". This is discouraged.\"\n            )\n        }\n        return json\n    }\n}\n\nclass PostvalidateTheme extends DesugaringStep<LayoutConfigJson> {\n    private readonly _state: DesugaringContext\n    constructor(state: DesugaringContext) {\n        super(\"Various validation steps when everything is done\", [], \"PostvalidateTheme\")\n        this._state = state\n    }\n\n    convert(json: LayoutConfigJson, context: ConversionContext): LayoutConfigJson {\n        for (const l of json.layers) {\n            const layer = <LayerConfigJson>l\n            const basedOn = <string>layer[\"_basedOn\"]\n            const basedOnDef = this._state.sharedLayers.get(basedOn)\n            if (!basedOn) {\n                continue\n            }\n            if (layer[\"name\"] === null) {\n                continue\n            }\n            const sameBasedOn = <LayerConfigJson[]>(\n                json.layers.filter(\n                    (l) => l[\"_basedOn\"] === layer[\"_basedOn\"] && l[\"id\"] !== layer.id\n                )\n            )\n            const minZoomAll = Math.min(...sameBasedOn.map((sbo) => sbo.minzoom))\n\n            const sameNameDetected = sameBasedOn.some(\n                (same) => JSON.stringify(layer[\"name\"]) === JSON.stringify(same[\"name\"])\n            )\n            if (!sameNameDetected) {\n                // The name is unique, so it'll won't be confusing\n                continue\n            }\n            if (minZoomAll < layer.minzoom) {\n                context.err(\n                    \"There are multiple layers based on \" +\n                        basedOn +\n                        \". The layer with id \" +\n                        layer.id +\n                        \" has a minzoom of \" +\n                        layer.minzoom +\n                        \", and has a name set. Another similar layer has a lower minzoom. As such, the layer selection might show 'zoom in to see features' even though some of the features are already visible. Set `\\\"name\\\": null` for this layer and eventually remove the 'name':null for the other layer.\"\n                )\n            }\n        }\n\n        for (const layer of json.layers) {\n            if (typeof layer === \"string\") {\n                continue\n            }\n            const config = <LayerConfigJson>layer\n            const sameAs = config.filter?.[\"sameAs\"]\n            if (!sameAs) {\n                continue\n            }\n\n            const matchingLayer = json.layers.find((l) => l[\"id\"] === sameAs)\n            if (!matchingLayer) {\n                const closeLayers = Utils.sortedByLevenshteinDistance(\n                    sameAs,\n                    json.layers,\n                    (l) => l[\"id\"]\n                ).map((l) => l[\"id\"])\n                context\n                    .enters(\"layers\", config.id, \"filter\", \"sameAs\")\n                    .err(\n                        \"The layer \" +\n                            config.id +\n                            \" follows the filter state of layer \" +\n                            sameAs +\n                            \", but no layer with this name was found.\\n\\tDid you perhaps mean one of: \" +\n                            closeLayers.slice(0, 3).join(\", \")\n                    )\n            }\n        }\n\n        return json\n    }\n}\nexport class PrepareTheme extends Fuse<LayoutConfigJson> {\n    private state: DesugaringContext\n\n    constructor(\n        state: DesugaringContext,\n        options?: {\n            skipDefaultLayers: false | boolean\n        }\n    ) {\n        super(\n            \"Fully prepares and expands a theme\",\n\n            new AddContextToTranslationsInLayout(),\n            new PreparePersonalTheme(state),\n            new WarnForUnsubstitutedLayersInTheme(),\n            new On(\"layers\", new Concat(new SubstituteLayer(state))),\n            new SetDefault(\"socialImage\", \"assets/SocialImage.png\", true),\n            // We expand all tagrenderings first...\n            new On(\"layers\", new Each(new PrepareLayer(state))),\n            // Then we apply the override all. We must first expand everything in case that we override something in an expanded tag\n            // Note that it'll cheat with tagRenderings+\n            new ApplyOverrideAll(),\n            // And then we prepare all the layers _again_ in case that an override all contained unexpanded tagrenderings!\n            new On(\"layers\", new Each(new PrepareLayer(state))),\n            options?.skipDefaultLayers\n                ? new Pass(\"AddDefaultLayers is disabled due to the set flag\")\n                : new AddDefaultLayers(state),\n            new AddDependencyLayersToTheme(state),\n            new AddImportLayers(),\n            new PostvalidateTheme(state)\n        )\n        this.state = state\n    }\n\n    convert(json: LayoutConfigJson, context: ConversionContext): LayoutConfigJson {\n        const result = super.convert(json, context)\n        if ((this.state.publicLayers?.size ?? 0) === 0) {\n            // THis is a bootstrapping run, no need to already set this flag\n            return result\n        }\n\n        const needsNodeDatabase = result.layers?.some((l: LayerConfigJson) =>\n            l.tagRenderings?.some((tr) =>\n                ValidationUtils.getSpecialVisualisations(<any>tr)?.some(\n                    (special) => special.needsNodeDatabase\n                )\n            )\n        )\n        if (needsNodeDatabase) {\n            context.info(\n                \"Setting 'enableNodeDatabase' as this theme uses a special visualisation which needs to keep track of _all_ nodes\"\n            )\n            result.enableNodeDatabase = true\n        }\n\n        return result\n    }\n}\n"],"names":["AddContextToTranslations","DesugaringStep","prefix","__publicField","json","context","Utils","leaf","path","breadcrumb","i","pointer","obj","Translations","ValidationUtils","renderingConfigs","visualisations","renderConfig","renderingConfig","spec","cacheName","translations","m","all","translation","key","template","specials","SpecialVisualizations","p","ExpandRewrite","Conversion","keyToRewrite","target","tr","targetIsTranslation","replaceRecursive","o","isTr","subtarget","findRecursive","rewrite","keysToRewrite","results","guard","j","toRewrite","into","renderings","ts","tx","t","sourceKeysToIgnore","listKey","original","sourceKeys","sk","sourceKey","rw","values","v","_ExpandFilter","state","filters","filter","predifined_filters","newFilters","matchingTr","_a","options","mapping","split","layer","expectedId","expandedFilter","f","found","suggestions","ExpandFilter","ExpandTagRendering","self","trconfig","label","withLabel","ctx","trs","result","stable","name","direct","tagRenderingConfigJson","nm","indirect","n","foundTr","spl","_b","id","layerTrs","matchingTrs","id_","contextWriter","_c","ConversionContext","lookup","_d","names","candidates","layerName","_e","s","DetectInline","AddQuestionBox","questionSpecials","sp","noLabels","allLabels","seen","questionSpecial","used","a","blacklisted","_f","usedLabel","question","AddEditingElements","desugaring","_","allIds","specialVisualisations","usedSpecialFunctions","sv","trc","RewriteSpecial","input","special","type","vis","k","e","argNamesList","argNames","wrongArg","byDistance","x","arg","foundLanguages","translatedArgs","translatedArg","ln","before","after","args","languages","argName","Translation","beforeText","afterText","paths","tagrenderingconfigmeta","travelled","ExpandIconBadges","badgesJson","iconBadges","iconBadge","expanded","resolved","PreparePointRendering","Fuse","On","Each","FirstOf","SetFullNodeDatabase","specs","ExpandMarkerRenderings","expander","AddFavouriteBadges","pr","ti","AddRatingBadge","specialVis","rs","AutoTitleIcon","mappings","img","allAutoIndex","generated","titleIcon","trId","PrepareLayer","Concat","SetDefault","ValidateLanguageCompleteness","origLayers","l","neededLanguage","missing","DoesImageExist","knownImagePaths","checkExistsSync","ignore","image","Constants","_ValidateTheme","doesImageExist","isBuiltin","sharedTagRenderings","ExtractImages","theme","LayoutConfig","images","remoteImages","remoteImage","filename","dups","targetLanguage","DetectDuplicatePresets","backgroundId","nearby","AvailableRasterLayers","ValidateTheme","ValidateThemeAndLayers","Bypass","ValidateLayerConfig","OverrideShadowingCheck","overrideAll","withOverride","w","MiscThemeChecks","PrevalidateTheme","DetectConflictingAddExtraTags","tagRendering","TagRenderingConfig","keysInMapping","duplicateKeys","DetectShadowedMappings","layerConfig","ct","defaultProperties","calculatedTagName","parsedConditions","ifTags","TagUtils","hideInAnswer","conditionTags","And","keyValues","properties","doesMatch","DetectMappingsWithImages","ignoreToken","ValidatePossibleLinks","str","parse_html","links","link","_CheckTranslation","allowUndefined","keys","msg","lng","CheckTranslation","MiscTagRenderingChecks","en","render","txt","funcName","freeformType","Validators","ValidateTagRenderings","PrevalidateLayer","studioValidations","ValidatePointRendering","layerRegex","osmTags","LayerConfig","duplicates","c","_g","DeleteConfig","forbiddenTopLevel","forbiddenKey","expected","_h","emptyIndexes","duplicateIds","_i","ValidateFilter","pointRendering","icon","indexM","baseTags","preset","tags","tag","skipDefaultLayers","ValidateLayer","prepared","code","__","src","option","presets","enNames","layerIds","optimizedTags","presetATags","presetA","presetBTags","presetB","CreateNoteImportLayer","includeClosedNotesDays","layerJson","isShownIfAny","mustMatchAll","value","condition","title","importButton","embed","postfix","language","subs","DependencyCalculator","deps","parts","part","specialVizs","specialViz","snapTo","dep","currentKey","currentLine","params","layerId","helpers","ExtraFunctions","SubstituteLayer","reportNotFound","withDistance","lname","b","ids","layers","trPlus","index","hideLabels","usedLabels","filtered","labels","forbiddenLabel","unused","AddDefaultLayers","alreadyLoaded","AddImportLayers","allLayers","creator","i1","importLayerResult","AddContextToTranslationsInLayout","ApplyOverrideAll","newLayers","tagRenderingsPlus","AddDependencyLayersToTheme","allKnownLayers","themeId","dependenciesToAdd","loadedLayerIds","unmetDependencies","dependencies","layerDeps","dependency","unmetDependency","reason","d","knownTagRenderings","PreparePersonalTheme","WarnForUnsubstitutedLayersInTheme","PostvalidateTheme","basedOn","sameBasedOn","minZoomAll","sbo","same","config","sameAs","closeLayers","PrepareTheme","Pass"],"mappings":"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"}