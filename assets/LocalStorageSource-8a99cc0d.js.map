{"version":3,"file":"LocalStorageSource-8a99cc0d.js","sources":["../../src/Logic/UIEventSource.ts","../../src/Logic/Web/LocalStorageSource.ts"],"sourcesContent":["import { Utils } from \"../Utils\"\nimport { Readable, Subscriber, Unsubscriber, Updater, Writable } from \"svelte/store\"\n\n/**\n * Various static utils\n */\nexport class Stores {\n    public static Chronic(millis: number, asLong: () => boolean = undefined): Store<Date> {\n        const source = new UIEventSource<Date>(undefined)\n\n        function run() {\n            source.setData(new Date())\n            if (asLong === undefined || asLong()) {\n                window.setTimeout(run, millis)\n            }\n        }\n\n        run()\n        return source\n    }\n\n    public static FromPromiseWithErr<T>(\n        promise: Promise<T>\n    ): Store<{ success: T } | { error: any }> {\n        return UIEventSource.FromPromiseWithErr(promise)\n    }\n\n    /**\n     * Converts a promise into a UIVentsource, sets the UIEVentSource when the result is calculated.\n     * If the promise fails, the value will stay undefined\n     * @param promise\n     * @constructor\n     */\n    public static FromPromise<T>(promise: Promise<T>): Store<T | undefined> {\n        const src = new UIEventSource<T>(undefined)\n        promise?.then((d) => src.setData(d))\n        promise?.catch((err) => console.warn(\"Promise failed:\", err))\n        return src\n    }\n\n    public static flatten<X>(source: Store<Store<X>>, possibleSources?: Store<any>[]): Store<X> {\n        return UIEventSource.flatten(source, possibleSources)\n    }\n\n    /**\n     * Given a UIEVentSource with a list, returns a new UIEventSource which is only updated if the _contents_ of the list are different.\n     * E.g.\n     * const src = new UIEventSource([1,2,3])\n     * const stable = UIEventSource.ListStabilized(src)\n     * src.addCallback(_ => console.log(\"src pinged\"))\n     * stable.addCallback(_ => console.log(\"stable pinged))\n     * src.setDate([...src.data])\n     *\n     * This will only trigger 'src pinged'\n     *\n     * @param src\n     * @constructor\n     */\n    public static ListStabilized<T>(src: Store<T[]>): Store<T[]> {\n        const stable = new UIEventSource<T[]>(undefined)\n        src.addCallbackAndRun((list) => {\n            if (list === undefined) {\n                stable.setData(undefined)\n                return\n            }\n            if (Utils.sameList(stable.data, list)) {\n                return\n            }\n            stable.setData(list)\n        })\n        return stable\n    }\n}\n\nexport abstract class Store<T> implements Readable<T> {\n    abstract readonly data: T\n\n    /**\n     * Optional value giving a title to the UIEventSource, mainly used for debugging\n     */\n    public readonly tag: string | undefined\n\n    constructor(tag: string = undefined) {\n        this.tag = tag\n        if (tag === undefined || tag === \"\") {\n            let createStack = Utils.runningFromConsole\n            if (!Utils.runningFromConsole) {\n                createStack = window.location.hostname === \"127.0.0.1\"\n            }\n            if (createStack) {\n                const callstack = new Error().stack.split(\"\\n\")\n                this.tag = callstack[1]\n            }\n        }\n    }\n\n    abstract map<J>(f: (t: T) => J): Store<J>\n    abstract map<J>(f: (t: T) => J, extraStoresToWatch: Store<any>[]): Store<J>\n\n    public mapD<J>(f: (t: Exclude<T, undefined | null>) => J, extraStoresToWatch?: Store<any>[]): Store<J> {\n        return this.map((t) => {\n            if (t === undefined) {\n                return undefined\n            }\n            if (t === null) {\n                return null\n            }\n            return f(<Exclude<T, undefined | null>> t)\n        }, extraStoresToWatch)\n    }\n\n    /**\n     * Add a callback function which will run on future data changes\n     */\n    abstract addCallback(callback: (data: T) => void): () => void\n\n    /**\n     * Adds a callback function, which will be run immediately.\n     * Only triggers if the current data is defined\n     */\n    abstract addCallbackAndRunD(callback: (data: T) => void): () => void\n\n    /**\n     * Add a callback function which will run on future data changes\n     * Only triggers if the data is defined\n     */\n    abstract addCallbackD(callback: (data: T) => void): () => void\n\n    /**\n     * Adds a callback function, which will be run immediately.\n     * Only triggers if the current data is defined\n     */\n    abstract addCallbackAndRun(callback: (data: T) => void): () => void\n\n    public withEqualityStabilized(\n        comparator: (t: T | undefined, t1: T | undefined) => boolean\n    ): Store<T> {\n        let oldValue = undefined\n        return this.map((v) => {\n            if (v == oldValue) {\n                return oldValue\n            }\n            if (comparator(oldValue, v)) {\n                return oldValue\n            }\n            oldValue = v\n            return v\n        })\n    }\n\n    /**\n     * Monadic bind function\n     *\n     * // simple test with bound and immutablestores\n     * const src = new UIEventSource<number>(3)\n     * const bound = src.bind(i => new ImmutableStore(i * 2))\n     * let lastValue = undefined;\n     * bound.addCallbackAndRun(v => lastValue = v);\n     * lastValue // => 6\n     * src.setData(21)\n     * lastValue // => 42\n     *\n     * // simple test with bind over a mapped value\n     * const src = new UIEventSource<number>(0)\n     * const srcs : UIEventSource<string>[] = [new UIEventSource<string>(\"a\"), new UIEventSource<string>(\"b\")]\n     * const bound = src.map(i => -i).bind(i => srcs[i])\n     * let lastValue : string = undefined;\n     * bound.addCallbackAndRun(v => lastValue = v);\n     * lastValue // => \"a\"\n     * src.setData(-1)\n     * lastValue // => \"b\"\n     * srcs[1].setData(\"xyz\")\n     * lastValue // => \"xyz\"\n     * srcs[0].setData(\"def\")\n     * lastValue // => \"xyz\"\n     * src.setData(0)\n     * lastValue // => \"def\"\n     *\n     *\n     *\n     * // advanced test with bound\n     * const src = new UIEventSource<number>(0)\n     * const srcs : UIEventSource<string>[] = [new UIEventSource<string>(\"a\"), new UIEventSource<string>(\"b\")]\n     * const bound = src.bind(i => srcs[i])\n     * let lastValue : string = undefined;\n     * bound.addCallbackAndRun(v => lastValue = v);\n     * lastValue // => \"a\"\n     * src.setData(1)\n     * lastValue // => \"b\"\n     * srcs[1].setData(\"xyz\")\n     * lastValue // => \"xyz\"\n     * srcs[0].setData(\"def\")\n     * lastValue // => \"xyz\"\n     * src.setData(0)\n     * lastValue // => \"def\"\n     */\n    public bind<X>(f: (t: T) => Store<X>): Store<X> {\n        const mapped = this.map(f)\n        const sink = new UIEventSource<X>(undefined)\n        const seenEventSources = new Set<Store<X>>()\n        mapped.addCallbackAndRun((newEventSource) => {\n            if (newEventSource === null) {\n                sink.setData(null)\n            } else if (newEventSource === undefined) {\n                sink.setData(undefined)\n            } else if (!seenEventSources.has(newEventSource)) {\n                seenEventSources.add(newEventSource)\n                newEventSource.addCallbackAndRun((resultData) => {\n                    if (mapped.data === newEventSource) {\n                        sink.setData(resultData)\n                    }\n                })\n            } else {\n                // Already seen, so we don't have to add a callback, just update the value\n                sink.setData(newEventSource.data)\n            }\n        })\n\n        return sink\n    }\n\n    public stabilized(millisToStabilize): Store<T> {\n        if (Utils.runningFromConsole) {\n            return this\n        }\n\n        const newSource = new UIEventSource<T>(this.data)\n\n        const self = this\n        this.addCallback((latestData) => {\n            window.setTimeout(() => {\n                if (self.data == latestData) {\n                    // compare by reference.\n                    // Note that 'latestData' and 'self.data' are both from the same UIEVentSource, but both are dereferenced at a different time\n                    newSource.setData(latestData)\n                }\n            }, millisToStabilize)\n        })\n\n        return newSource\n    }\n\n    /**\n     * Converts the uiEventSource into a promise.\n     * The promise will return the value of the store if the given condition evaluates to true\n     * @param condition: an optional condition, default to 'store.value !== undefined'\n     * @constructor\n     */\n    public AsPromise(condition?: (t: T) => boolean): Promise<T> {\n        const self = this\n        condition = condition ?? ((t) => t !== undefined)\n        return new Promise((resolve) => {\n            const data = self.data\n            if (condition(data)) {\n                resolve(data)\n            } else {\n                self.addCallbackD((data) => {\n                    if (condition(data)) {\n                        resolve(data)\n                        return true // return true to unregister as we only need to be called once\n                    } else {\n                        return false // We didn't resolve yet, wait for the next ping\n                    }\n                })\n            }\n        })\n    }\n\n    /**\n     * Same as 'addCallbackAndRun', added to be compatible with Svelte\n     */\n    public subscribe(run: Subscriber<T> & ((value: T) => void), _?): Unsubscriber {\n        // We don't need to do anything with 'invalidate', see\n        // https://github.com/sveltejs/svelte/issues/3859\n\n        // Note: run is wrapped in an anonymous function. 'Run' returns the value. If this value happens to be true, it would unsubscribe\n        return this.addCallbackAndRun((v) => {\n            run(v)\n        })\n    }\n}\n\nexport class ImmutableStore<T> extends Store<T> {\n    public readonly data: T\n\n    constructor(data: T) {\n        super()\n        this.data = data\n    }\n\n    private static readonly pass: () => void = () => {}\n\n    addCallback(_: (data: T) => void): () => void {\n        // pass: data will never change\n        return ImmutableStore.pass\n    }\n\n    addCallbackAndRun(callback: (data: T) => void): () => void {\n        callback(this.data)\n        // no callback registry: data will never change\n        return ImmutableStore.pass\n    }\n\n    addCallbackAndRunD(callback: (data: T) => void): () => void {\n        if (this.data !== undefined) {\n            callback(this.data)\n        }\n        // no callback registry: data will never change\n        return ImmutableStore.pass\n    }\n\n    addCallbackD(_: (data: T) => void): () => void {\n        // pass: data will never change\n        return ImmutableStore.pass\n    }\n\n    map<J>(f: (t: T) => J, extraStores: Store<any>[] = undefined): ImmutableStore<J> {\n        if (extraStores?.length > 0) {\n            return new MappedStore(this, f, extraStores, undefined, f(this.data))\n        }\n        return new ImmutableStore<J>(f(this.data))\n    }\n}\n\n/**\n * Keeps track of the callback functions\n */\nclass ListenerTracker<T> {\n    public pingCount = 0\n    private readonly _callbacks: ((t: T) => boolean | void | any)[] = []\n\n    /**\n     * Adds a callback which can be called; a function to unregister is returned\n     */\n    public addCallback(callback: (t: T) => boolean | void | any): () => void {\n        if (callback === console.log) {\n            // This ^^^ actually works!\n            throw \"Don't add console.log directly as a callback - you'll won't be able to find it afterwards. Wrap it in a lambda instead.\"\n        }\n        this._callbacks.push(callback)\n\n        // Give back an unregister-function!\n        return () => {\n            const index = this._callbacks.indexOf(callback)\n            if (index >= 0) {\n                this._callbacks.splice(index, 1)\n            }\n        }\n    }\n\n    /**\n     * Call all the callbacks.\n     * Returns the number of registered callbacks\n     */\n    public ping(data: T): number {\n        this.pingCount++\n        let toDelete = undefined\n        let startTime = new Date().getTime() / 1000\n        for (const callback of this._callbacks) {\n            try {\n                if (callback(data) === true) {\n                    // This callback wants to be deleted\n                    // Note: it has to return precisely true in order to avoid accidental deletions\n                    if (toDelete === undefined) {\n                        toDelete = [callback]\n                    } else {\n                        toDelete.push(callback)\n                    }\n                }\n            } catch (e) {\n                console.error(\"Got an error while running a callback:\", e)\n            }\n        }\n        let endTime = new Date().getTime() / 1000\n        if (endTime - startTime > 500) {\n            console.trace(\n                \"Warning: a ping took more then 500ms; this is probably a performance issue\"\n            )\n        }\n        if (toDelete !== undefined) {\n            for (const toDeleteElement of toDelete) {\n                this._callbacks.splice(this._callbacks.indexOf(toDeleteElement), 1)\n            }\n        }\n        return this._callbacks.length\n    }\n\n    length() {\n        return this._callbacks.length\n    }\n}\n\n/**\n * The mapped store is a helper type which does the mapping of a function.\n */\nclass MappedStore<TIn, T> extends Store<T> {\n    private static readonly pass: () => {}\n    private readonly _upstream: Store<TIn>\n    private readonly _upstreamCallbackHandler: ListenerTracker<TIn> | undefined\n    private _upstreamPingCount: number = -1\n    private _unregisterFromUpstream: () => void\n    private readonly _f: (t: TIn) => T\n    private readonly _extraStores: Store<any>[] | undefined\n    private _unregisterFromExtraStores: (() => void)[] | undefined\n    private _callbacks: ListenerTracker<T> = new ListenerTracker<T>()\n    private _callbacksAreRegistered = false\n\n    constructor(\n        upstream: Store<TIn>,\n        f: (t: TIn) => T,\n        extraStores: Store<any>[],\n        upstreamListenerHandler: ListenerTracker<TIn> | undefined,\n        initialState: T,\n        onDestroy?: (f: () => void) => void\n    ) {\n        super()\n        this._upstream = upstream\n        this._upstreamCallbackHandler = upstreamListenerHandler\n        this._f = f\n        this._data = initialState\n        this._upstreamPingCount = upstreamListenerHandler?.pingCount\n        this._extraStores = extraStores\n        this.registerCallbacksToUpstream()\n        if (onDestroy !== undefined) {\n            onDestroy(() => this.unregisterFromUpstream())\n        }\n    }\n\n    private _data: T\n\n    /**\n     * Gets the current data from the store\n     *\n     * const src = new UIEventSource(21)\n     * const mapped = src.map(i => i * 2)\n     * src.setData(3)\n     * mapped.data // => 6\n     */\n    get data(): T {\n        if (!this._callbacksAreRegistered) {\n            // Callbacks are not registered, so we haven't been listening for updates from the upstream which might have changed\n            if (this._upstreamCallbackHandler?.pingCount != this._upstreamPingCount) {\n                // Upstream has pinged - let's update our data first\n                this._data = this._f(this._upstream.data)\n            }\n            return this._data\n        }\n        return this._data\n    }\n\n    map<J>(f: (t: T) => J, extraStores: Store<any>[] = undefined): Store<J> {\n        let stores: Store<any>[] = undefined\n        if (extraStores?.length > 0 || this._extraStores?.length > 0) {\n            stores = []\n        }\n        if (extraStores?.length > 0) {\n            stores.push(...extraStores)\n        }\n        if (this._extraStores?.length > 0) {\n            this._extraStores?.forEach((store) => {\n                if (stores.indexOf(store) < 0) {\n                    stores.push(store)\n                }\n            })\n        }\n        return new MappedStore(\n            this,\n            f, // we could fuse the functions here (e.g. data => f(this._f(data), but this might result in _f being calculated multiple times, breaking things\n            stores,\n            this._callbacks,\n            f(this.data)\n        )\n    }\n\n    addCallback(callback: (data: T) => any | boolean | void): () => void {\n        if (!this._callbacksAreRegistered) {\n            // This is the first callback that is added\n            // We register this 'map' to the upstream object and all the streams\n            this.registerCallbacksToUpstream()\n        }\n        const unregister = this._callbacks.addCallback(callback)\n        return () => {\n            unregister()\n            if (this._callbacks.length() == 0) {\n                this.unregisterFromUpstream()\n            }\n        }\n    }\n\n    addCallbackAndRun(callback: (data: T) => any | boolean | void): () => void {\n        const unregister = this.addCallback(callback)\n        const doRemove = callback(this.data)\n        if (doRemove === true) {\n            unregister()\n            return MappedStore.pass\n        }\n        return unregister\n    }\n\n    addCallbackAndRunD(callback: (data: T) => any | boolean | void): () => void {\n        return this.addCallbackAndRun((data) => {\n            if (data !== undefined) {\n                return callback(data)\n            }\n        })\n    }\n\n    addCallbackD(callback: (data: T) => any | boolean | void): () => void {\n        return this.addCallback((data) => {\n            if (data !== undefined) {\n                return callback(data)\n            }\n        })\n    }\n\n    private unregisterFromUpstream() {\n        this._callbacksAreRegistered = false\n        this._unregisterFromUpstream()\n        this._unregisterFromExtraStores?.forEach((unr) => unr())\n    }\n\n    private registerCallbacksToUpstream() {\n        const self = this\n\n        this._unregisterFromUpstream = this._upstream.addCallback((_) => self.update())\n        this._unregisterFromExtraStores = this._extraStores?.map((store) =>\n            store?.addCallback((_) => self.update())\n        )\n        this._callbacksAreRegistered = true\n    }\n\n    private update(): void {\n        const newData = this._f(this._upstream.data)\n        this._upstreamPingCount = this._upstreamCallbackHandler?.pingCount\n        if (this._data === newData) {\n            return\n        }\n        this._data = newData\n        this._callbacks.ping(this._data)\n    }\n}\n\nexport class UIEventSource<T> extends Store<T> implements Writable<T> {\n    private static readonly pass: () => {}\n    public data: T\n    _callbacks: ListenerTracker<T> = new ListenerTracker<T>()\n\n    constructor(data: T, tag: string = \"\") {\n        super(tag)\n        this.data = data\n    }\n\n    public static flatten<X>(\n        source: Store<Store<X>>,\n        possibleSources?: Store<any>[]\n    ): UIEventSource<X> {\n        const sink = new UIEventSource<X>(source.data?.data)\n\n        source.addCallback((latestData) => {\n            sink.setData(latestData?.data)\n            latestData.addCallback((data) => {\n                if (source.data !== latestData) {\n                    return true\n                }\n                sink.setData(data)\n            })\n        })\n\n        for (const possibleSource of possibleSources ?? []) {\n            possibleSource?.addCallback(() => {\n                sink.setData(source.data?.data)\n            })\n        }\n\n        return sink\n    }\n\n    /**\n     * Converts a promise into a UIVentsource, sets the UIEVentSource when the result is calculated.\n     * If the promise fails, the value will stay undefined, but 'onError' will be called\n     */\n    public static FromPromise<T>(\n        promise: Promise<T>,\n        onError: (e: any) => void = undefined\n    ): UIEventSource<T> {\n        const src = new UIEventSource<T>(undefined)\n        promise?.then((d) => src.setData(d))\n        promise?.catch((err) => {\n            if (onError !== undefined) {\n                onError(err)\n            } else {\n                console.warn(\"Promise failed:\", err)\n            }\n        })\n        return src\n    }\n\n    /**\n     * Converts a promise into a UIVentsource, sets the UIEVentSource when the result is calculated.\n     * If the promise fails, the value will stay undefined\n     * @param promise\n     * @constructor\n     */\n    public static FromPromiseWithErr<T>(\n        promise: Promise<T>\n    ): UIEventSource<{ success: T } | { error: any } | undefined> {\n        const src = new UIEventSource<{ success: T } | { error: any }>(undefined)\n        promise?.then((d) => src.setData({ success: d }))\n        promise?.catch((err) => src.setData({ error: err }))\n        return src\n    }\n\n    /**\n     *\n     * @param source\n     * UIEventSource.asInt(new UIEventSource(\"123\")).data // => 123\n     * UIEventSource.asInt(new UIEventSource(\"123456789\")).data // => 123456789\n     *\n     * const srcStr = new UIEventSource(\"123456789\"))\n     * const srcInt = UIEventSource.asInt(srcStr)\n     * srcInt.setData(987654321)\n     * srcStr.data // => \"987654321\"\n     */\n    public static asInt(source: UIEventSource<string>): UIEventSource<number> {\n        return source.sync(\n            (str) => {\n                let parsed = parseInt(str)\n                return isNaN(parsed) ? undefined : parsed\n            },\n            [],\n            (fl) => {\n                if (fl === undefined || isNaN(fl)) {\n                    return undefined\n                }\n                return \"\" + fl\n            }\n        )\n    }\n\n    /**\n     * UIEventSource.asFloat(new UIEventSource(\"123\")).data // => 123\n     * UIEventSource.asFloat(new UIEventSource(\"123456789\")).data // => 123456789\n     * UIEventSource.asFloat(new UIEventSource(\"0.5\")).data // => 0.5\n     * UIEventSource.asFloat(new UIEventSource(\"0.125\")).data // => 0.125\n     * UIEventSource.asFloat(new UIEventSource(\"0.0000000001\")).data // => 0.0000000001\n     *\n     *\n     * const srcStr = new UIEventSource(\"123456789\"))\n     * const srcInt = UIEventSource.asFloat(srcStr)\n     * srcInt.setData(987654321)\n     * srcStr.data // => \"987654321\"\n     * @param source\n     */\n\n    public static asFloat(source: UIEventSource<string>): UIEventSource<number> {\n        return source.sync(\n            (str) => {\n                let parsed = parseFloat(str)\n                return isNaN(parsed) ? undefined : parsed\n            },\n            [],\n            (fl) => {\n                if (fl === undefined || isNaN(fl)) {\n                    return undefined\n                }\n                return \"\" + fl\n            }\n        )\n    }\n\n    static asBoolean(stringUIEventSource: UIEventSource<string>): UIEventSource<boolean> {\n        return stringUIEventSource.sync(\n            (str) => str === \"true\",\n            [],\n            (b) => \"\" + b\n        )\n    }\n\n    /**\n     * Create a new UIEVentSource. Whenever 'source' changes, the returned UIEventSource will get this value as well.\n     * However, this value can be overriden without affecting source\n     */\n    static feedFrom<T>(store: Store<T>): UIEventSource<T> {\n        const src = new UIEventSource(store.data)\n        store.addCallback((t) => src.setData(t))\n        return src\n    }\n\n    /**\n     * Adds a callback\n     *\n     * If the result of the callback is 'true', the callback is considered finished and will be removed again\n     * @param callback\n     */\n    public addCallback(callback: (latestData: T) => boolean | void | any): () => void {\n        return this._callbacks.addCallback(callback)\n    }\n\n    public addCallbackAndRun(callback: (latestData: T) => boolean | void | any): () => void {\n        const doDeleteCallback = callback(this.data)\n        if (doDeleteCallback !== true) {\n            return this.addCallback(callback)\n        } else {\n            return UIEventSource.pass\n        }\n    }\n\n    public addCallbackAndRunD(callback: (data: T) => void): () => void {\n        return this.addCallbackAndRun((data) => {\n            if (data !== undefined && data !== null) {\n                return callback(data)\n            }\n        })\n    }\n\n    public addCallbackD(callback: (data: T) => void): () => void {\n        return this.addCallback((data) => {\n            if (data !== undefined && data !== null) {\n                return callback(data)\n            }\n        })\n    }\n\n    public setData(t: T): UIEventSource<T> {\n        if (this.data == t) {\n            // MUST COMPARE BY REFERENCE!\n            return\n        }\n        this.data = t\n        this._callbacks.ping(t)\n        return this\n    }\n\n    public ping(): void {\n        this._callbacks.ping(this.data)\n    }\n\n    /**\n     * Monoidal map which results in a read-only store\n     * Given a function 'f', will construct a new UIEventSource where the contents will always be \"f(this.data)'\n     * @param f: The transforming function\n     * @param extraSources: also trigger the update if one of these sources change\n     * @param onDestroy: a callback that can trigger the destroy function\n     *\n     * const src = new UIEventSource<number>(10)\n     * const store = src.map(i => i * 2)\n     * store.data // => 20\n     * let srcSeen = undefined;\n     * src.addCallback(v => {\n     *     console.log(\"Triggered\")\n     *     srcSeen = v\n     * })\n     * let lastSeen = undefined\n     * store.addCallback(v => {\n     *     console.log(\"Triggered!\")\n     *     lastSeen = v\n     * })\n     * src.setData(21)\n     * srcSeen // => 21\n     * lastSeen // => 42\n     */\n    public map<J>(\n        f: (t: T) => J,\n        extraSources: Store<any>[] = [],\n        onDestroy?: (f: () => void) => void\n    ): Store<J> {\n        return new MappedStore(this, f, extraSources, this._callbacks, f(this.data), onDestroy)\n    }\n\n    /**\n     * Monoidal map which results in a read-only store. 'undefined' is passed 'as is'\n     * Given a function 'f', will construct a new UIEventSource where the contents will always be \"f(this.data)'\n     */\n    public mapD<J>(f: (t: Exclude<T, undefined | null>) => J, extraSources: Store<any>[] = []): Store<J | undefined> {\n        return new MappedStore(\n            this,\n            (t) => {\n                if (t === undefined) {\n                    return undefined\n                }\n                if (t === null) {\n                    return null\n                }\n                return f(<Exclude<T, undefined | null>> t)\n            },\n            extraSources,\n            this._callbacks,\n            (this.data === undefined || this.data === null) ?(<undefined | null> this.data) : f(<any> this.data)\n        )\n    }\n\n    /**\n     * Two way sync with functions in both directions\n     * Given a function 'f', will construct a new UIEventSource where the contents will always be \"f(this.data)'\n     * @param f: The transforming function\n     * @param extraSources: also trigger the update if one of these sources change\n     * @param g: a 'backfunction to let the sync run in two directions. (data of the new UIEVEntSource, currentData) => newData\n     * @param allowUnregister: if set, the update will be halted if no listeners are registered\n     */\n    public sync<J>(\n        f: (t: T) => J,\n        extraSources: Store<any>[],\n        g: (j: J, t: T) => T,\n        allowUnregister = false\n    ): UIEventSource<J> {\n        const self = this\n\n        const stack = new Error().stack.split(\"\\n\")\n        const callee = stack[1]\n\n        const newSource = new UIEventSource<J>(f(this.data), \"map(\" + this.tag + \")@\" + callee)\n\n        const update = function () {\n            newSource.setData(f(self.data))\n            return allowUnregister && newSource._callbacks.length() === 0\n        }\n\n        this.addCallback(update)\n        for (const extraSource of extraSources) {\n            extraSource?.addCallback(update)\n        }\n\n        if (g !== undefined) {\n            newSource.addCallback((latest) => {\n                self.setData(g(latest, self.data))\n            })\n        }\n\n        return newSource\n    }\n\n    public syncWith(otherSource: UIEventSource<T>, reverseOverride = false): UIEventSource<T> {\n        this.addCallback((latest) => otherSource.setData(latest))\n        const self = this\n        otherSource.addCallback((latest) => self.setData(latest))\n        if (reverseOverride) {\n            if (otherSource.data !== undefined) {\n                this.setData(otherSource.data)\n            }\n        } else if (this.data === undefined) {\n            this.setData(otherSource.data)\n        } else {\n            otherSource.setData(this.data)\n        }\n        return this\n    }\n\n    set(value: T): void {\n        this.setData(value)\n    }\n\n    update(f: Updater<T> & ((value: T) => T)): void {\n        this.setData(f(this.data))\n    }\n}\n","import { UIEventSource } from \"../UIEventSource\"\n\n/**\n * UIEventsource-wrapper around localStorage\n */\nexport class LocalStorageSource {\n    static GetParsed<T>(key: string, defaultValue: T): UIEventSource<T> {\n        return LocalStorageSource.Get(key).sync(\n            (str) => {\n                if (str === undefined) {\n                    return defaultValue\n                }\n                try {\n                    return JSON.parse(str)\n                } catch {\n                    return defaultValue\n                }\n            },\n            [],\n            (value) => JSON.stringify(value)\n        )\n    }\n\n    static Get(key: string, defaultValue: string = undefined): UIEventSource<string> {\n        try {\n            const saved = localStorage.getItem(key)\n            const source = new UIEventSource<string>(saved ?? defaultValue, \"localstorage:\" + key)\n\n            source.addCallback((data) => {\n                try {\n                    localStorage.setItem(key, data)\n                } catch (e) {\n                    // Probably exceeded the quota with this item!\n                    // Lets nuke everything\n                    localStorage.clear()\n                }\n            })\n            return source\n        } catch (e) {\n            return new UIEventSource<string>(defaultValue)\n        }\n    }\n}\n"],"names":["Stores","millis","asLong","source","UIEventSource","run","promise","src","d","err","possibleSources","stable","list","Utils","Store","tag","__publicField","createStack","callstack","f","extraStoresToWatch","t","comparator","oldValue","v","mapped","sink","seenEventSources","newEventSource","resultData","millisToStabilize","newSource","self","latestData","condition","resolve","data","_","_ImmutableStore","callback","extraStores","MappedStore","ImmutableStore","ListenerTracker","index","toDelete","startTime","e","toDeleteElement","_MappedStore","upstream","upstreamListenerHandler","initialState","onDestroy","_a","stores","_b","_c","store","unregister","unr","newData","_UIEventSource","possibleSource","onError","str","parsed","fl","stringUIEventSource","b","extraSources","g","allowUnregister","callee","update","extraSource","latest","otherSource","reverseOverride","value","LocalStorageSource","key","defaultValue","saved"],"mappings":"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"}