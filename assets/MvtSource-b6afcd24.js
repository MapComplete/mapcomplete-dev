var V=Object.defineProperty;var k=(c,e,t)=>e in c?V(c,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):c[e]=t;var u=(c,e,t)=>(k(c,typeof e!="symbol"?e+"":e,t),t);import{U as P}from"./UIEventSource-b2e0ae35.js";import{P as x}from"./index-d8df05ab.js";const f=class f{constructor(e,t,r,a){u(this,"_size");u(this,"_x0");u(this,"_y0");this._size=e*Math.pow(2,a),this._x0=e*t,this._y0=e*r}static signedArea(e){let t=0;const r=e.length;let a=r-1,i,s;for(let l=0;l<r;l++)i=e[l],s=e[a],t+=(s.x-i.x)*(i.y+s.y),a=l;return t}static classifyRings(e){if(e.length<=0)throw"Now rings in polygon found";if(e.length==1)return[e];const t=[];let r;for(let a=0;a<e.length;a++){let i=e[a];const s=this.signedArea(i);if(s===0)continue;s<0===s<0?(r&&t.push(r),r=[i]):r.push(i)}return r&&t.push(r),t}toGeoJson(e,t,r){let a=this.encodeGeometry(e),i;switch(t){case 1:const o=[];for(let n=0;n<a.length;n++)o[n]=a[n][0];a=o,this.project(a);break;case 2:for(let n=0;n<a.length;n++)this.project(a[n]);break;case 3:i=f.classifyRings(a);for(let n=0;n<i.length;n++)for(let d=0;d<i[n].length;d++)this.project(i[n][d]);break}let s=f.geom_types[t],l;return a.length===1?l=(i??a)[0]:(l=i??a,s="Multi"+s),{type:"Feature",geometry:{type:s,coordinates:l},properties:r}}encodeGeometry(e){let t=0,r=0,a=[],i=[];for(let s=0;s<e.length;s++){let l=e[s],o=l&7,n=l>>3;if(o===1&&i.length!==0&&(a.push(i),i=[]),o===1||o===2){for(let d=0;d<n;d++){const F=e[s+d*2+1];t+=F>>1^-(F&1);const p=e[s+d*2+2];r+=p>>1^-(p&1),i.push([t,r])}s+=n*2}o===7&&(i.push([...i[0]]),s++)}return i.length>0&&a.push(i),a}project(e){const t=this._y0,r=this._x0,a=this._size;for(let i=0;i<e.length;i++){let s=e[i],l=180-(s[1]+t)*360/a;e[i]=[(s[0]+r)*360/a-180,360/Math.PI*Math.atan(Math.exp(l*Math.PI/180))-90]}return e}};u(f,"geom_types",["Unknown","Point","LineString","Polygon"]);let g=f;class h{static read(e,t){return e.readFields(h._readField,{version:0,name:"",features:[],keys:[],values:[],extent:0},t)}static _readField(e,t,r){e===15?t.version=r.readVarint():e===1?t.name=r.readString():e===2?t.features.push(y.read(r,r.readVarint()+r.pos)):e===3?t.keys.push(r.readString()):e===4?t.values.push(_.read(r,r.readVarint()+r.pos)):e===5&&(t.extent=r.readVarint())}static write(e,t){if(e.version&&t.writeVarintField(15,e.version),e.name&&t.writeStringField(1,e.name),e.features)for(var r=0;r<e.features.length;r++)t.writeMessage(2,y.write,e.features[r]);if(e.keys)for(r=0;r<e.keys.length;r++)t.writeStringField(3,e.keys[r]);if(e.values)for(r=0;r<e.values.length;r++)t.writeMessage(4,_.write,e.values[r]);e.extent&&t.writeVarintField(5,e.extent)}}class y{static read(e,t){return e.readFields(y._readField,{id:0,tags:[],type:0,geometry:[]},t)}static _readField(e,t,r){e===1?t.id=r.readVarint():e===2?r.readPackedVarint(t.tags):e===3?t.type=r.readVarint():e===4&&r.readPackedVarint(t.geometry)}static write(e,t){e.id&&t.writeVarintField(1,e.id),e.tags&&t.writePackedVarint(2,e.tags),e.type&&t.writeVarintField(3,e.type),e.geometry&&t.writePackedVarint(4,e.geometry)}}const w=class w{static read(e,t){return e.readFields(w._readField,{string_value:"",float_value:0,double_value:0,int_value:0,uint_value:0,sint_value:0,bool_value:!1},t)}static write(e,t){e.string_value&&t.writeStringField(1,e.string_value),e.float_value&&t.writeFloatField(2,e.float_value),e.double_value&&t.writeDoubleField(3,e.double_value),e.int_value&&t.writeVarintField(4,e.int_value),e.uint_value&&t.writeVarintField(5,e.uint_value),e.sint_value&&t.writeSVarintField(6,e.sint_value),e.bool_value&&t.writeBooleanField(7,e.bool_value)}};u(w,"_readField",function(e,t,r){e===1?t.string_value=r.readString():e===2?t.float_value=r.readFloat():e===3?t.double_value=r.readDouble():e===4?t.int_value=r.readVarint(!0):e===5?t.uint_value=r.readVarint():e===6?t.sint_value=r.readSVarint():e===7&&(t.bool_value=r.readBoolean())});let _=w;const v=class v{static read(e,t){return e.readFields(v._readField,{layers:[]},t)}static _readField(e,t,r){e===3&&t.layers.push(h.read(r,r.readVarint()+r.pos))}static write(e,t){if(e.layers)for(var r=0;r<e.layers.length;r++)t.writeMessage(3,h.write,e.layers[r])}};u(v,"GeomType",{UNKNOWN:{value:0,options:{}},POINT:{value:1,options:{}},LINESTRING:{value:2,options:{}},POLYGON:{value:3,options:{}}});let m=v;class R{constructor(e,t,r,a,i,s){u(this,"features");u(this,"x");u(this,"y");u(this,"z");u(this,"_url");u(this,"_layerName");u(this,"_features",new P([]));u(this,"currentlyRunning");this._url=e,this._layerName=i,this.x=t,this.y=r,this.z=a,this.updateAsync(),this.features=this._features.map(l=>l===void 0||(s==null?void 0:s.data)===!1?[]:l,[s])}async updateAsync(){this.currentlyRunning||(this.currentlyRunning=this.download()),await this.currentlyRunning}getValue(e){if(e.string_value!=="")return e.string_value;if(e.double_value!==0)return e.double_value;if(e.float_value!==0)return e.float_value;if(e.int_value!==0)return e.int_value;if(e.uint_value!==0)return e.uint_value;if(e.sint_value!==0)return e.sint_value;if(e.bool_value!==!1)return e.bool_value}async download(){try{const e=await fetch(this._url);if(e.status!==200){console.error("Could not download tile "+this._url);return}const t=await e.arrayBuffer(),r=m.read(new x(t),void 0),a=r.layers;let i=r.layers[0];if(a.length>1){if(!this._layerName)throw"Multiple layers in the downloaded tile, but no layername is given to choose from";i=a.find(o=>o.name===this._layerName)}if(!i)return;const s=new g(i.extent,this.x,this.y,this.z),l=[];for(const o of i.features){const n=this.inflateProperties(o.tags,i.keys,i.values);l.push(s.toGeoJson(o.geometry,o.type,n))}this._features.setData(l)}catch(e){console.error("Could not download MVT tile due to",e)}}inflateProperties(e,t,r){const a={};for(let s=0;s<e.length;s+=2)a[t[e[s]]]=this.getValue(r[e[s+1]]);let i;switch(a.osm_type){case"N":i="node";break;case"W":i="way";break;case"R":i="relation";break}return a.id=i+"/"+a.osm_id,delete a.osm_id,delete a.osm_type,a}}export{R as M};
//# sourceMappingURL=MvtSource-b6afcd24.js.map
