{"version":3,"file":"UIEventSource-f4363691.js","sources":["../../src/Logic/UIEventSource.ts"],"sourcesContent":["import { Utils } from \"../Utils\"\nimport { Readable, Subscriber, Unsubscriber, Updater, Writable } from \"svelte/store\"\n\n/**\n * Various static utils\n */\nexport class Stores {\n    public static Chronic(millis: number, asLong: () => boolean = undefined): Store<Date> {\n        const source = new UIEventSource<Date>(undefined)\n\n        function run() {\n            source.setData(new Date())\n            if (Utils.runningFromConsole) {\n                return\n            }\n            if (asLong === undefined || asLong()) {\n                window.setTimeout(run, millis)\n            }\n        }\n\n        run()\n        return source\n    }\n\n    public static FromPromiseWithErr<T>(\n        promise: Promise<T>\n    ): Store<{ success: T } | { error: any }> {\n        return UIEventSource.FromPromiseWithErr(promise)\n    }\n\n    /**\n     * Converts a promise into a UIVentsource, sets the UIEVentSource when the result is calculated.\n     * If the promise fails, the value will stay undefined\n     * @param promise\n     * @constructor\n     */\n    public static FromPromise<T>(promise: Promise<T>): Store<T | undefined> {\n        const src = new UIEventSource<T>(undefined)\n        promise?.then((d) => src.setData(d))\n        promise?.catch((err) => console.warn(\"Promise failed:\", err))\n        return src\n    }\n\n    public static flatten<X>(source: Store<Store<X>>, possibleSources?: Store<any>[]): Store<X> {\n        return UIEventSource.flatten(source, possibleSources)\n    }\n\n    /**\n     * Given a UIEVentSource with a list, returns a new UIEventSource which is only updated if the _contents_ of the list are different.\n     * E.g.\n     * const src = new UIEventSource([1,2,3])\n     * const stable = UIEventSource.ListStabilized(src)\n     * src.addCallback(_ => console.log(\"src pinged\"))\n     * stable.addCallback(_ => console.log(\"stable pinged))\n     * src.setDate([...src.data])\n     *\n     * This will only trigger 'src pinged'\n     *\n     * @param src\n     * @constructor\n     */\n    public static ListStabilized<T>(src: Store<T[]>): Store<T[]> {\n        const stable = new UIEventSource<T[]>(undefined)\n        src.addCallbackAndRun((list) => {\n            if (list === undefined) {\n                stable.setData(undefined)\n                return\n            }\n            if (Utils.sameList(stable.data, list)) {\n                return\n            }\n            stable.setData(list)\n        })\n        return stable\n    }\n}\n\nexport abstract class Store<T> implements Readable<T> {\n    abstract readonly data: T\n\n    /**\n     * Optional value giving a title to the UIEventSource, mainly used for debugging\n     */\n    public readonly tag: string | undefined\n\n    constructor(tag: string = undefined) {\n        this.tag = tag\n        if (tag === undefined || tag === \"\") {\n            let createStack = Utils.runningFromConsole\n            if (!Utils.runningFromConsole) {\n                createStack = window.location.hostname === \"127.0.0.1\"\n            }\n            if (createStack) {\n                const callstack = new Error().stack.split(\"\\n\")\n                this.tag = callstack[1]\n            }\n        }\n    }\n\n    abstract map<J>(f: (t: T) => J): Store<J>\n    abstract map<J>(f: (t: T) => J, extraStoresToWatch: Store<any>[]): Store<J>\n    abstract map<J>(\n        f: (t: T) => J,\n        extraStoresToWatch: Store<any>[],\n        callbackDestroyFunction: (f: () => void) => void\n    ): Store<J>\n    M\n    public mapD<J>(\n        f: (t: Exclude<T, undefined | null>) => J,\n        extraStoresToWatch?: Store<any>[],\n        callbackDestroyFunction?: (f: () => void) => void\n    ): Store<J> {\n        return this.map((t) => {\n            if (t === undefined) {\n                return undefined\n            }\n            if (t === null) {\n                return null\n            }\n            return f(<Exclude<T, undefined | null>>t)\n        }, extraStoresToWatch)\n    }\n\n    /**\n     * Add a callback function which will run on future data changes\n     */\n    abstract addCallback(callback: (data: T) => void): () => void\n\n    /**\n     * Adds a callback function, which will be run immediately.\n     * Only triggers if the current data is defined\n     */\n    abstract addCallbackAndRunD(callback: (data: T) => void): () => void\n\n    /**\n     * Add a callback function which will run on future data changes\n     * Only triggers if the data is defined\n     */\n    abstract addCallbackD(callback: (data: T) => void): () => void\n\n    /**\n     * Adds a callback function, which will be run immediately.\n     * Only triggers if the current data is defined\n     */\n    abstract addCallbackAndRun(callback: (data: T) => void): () => void\n\n    public withEqualityStabilized(\n        comparator: (t: T | undefined, t1: T | undefined) => boolean\n    ): Store<T> {\n        let oldValue = undefined\n        return this.map((v) => {\n            if (v == oldValue) {\n                return oldValue\n            }\n            if (comparator(oldValue, v)) {\n                return oldValue\n            }\n            oldValue = v\n            return v\n        })\n    }\n\n    /**\n     * Monadic bind function\n     *\n     * // simple test with bound and immutablestores\n     * const src = new UIEventSource<number>(3)\n     * const bound = src.bind(i => new ImmutableStore(i * 2))\n     * let lastValue = undefined;\n     * bound.addCallbackAndRun(v => lastValue = v);\n     * lastValue // => 6\n     * src.setData(21)\n     * lastValue // => 42\n     *\n     * // simple test with bind over a mapped value\n     * const src = new UIEventSource<number>(0)\n     * const srcs : UIEventSource<string>[] = [new UIEventSource<string>(\"a\"), new UIEventSource<string>(\"b\")]\n     * const bound = src.map(i => -i).bind(i => srcs[i])\n     * let lastValue : string = undefined;\n     * bound.addCallbackAndRun(v => lastValue = v);\n     * lastValue // => \"a\"\n     * src.setData(-1)\n     * lastValue // => \"b\"\n     * srcs[1].setData(\"xyz\")\n     * lastValue // => \"xyz\"\n     * srcs[0].setData(\"def\")\n     * lastValue // => \"xyz\"\n     * src.setData(0)\n     * lastValue // => \"def\"\n     *\n     *\n     *\n     * // advanced test with bound\n     * const src = new UIEventSource<number>(0)\n     * const srcs : UIEventSource<string>[] = [new UIEventSource<string>(\"a\"), new UIEventSource<string>(\"b\")]\n     * const bound = src.bind(i => srcs[i])\n     * let lastValue : string = undefined;\n     * bound.addCallbackAndRun(v => lastValue = v);\n     * lastValue // => \"a\"\n     * src.setData(1)\n     * lastValue // => \"b\"\n     * srcs[1].setData(\"xyz\")\n     * lastValue // => \"xyz\"\n     * srcs[0].setData(\"def\")\n     * lastValue // => \"xyz\"\n     * src.setData(0)\n     * lastValue // => \"def\"\n     */\n    public bind<X>(f: (t: T) => Store<X>): Store<X> {\n        const mapped = this.map(f)\n        const sink = new UIEventSource<X>(undefined)\n        const seenEventSources = new Set<Store<X>>()\n        mapped.addCallbackAndRun((newEventSource) => {\n            if (newEventSource === null) {\n                sink.setData(null)\n                return\n            }\n            if (newEventSource === undefined) {\n                sink.setData(undefined)\n                return\n            }\n            if (seenEventSources.has(newEventSource)) {\n                // Already seen, so we don't have to add a callback, just update the value\n                sink.setData(newEventSource.data)\n                return\n            }\n            seenEventSources.add(newEventSource)\n            newEventSource.addCallbackAndRun((resultData) => {\n                if (mapped.data === newEventSource) {\n                    sink.setData(resultData)\n                }\n            })\n        })\n\n        return sink\n    }\n\n    public bindD<X>(f: (t: Exclude<T, undefined | null>) => Store<X>): Store<X> {\n        return this.bind((t) => {\n            if (t === undefined || t === null) {\n                return <undefined | null>t\n            }\n            return f(<Exclude<T, undefined | null>>t)\n        })\n    }\n    public stabilized(millisToStabilize): Store<T> {\n        if (Utils.runningFromConsole) {\n            return this\n        }\n\n        const newSource = new UIEventSource<T>(this.data)\n\n        const self = this\n        this.addCallback((latestData) => {\n            window.setTimeout(() => {\n                if (self.data == latestData) {\n                    // compare by reference.\n                    // Note that 'latestData' and 'self.data' are both from the same UIEVentSource, but both are dereferenced at a different time\n                    newSource.setData(latestData)\n                }\n            }, millisToStabilize)\n        })\n\n        return newSource\n    }\n\n    /**\n     * Converts the uiEventSource into a promise.\n     * The promise will return the value of the store if the given condition evaluates to true\n     * @param condition an optional condition, default to 'store.value !== undefined'\n     * @constructor\n     */\n    public AsPromise(condition?: (t: T) => boolean): Promise<T> {\n        const self = this\n        condition = condition ?? ((t) => t !== undefined)\n        return new Promise((resolve) => {\n            const data = self.data\n            if (condition(data)) {\n                resolve(data)\n            } else {\n                self.addCallbackD((data) => {\n                    if (condition(data)) {\n                        resolve(data)\n                        return true // return true to unregister as we only need to be called once\n                    } else {\n                        return false // We didn't resolve yet, wait for the next ping\n                    }\n                })\n            }\n        })\n    }\n\n    /**\n     * Same as 'addCallbackAndRun', added to be compatible with Svelte\n     */\n    public subscribe(run: Subscriber<T> & ((value: T) => void), _?): Unsubscriber {\n        // We don't need to do anything with 'invalidate', see\n        // https://github.com/sveltejs/svelte/issues/3859\n\n        // Note: run is wrapped in an anonymous function. 'Run' returns the value. If this value happens to be true, it would unsubscribe\n        return this.addCallbackAndRun((v) => {\n            run(v)\n        })\n    }\n}\n\nexport class ImmutableStore<T> extends Store<T> {\n    public readonly data: T\n    static FALSE = new ImmutableStore<boolean>(false)\n    static TRUE = new ImmutableStore<boolean>(true)\n    constructor(data: T) {\n        super()\n        this.data = data\n    }\n\n    private static readonly pass: () => void = () => {}\n\n    addCallback(_: (data: T) => void): () => void {\n        // pass: data will never change\n        return ImmutableStore.pass\n    }\n\n    addCallbackAndRun(callback: (data: T) => void): () => void {\n        callback(this.data)\n        // no callback registry: data will never change\n        return ImmutableStore.pass\n    }\n\n    addCallbackAndRunD(callback: (data: T) => void): () => void {\n        if (this.data !== undefined) {\n            callback(this.data)\n        }\n        // no callback registry: data will never change\n        return ImmutableStore.pass\n    }\n\n    addCallbackD(_: (data: T) => void): () => void {\n        // pass: data will never change\n        return ImmutableStore.pass\n    }\n\n    map<J>(\n        f: (t: T) => J,\n        extraStores: Store<any>[] = undefined,\n        ondestroyCallback?: (f: () => void) => void\n    ): ImmutableStore<J> {\n        if (extraStores?.length > 0) {\n            return new MappedStore(this, f, extraStores, undefined, f(this.data), ondestroyCallback)\n        }\n        return new ImmutableStore<J>(f(this.data))\n    }\n}\n\n/**\n * Keeps track of the callback functions\n */\nclass ListenerTracker<T> {\n    public pingCount = 0\n    private readonly _callbacks: ((t: T) => boolean | void | any)[] = []\n\n    /**\n     * Adds a callback which can be called; a function to unregister is returned\n     */\n    public addCallback(callback: (t: T) => boolean | void | any): () => void {\n        if (callback === console.log) {\n            // This ^^^ actually works!\n            throw \"Don't add console.log directly as a callback - you'll won't be able to find it afterwards. Wrap it in a lambda instead.\"\n        }\n        this._callbacks.push(callback)\n\n        // Give back an unregister-function!\n        return () => {\n            const index = this._callbacks.indexOf(callback)\n            if (index >= 0) {\n                this._callbacks.splice(index, 1)\n            }\n        }\n    }\n\n    /**\n     * Call all the callbacks.\n     * Returns the number of registered callbacks\n     */\n    public ping(data: T): number {\n        this.pingCount++\n        let toDelete = undefined\n        let startTime = new Date().getTime() / 1000\n        for (const callback of this._callbacks) {\n            try {\n                if (callback(data) === true) {\n                    // This callback wants to be deleted\n                    // Note: it has to return precisely true in order to avoid accidental deletions\n                    if (toDelete === undefined) {\n                        toDelete = [callback]\n                    } else {\n                        toDelete.push(callback)\n                    }\n                }\n            } catch (e) {\n                console.error(\"Got an error while running a callback:\", e)\n            }\n        }\n        let endTime = new Date().getTime() / 1000\n        if (endTime - startTime > 500) {\n            console.trace(\n                \"Warning: a ping took more then 500ms; this is probably a performance issue\"\n            )\n        }\n        if (toDelete !== undefined) {\n            for (const toDeleteElement of toDelete) {\n                this._callbacks.splice(this._callbacks.indexOf(toDeleteElement), 1)\n            }\n        }\n        return this._callbacks.length\n    }\n\n    length() {\n        return this._callbacks.length\n    }\n}\n\n/**\n * The mapped store is a helper type which does the mapping of a function.\n */\nclass MappedStore<TIn, T> extends Store<T> {\n    private static readonly pass: () => {}\n    private readonly _upstream: Store<TIn>\n    private readonly _upstreamCallbackHandler: ListenerTracker<TIn> | undefined\n    private _upstreamPingCount: number = -1\n    private _unregisterFromUpstream: () => void\n    private readonly _f: (t: TIn) => T\n    private readonly _extraStores: Store<any>[] | undefined\n    private _unregisterFromExtraStores: (() => void)[] | undefined\n    private _callbacks: ListenerTracker<T> = new ListenerTracker<T>()\n    private _callbacksAreRegistered = false\n\n    constructor(\n        upstream: Store<TIn>,\n        f: (t: TIn) => T,\n        extraStores: Store<any>[],\n        upstreamListenerHandler: ListenerTracker<TIn> | undefined,\n        initialState: T,\n        onDestroy?: (f: () => void) => void\n    ) {\n        super()\n        this._upstream = upstream\n        this._upstreamCallbackHandler = upstreamListenerHandler\n        this._f = f\n        this._data = initialState\n        this._upstreamPingCount = upstreamListenerHandler?.pingCount\n        this._extraStores = extraStores\n        this.registerCallbacksToUpstream()\n        if (onDestroy !== undefined) {\n            onDestroy(() => this.unregisterFromUpstream())\n        }\n    }\n\n    private _data: T\n\n    /**\n     * Gets the current data from the store\n     *\n     * const src = new UIEventSource(21)\n     * const mapped = src.map(i => i * 2)\n     * src.setData(3)\n     * mapped.data // => 6\n     */\n    get data(): T {\n        if (!this._callbacksAreRegistered) {\n            // Callbacks are not registered, so we haven't been listening for updates from the upstream which might have changed\n            if (this._upstreamCallbackHandler?.pingCount != this._upstreamPingCount) {\n                // Upstream has pinged - let's update our data first\n                this._data = this._f(this._upstream.data)\n            }\n            return this._data\n        }\n        return this._data\n    }\n\n    map<J>(\n        f: (t: T) => J,\n        extraStores: Store<any>[] = undefined,\n        ondestroyCallback?: (f: () => void) => void\n    ): Store<J> {\n        let stores: Store<any>[] = undefined\n        if (extraStores?.length > 0 || this._extraStores?.length > 0) {\n            stores = []\n        }\n        if (extraStores?.length > 0) {\n            stores?.push(...extraStores)\n        }\n        if (this._extraStores?.length > 0) {\n            this._extraStores?.forEach((store) => {\n                if (stores.indexOf(store) < 0) {\n                    stores.push(store)\n                }\n            })\n        }\n        return new MappedStore(\n            this,\n            f, // we could fuse the functions here (e.g. data => f(this._f(data), but this might result in _f being calculated multiple times, breaking things\n            stores,\n            this._callbacks,\n            f(this.data),\n            ondestroyCallback\n        )\n    }\n\n    addCallback(callback: (data: T) => any | boolean | void): () => void {\n        if (!this._callbacksAreRegistered) {\n            // This is the first callback that is added\n            // We register this 'map' to the upstream object and all the streams\n            this.registerCallbacksToUpstream()\n        }\n        const unregister = this._callbacks.addCallback(callback)\n        return () => {\n            unregister()\n            if (this._callbacks.length() == 0) {\n                this.unregisterFromUpstream()\n            }\n        }\n    }\n\n    addCallbackAndRun(callback: (data: T) => any | boolean | void): () => void {\n        const unregister = this.addCallback(callback)\n        const doRemove = callback(this.data)\n        if (doRemove === true) {\n            unregister()\n            return MappedStore.pass\n        }\n        return unregister\n    }\n\n    addCallbackAndRunD(callback: (data: T) => any | boolean | void): () => void {\n        return this.addCallbackAndRun((data) => {\n            if (data !== undefined) {\n                return callback(data)\n            }\n        })\n    }\n\n    addCallbackD(callback: (data: T) => any | boolean | void): () => void {\n        return this.addCallback((data) => {\n            if (data !== undefined) {\n                return callback(data)\n            }\n        })\n    }\n\n    private unregisterFromUpstream() {\n        this._callbacksAreRegistered = false\n        this._unregisterFromUpstream()\n        this._unregisterFromExtraStores?.forEach((unr) => unr())\n    }\n\n    private registerCallbacksToUpstream() {\n        const self = this\n\n        this._unregisterFromUpstream = this._upstream.addCallback((_) => self.update())\n        this._unregisterFromExtraStores = this._extraStores?.map((store) =>\n            store?.addCallback((_) => self.update())\n        )\n        this._callbacksAreRegistered = true\n    }\n\n    private update(): void {\n        const newData = this._f(this._upstream.data)\n        this._upstreamPingCount = this._upstreamCallbackHandler?.pingCount\n        if (this._data === newData) {\n            return\n        }\n        this._data = newData\n        this._callbacks.ping(this._data)\n    }\n}\n\nexport class UIEventSource<T> extends Store<T> implements Writable<T> {\n    private static readonly pass: () => {}\n    public data: T\n    _callbacks: ListenerTracker<T> = new ListenerTracker<T>()\n\n    constructor(data: T, tag: string = \"\") {\n        super(tag)\n        this.data = data\n    }\n\n    public static flatten<X>(\n        source: Store<Store<X>>,\n        possibleSources?: Store<any>[]\n    ): UIEventSource<X> {\n        const sink = new UIEventSource<X>(source.data?.data)\n\n        source.addCallback((latestData) => {\n            sink.setData(latestData?.data)\n            latestData.addCallback((data) => {\n                if (source.data !== latestData) {\n                    return true\n                }\n                sink.setData(data)\n            })\n        })\n\n        for (const possibleSource of possibleSources ?? []) {\n            possibleSource?.addCallback(() => {\n                sink.setData(source.data?.data)\n            })\n        }\n\n        return sink\n    }\n\n    /**\n     * Converts a promise into a UIVentsource, sets the UIEVentSource when the result is calculated.\n     * If the promise fails, the value will stay undefined, but 'onError' will be called\n     */\n    public static FromPromise<T>(\n        promise: Promise<T>,\n        onError: (e: any) => void = undefined\n    ): UIEventSource<T> {\n        const src = new UIEventSource<T>(undefined)\n        promise?.then((d) => src.setData(d))\n        promise?.catch((err) => {\n            if (onError !== undefined) {\n                onError(err)\n            } else {\n                console.warn(\"Promise failed:\", err)\n            }\n        })\n        return src\n    }\n\n    /**\n     * Converts a promise into a UIVentsource, sets the UIEVentSource when the result is calculated.\n     * If the promise fails, the value will stay undefined\n     * @param promise\n     * @constructor\n     */\n    public static FromPromiseWithErr<T>(\n        promise: Promise<T>\n    ): UIEventSource<{ success: T } | { error: any } | undefined> {\n        const src = new UIEventSource<{ success: T } | { error: any }>(undefined)\n        promise\n            ?.then((d) => src.setData({ success: d }))\n            ?.catch((err) => src.setData({ error: err }))\n        return src\n    }\n\n    /**\n     *\n     * @param source\n     * UIEventSource.asInt(new UIEventSource(\"123\")).data // => 123\n     * UIEventSource.asInt(new UIEventSource(\"123456789\")).data // => 123456789\n     *\n     * const srcStr = new UIEventSource(\"123456789\"))\n     * const srcInt = UIEventSource.asInt(srcStr)\n     * srcInt.setData(987654321)\n     * srcStr.data // => \"987654321\"\n     */\n    public static asInt(source: UIEventSource<string>): UIEventSource<number> {\n        return source.sync(\n            (str) => {\n                let parsed = parseInt(str)\n                return isNaN(parsed) ? undefined : parsed\n            },\n            [],\n            (fl) => {\n                if (fl === undefined || isNaN(fl)) {\n                    return undefined\n                }\n                return \"\" + fl\n            }\n        )\n    }\n\n    /**\n     * UIEventSource.asFloat(new UIEventSource(\"123\")).data // => 123\n     * UIEventSource.asFloat(new UIEventSource(\"123456789\")).data // => 123456789\n     * UIEventSource.asFloat(new UIEventSource(\"0.5\")).data // => 0.5\n     * UIEventSource.asFloat(new UIEventSource(\"0.125\")).data // => 0.125\n     * UIEventSource.asFloat(new UIEventSource(\"0.0000000001\")).data // => 0.0000000001\n     *\n     *\n     * const srcStr = new UIEventSource(\"123456789\"))\n     * const srcInt = UIEventSource.asFloat(srcStr)\n     * srcInt.setData(987654321)\n     * srcStr.data // => \"987654321\"\n     * @param source\n     */\n\n    public static asFloat(source: UIEventSource<string>): UIEventSource<number> {\n        return source.sync(\n            (str) => {\n                let parsed = parseFloat(str)\n                return isNaN(parsed) ? undefined : parsed\n            },\n            [],\n            (fl) => {\n                if (fl === undefined || isNaN(fl)) {\n                    return undefined\n                }\n                return \"\" + fl\n            }\n        )\n    }\n\n    static asBoolean(stringUIEventSource: UIEventSource<string>): UIEventSource<boolean> {\n        return stringUIEventSource.sync(\n            (str) => str === \"true\",\n            [],\n            (b) => \"\" + b\n        )\n    }\n\n    /**\n     * Create a new UIEVentSource. Whenever 'source' changes, the returned UIEventSource will get this value as well.\n     * However, this value can be overriden without affecting source\n     */\n    static feedFrom<T>(store: Store<T>): UIEventSource<T> {\n        const src = new UIEventSource(store.data)\n        store.addCallback((t) => src.setData(t))\n        return src\n    }\n\n    /**\n     * Adds a callback\n     *\n     * If the result of the callback is 'true', the callback is considered finished and will be removed again\n     * @param callback\n     */\n    public addCallback(callback: (latestData: T) => boolean | void | any): () => void {\n        return this._callbacks.addCallback(callback)\n    }\n\n    public addCallbackAndRun(callback: (latestData: T) => boolean | void | any): () => void {\n        const doDeleteCallback = callback(this.data)\n        if (doDeleteCallback !== true) {\n            return this.addCallback(callback)\n        } else {\n            return UIEventSource.pass\n        }\n    }\n\n    public addCallbackAndRunD(callback: (data: T) => void): () => void {\n        return this.addCallbackAndRun((data) => {\n            if (data !== undefined && data !== null) {\n                return callback(data)\n            }\n        })\n    }\n\n    public addCallbackD(callback: (data: T) => void): () => void {\n        return this.addCallback((data) => {\n            if (data !== undefined && data !== null) {\n                return callback(data)\n            }\n        })\n    }\n\n    public setData(t: T): UIEventSource<T> {\n        if (this.data == t) {\n            // MUST COMPARE BY REFERENCE!\n            return\n        }\n        this.data = t\n        this._callbacks.ping(t)\n        return this\n    }\n\n    public ping(): void {\n        this._callbacks.ping(this.data)\n    }\n\n    /**\n     * Monoidal map which results in a read-only store\n     * Given a function 'f', will construct a new UIEventSource where the contents will always be \"f(this.data)'\n     * @param f The transforming function\n     * @param extraSources also trigger the update if one of these sources change\n     * @param onDestroy a callback that can trigger the destroy function\n     *\n     * const src = new UIEventSource<number>(10)\n     * const store = src.map(i => i * 2)\n     * store.data // => 20\n     * let srcSeen = undefined;\n     * src.addCallback(v => {\n     *     console.log(\"Triggered\")\n     *     srcSeen = v\n     * })\n     * let lastSeen = undefined\n     * store.addCallback(v => {\n     *     console.log(\"Triggered!\")\n     *     lastSeen = v\n     * })\n     * src.setData(21)\n     * srcSeen // => 21\n     * lastSeen // => 42\n     */\n    public map<J>(\n        f: (t: T) => J,\n        extraSources: Store<any>[] = [],\n        onDestroy?: (f: () => void) => void\n    ): Store<J> {\n        return new MappedStore(this, f, extraSources, this._callbacks, f(this.data), onDestroy)\n    }\n\n    /**\n     * Monoidal map which results in a read-only store. 'undefined' is passed 'as is'\n     * Given a function 'f', will construct a new UIEventSource where the contents will always be \"f(this.data)'\n     */\n    public mapD<J>(\n        f: (t: Exclude<T, undefined | null>) => J,\n        extraSources: Store<any>[] = [],\n        callbackDestroyFunction?: (f: () => void) => void\n    ): Store<J | undefined> {\n        return new MappedStore(\n            this,\n            (t) => {\n                if (t === undefined) {\n                    return undefined\n                }\n                if (t === null) {\n                    return null\n                }\n                return f(<Exclude<T, undefined | null>>t)\n            },\n            extraSources,\n            this._callbacks,\n            this.data === undefined || this.data === null\n                ? <undefined | null>this.data\n                : f(<any>this.data),\n            callbackDestroyFunction\n        )\n    }\n\n    /**\n     * Two way sync with functions in both directions\n     * Given a function 'f', will construct a new UIEventSource where the contents will always be \"f(this.data)'\n     * @param f The transforming function\n     * @param extraSources also trigger the update if one of these sources change\n     * @param g a 'backfunction to let the sync run in two directions. (data of the new UIEVEntSource, currentData) => newData\n     * @param allowUnregister if set, the update will be halted if no listeners are registered\n     */\n    public sync<J>(\n        f: (t: T) => J,\n        extraSources: Store<any>[],\n        g: (j: J, t: T) => T,\n        allowUnregister = false\n    ): UIEventSource<J> {\n        const self = this\n\n        const stack = new Error().stack.split(\"\\n\")\n        const callee = stack[1]\n\n        const newSource = new UIEventSource<J>(f(this.data), \"map(\" + this.tag + \")@\" + callee)\n\n        const update = function () {\n            newSource.setData(f(self.data))\n            return allowUnregister && newSource._callbacks.length() === 0\n        }\n\n        this.addCallback(update)\n        for (const extraSource of extraSources) {\n            extraSource?.addCallback(update)\n        }\n\n        if (g !== undefined) {\n            newSource.addCallback((latest) => {\n                self.setData(g(latest, self.data))\n            })\n        }\n\n        return newSource\n    }\n\n    public syncWith(otherSource: UIEventSource<T>, reverseOverride = false): UIEventSource<T> {\n        this.addCallback((latest) => otherSource.setData(latest))\n        const self = this\n        otherSource.addCallback((latest) => self.setData(latest))\n        if (reverseOverride) {\n            if (otherSource.data !== undefined) {\n                this.setData(otherSource.data)\n            }\n        } else if (this.data === undefined) {\n            this.setData(otherSource.data)\n        } else {\n            otherSource.setData(this.data)\n        }\n        return this\n    }\n\n    set(value: T): void {\n        this.setData(value)\n    }\n\n    update(f: Updater<T> & ((value: T) => T)): void {\n        this.setData(f(this.data))\n    }\n}\n"],"names":["Stores","millis","asLong","source","UIEventSource","run","Utils","promise","src","d","err","possibleSources","stable","list","Store","tag","__publicField","createStack","callstack","f","extraStoresToWatch","callbackDestroyFunction","t","comparator","oldValue","v","mapped","sink","seenEventSources","newEventSource","resultData","millisToStabilize","newSource","self","latestData","condition","resolve","data","_","_ImmutableStore","callback","extraStores","ondestroyCallback","MappedStore","ImmutableStore","ListenerTracker","index","toDelete","startTime","e","toDeleteElement","_MappedStore","upstream","upstreamListenerHandler","initialState","onDestroy","_a","stores","_b","_c","store","unregister","unr","newData","_UIEventSource","possibleSource","onError","str","parsed","fl","stringUIEventSource","b","extraSources","g","allowUnregister","callee","update","extraSource","latest","otherSource","reverseOverride","value"],"mappings":"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"}